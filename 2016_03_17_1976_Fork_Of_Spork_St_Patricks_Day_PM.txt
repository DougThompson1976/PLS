Rem FOS (Fork of Spork) Library, by Douglas E Thompson  Douglas.E.Thompson@gmail.com
Rem License - Eclipse Public License 1.0 (same as Sporklisp) with recognition of Peter Norvig for design attribution
Rem See the License section below (search for "Eclipse") - https://github.com/kanaka/mal/blob/master/process/guide.md

Rem Note: added Rem MAL_L  Make A Lisp - from Github - prefix for the diagram...
Rem - MAL is not part of original VBA / SporkLisp, but part of the PicoLisp "ReFactoring / Makeover"

Rem Module List - and single file integration status

Rem* ARY_M  ArrayLib
Rem* CDP_C  CodePrinter
Rem* CDP_M  CodePrintingLib
Rem* CLT_M  CollectionLib
Rem* CMP_M  ComparisonLib
Rem* DIT_M  DictionaryLib
Rem* FOS_M  Fork Of Spork Form - linkage - code to put into a Form (remove prefix)
Rem* FRM_M  Form - generic linkage from Parachute Sample - code to put into a Form (remove prefix)
Rem* GC__C  GenericComparer
Rem* GCD_C  GenericComparerDict
Rem* GCF_C  GenericComparerFn
Rem* GCL_C  GenericComparerList
Rem* GCN_C  GenericComparerNot
Rem* GCS_C  GenericComparerSet
Rem* GME_C  GenericMapEntry
Rem* GS__C  GenericSort
Rem* ICL_C  IClosure
Rem* ICP_C  IComparator
Rem* IDI_C  IDistributor
Rem* IFN_C  IFn
Rem* IOL_M  IOLib
Rem* ISQ_C  ISeq
Rem* ISZ_C  ISerializable
Rem* ITA_C  IteratorArray
Rem* ITC_C  IteratorColl
Rem* ITN_C  IteratorConc
Rem* ITT_C  IteratorConstant
Rem* ITY_C  IteratorDict_(Dictionary)
Rem* ITZ_C  IteratorSeq_Z(LAST)
Rem* JSP_C  JSONParser
Rem* JSS_C  JSONScript
Rem* LEC_M  LibEnumsAndConstants
Rem* LVM_M  Logistics Virtual Machine - from Parachute Sample
Rem* LI__M  Lisp
Rem* LIC_C  LispClosure
Rem* LIE_M  LispExcelInterop
Rem* LII_C  LispInterpreter
Rem* LIP_M  LispPrimitive
Rem* LIR_L  LispProcedure
Rem* MAL_L  Make A Lisp - from Github - prefix for the diagram...
Rem  NME_M  NameLib
Rem  PAR_M  ParsingLib
Rem  REP_M  REPL
Rem  SQA_M  SeqArr
Rem  SQC_C  SeqColl
Rem  SQE_C  SeqConsCell
Rem  SQL_C  SeqConsLazy
Rem  SQT_C  SeqDict
Rem  SQX_M  SeqLib_X(GENERIC_SEQ)
Rem  SRL_M  SerializationLib
Rem  SRR_C  SetLib_RR(SET_oLI__M_2_R)
Rem  SRT_M  SortLib
Rem  STR_C  StringBuilder
Rem  UNT_M  UnitTestLib
Rem  UTL_M  UtilitiesLib
Rem* VRC_M  VersionControlLib
Rem  XML_C  Xml_Parser

Option Explicit

Private n As Long

Rem from LII_C LispInterpreter "Instance" Variable - localenv - now public

Public localenv As Dictionary
Rem localenv is now global to current Excel instance - for porting reasons (i.e. RFO BASIC)

'CDP_C Enum moved here to get rid of error
Public Enum ParseState
    code
    ResWord
    Comment
End Enum


'CMP_M_ below enum and Const from Comparison Lib
Public Enum ComparisonType  'should be the main one used project wide, other instances prefixed with x/y/z
    generic = 0
    text = 1
    int32 = 2
    float32 = 3
    float64 = 4
End Enum

Private Const epsilon As Double = 10 ^ -6

Public comptype As ComparisonType ''GC__C
'Implements IComparator - had to comment out - not quite sure how to mimic VBA Class stuff in a Module... yet...

'ICP_C IComparator
Public Enum Comparison 'should be the main one used project wide, other instances prefixed with x/y/z
                       'this one is in a class... would it impact the project?

    lessthan = -1
    equal = 0
    greaterthan = 1
End Enum

Rem Mapping 5W1H to the core computing Sequence (Nouns), Conditional (Verbs), and Looping (Connectors)
Rem - is the essential computing methodology for all of the below,

Rem - via REM and Prefixes (Hungarian Notation, OOP / C++ style Name Mangling)

Rem - Use Risk Management - Use Case Functionality (Fast / Cheap / Good)
Rem --- Disciplines: Security (CIA), Quality (Lean, Theory of Contraints, Six Sigma), Wiki Way DevOps (Joel, Simplicity)


Rem Slashdot Quote: It takes longer to read working software than to write bad software
Rem - hence - all the comments with linkages to Norvig, PicoLisp, MAL, etc.
Rem - http://www.joelonsoftware.com/articles/fog0000000069.html - It’s harder to read code than to write it.
Rem -http://www.joelonsoftware.com/uibook/chapters/fog0000000057.html - Controlling your Environment - Motivation for FOS
Rem -- from above: A user interface is well-designed when the program behaves exactly how the user thought it would.
Rem -- Learned Helplessness (Depression) (Seligman) - the feeling that you cannot control your environment
    
Rem - http://www.joelonsoftware.com/articles/fog0000000043.html - Joel 12 step test - Version control, bug database, etc.

Rem - http://programmers.stackexchange.com/questions/48698/i-dont-program-in-my-spare-time-does-that-make-me-a-bad-developer

Rem
Rem ################ Lispy: Scheme Interpreter in Python
Rem
Rem ## (c) Peter Norvig, 2010; See http://norvig.com/lispy.html
Rem
Rem ################ Symbol, Env classes
Rem
Rem from __future__ import division
Rem
Rem symbol = str
Rem
Rem Class env(dict):
Rem     "An environment: a dict of {REM varREM :val} pairs, with an outer Env."
Rem     def __init__(self, parms=(), args=(), outer=None):
Rem         self.update (zip(parms, args))
Rem         self.outer = outer
Rem     def Find(self, Var):
Rem         "Find the innermost Env where var appears."
Rem         return self if var in self else self.outer.find(var)
Rem

Const outer As String = "Outer"
Const lispPI As Double = 3.14159265358979
Const lispE As Double = 2.71828182845905
    
Public globalenv As Dictionary
Public primitiveFuncs As Dictionary


Rem Below is the license for SporkLisp from GitHub, which Fork of Spork, is a fork of, therefore follows the same license...
Rem Please note that FOS is attempting to mediate some of the risks detailed below by being
 
Rem (This is written by Tom Spoon, so entertaining reading is just ahead... )
Rem  1) Single file - eases management in a locked down setting / environment (typically corporate / educational)
Rem  2) Minimal use of VBA unique features - secondary target language is RFO Basic,
Rem         which has lists and dictionaries, but no classes or variants


Rem 'A copy of the following license must be included with every distribution of sporklisp:
Rem
Rem 'PREAMBLE:
Rem
Rem 'sporklisp was inspired by LisPy and JScheme, both of which Peter Norvig started.  While the sporklisp source is in VBA,
Rem 'and there have been significant deviations from the scheme that Norvig implemented, I wanted to pay homage to the master.
Rem 'Every copy of this software - distributed in workbook, document, or other Office blub software form, MUST include Peter
Rem 'Norvig's license, and pay homage to the fact that Norvig is awesome.  Long live hawaiian shirts and s-expressions!
Rem
Rem 'ACKNOWLEDGEMENTS ON THE LIMITATIONS OF VBA:
Rem 'VBA is not an abomination, but it's also not your first choice for a prom date.  As an embedded language in every office
Rem 'product, it can be - useful - in certain situations.  However, the Company that spawned VBA, DOES NOT CARE about supporting
Rem 'VBA.  As such, one should NOT expect any VBA-based solution to be stable over the long-run.  Since sporklisp is a lisp living
Rem 'in VBA, sporklisp is ultimately doomed as well.  Anyone using sporklisp understands that sporklisp is not intended to be a
Rem 'stable platform for computation, and that sporklisp - as implemented - functions on top of Closed Source software.  These
Rem 'limitations are outside of the control of the author of sporklisp.
Rem
Rem 'Begin Homage to LisPy and JScheme--------------
Rem
Rem 'Notice: Please do not contact Mr. Norvig about sporklisp.
Rem
Rem 'Software License Agreement
Rem 'Copyright © 1998-2002 by Peter Norvig.
Rem '
Rem 'Permission is granted to anyone to use this software, in source or object code form, on any computer system, and to modify, compile, decompile, run, and redistribute it to anyone else, subject to the following restrictions:
Rem '
Rem '    The author makes no warranty of any kind, either expressed or implied, about the suitability of this software for any purpose.
Rem '
Rem '    The author accepts no liability of any kind for damages or other consequences of the use of this software, even if they arise from defects in the software.
Rem '
Rem '    The origin of this software must not be misrepresented, either by explicit claim or by omission.
Rem '
Rem '    Altered versions must be plainly marked as such, and must not be misrepresented as being the original software. Altered versions may be distributed in packages under other licenses (such as the GNU license).
Rem '
Rem 'If you find this software useful, it would be nice if you let me (peter@norvig.com) know about it, and nicer still if you send me modifications that you are willing to share. However, you are not required to do so.
Rem '
Rem 'License License Agreement
Rem 'A few people have written to say they like this license agreement and want to know if they can use it. So this is to clarify that you are free to use this license agreement, subject to this license agreement.
Rem 'Peter Norvig
Rem
Rem 'End Homage to LisPy and JScheme----------
Rem
Rem
Rem 'Begin License VBA Portions of sporklisp-------
Rem 'All source code for sporklisp and the associated libraries are licensed under the Eclipse Public License, which follows.
Rem 'If you elect to use sporklisp and distribute any of the associated code, the code may NOT be password or otherwise protected.
Rem 'In short, classes, modules, and forms used by sporklisp must be open and available to the end user.  Preventing user access to
Rem 'any of these resource is tantamount to closing the source code, and is unacceptable.
Rem
Rem 'Eclipse Public License - v 1.0
Rem 'THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
Rem '1. DEFINITIONS
Rem
Rem '"Contribution" means:
Rem 'a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and
Rem 'b) in the case of each subsequent Contributor:
Rem 'i) changes to the Program, and
Rem 'ii) additions to the Program;
Rem
Rem 'where such changes and/or additions to the Program originate from and are distributed by that particular Contributor. A Contribution 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf. Contributions do not include additions to the Program which: (i) are separate modules of software distributed in conjunction with the Program under their own license agreement, and (ii) are not derivative works of the Program.
Rem '"Contributor" means any person or entity that distributes the Program.
Rem '"Licensed Patents" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.
Rem '"Program" means the Contributions distributed in accordance with this Agreement.
Rem '"Recipient" means anyone who receives the Program under this Agreement, including all Contributors.
Rem
Rem '2. GRANT OF RIGHTS
Rem 'a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor, if any, and such derivative works, in source code and object code form.
Rem 'b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source code and object code form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.
Rem 'c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise. As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.
Rem 'd) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement.
Rem
Rem '3. REQUIREMENTS
Rem 'A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:
Rem 'a) it complies with the terms and conditions of this Agreement; and
Rem 'b) its license agreement:
Rem  'i) effectively disclaims on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;
Rem  'ii) effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits;
Rem  'iii) states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and
Rem  'iv) states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner on or through a medium customarily used for software exchange.
Rem
Rem 'When the Program is made available in source code form:
Rem
Rem 'a) it must be made available under this Agreement; and
Rem 'b) a copy of this Agreement must be included with each copy of the Program.
Rem
Rem 'Contributors may not remove or alter any copyright notices contained within the Program.
Rem 'Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients to identify the originator of the Contribution.
Rem
Rem '4. COMMERCIAL DISTRIBUTION
Rem
Rem 'Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor ("Commercial Contributor") hereby agrees to defend and indemnify every other Contributor ("Indemnified Contributor") against any losses, damages and costs (collectively "Losses") arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or Losses relating to any
Rem 'Actual
Rem ' or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim at its own expense.
Rem '
Rem 'For example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.
Rem
Rem '5. NO WARRANTY
Rem
Rem 'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and assumes all risks associated with its exercise of rights under this Agreement , including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.
Rem
Rem '6. DISCLAIMER OF LIABILITY
Rem
Rem 'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
Rem
Rem '7. GENERAL
Rem
Rem 'If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.
Rem 'If Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed.
Rem
Rem 'All Recipient 's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.
Rem
Rem 'Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to distribute the Program (including its Contributions) under the new version. Except as expressly stated in Sections 2(a) and 2(b) above, Recipient
Rem receives
Rem 'no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved.
Rem
Rem 'This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose. Each party waives its rights to a jury trial in any resulting litigation.

Rem Below is the READ Me (README.txt) of Tom Spoon - entertaining, but a bit saucy (Should be safe for work, but barely)

Rem 'What in the hell is sporklisp?
Rem
Rem 'It's a lisp interpreter I wrote in VBA, with Excel via the ability to call user defined
Rem 'functions from excel.  A lot of the concepts came from lisp wizards, particulalry the
Rem 'Structure and Interpretation of Computer Programs (SICP), Peter Norvig's excellent tutorials
Rem 'for LisPy and JScheme, and Christian Queinnec's Lisp in Small Pieces.
Rem
Rem 'Why is it called sporklisp?
Rem
Rem 'Originally, I intended to build a small lisp for a VBA-based set of libraries called
Rem 'SPORK (Spoon's Operations Research Kit).  These libs were designed to support a sizeable
Rem 'discrete event simulation, and ended up including a ton of generic libraries and features
Rem 'grafted onto VBA to facilitate a more functional style of programming.  sporklisp was
Rem 'a piece of SPORK, but its existence merited a stand-alone library.
Rem
Rem 'In the name of all that is pure and good in this world, why VBA?
Rem
Rem 'In short: environment, education, and experimentation.
Rem
Rem 'I come from an Operations Research background.
Rem 'In my little corner of the world, they preach that VBA is the
Rem 'coin of the realm.  OR types use spreadsheets a lot, VBA is readily available.
Rem 'It's almost like saying PHP is the common language of the web....They're both weak
Rem 'scripting languages that have a surprising amount of market penetration
Rem 'due to just "being everywhere".  Prior to discovering the One True Way, I spent
Rem 'a LOT of time in VBA, using it as an environment to explore computer science and
Rem 'software engineering, while facilitating my OR job.  Eventually, I outgrew the bounds
Rem 'of VBA, although I was mightily impressed to see "just" how far you can push VBA if you're
Rem 'so inclined.  sporklisp is an example of pushing VBA to do things it really wasn't intended to.
Rem 'It's also a way to provide an embedded programming environment for a lisp dialect that can be
Rem 'used in office products.  Finally, having lisp in the spreadsheet can provide some advantages
Rem 'although I do most of my "real" work in a lisp repl (these days it's Clojure).  Finally finally,
Rem 'most lispers go through a learning phase where, as in the Structure and Interpretation of Computer
Rem 'Programs (by Abelson and Sussman), they show you how to implement your own lisp.  Lisp in Small Pieces
Rem 'by Queinnec also explores a lot of ways to implement your favorite lisp dialect.  By the time I started
Rem 'getting decent in Clojure, Common Lisp, and Scheme, I felt of sufficient maturity to implement a lisp.
Rem 'This is my first foray into doing so.  It's been great fun and incredibly educational.  I highly recommend
Rem 'you try it sometime :)
Rem
Rem 'How did you do it?
Rem
Rem 'I've spent unholy amounts of time in VBA over the last 5 years,
Rem 'and toward the end of my last project (prior to porting a 42K LOC simulation library +
Rem 'generic data structures + graph library + tons-of-stuff-vba-is-missing + my discrete
Rem 'event simulation) I decided to roll my own lisp in VBA.  At the time, I was already
Rem 'moving to clojure anyway, and had re-organized the initial OOP-designed simulation
Rem 'structure (yes, VBA can do decent OOP quite well without some of the masochism in
Rem 'other languages - also without many of the benefits) into something with a much
Rem 'more functional style (to facilitate porting to a functional programming language).
Rem 'My idea was to use a little Lisp dialect for scripting entity behaviors and other
Rem 'lightweight stuff (I wanted first class functions too dammit).  I used Peter Norvig's
Rem 'LisPy example in Python to get me started (which is a lightweight implementation, but
Rem 'it uses a lot of Python's features to easily import primitives...and python has first
Rem 'class functions already).  I had to cross-reference the implementation from Norvig's
Rem 'JScheme (which LisPy was a subset of), and adapt the solution to the unique challenges
Rem 'in VBA.  Finally, Chapter 4 of SICP (Structure and Interpretation of Computer Programs)
Rem 'was invaluable, as was Lisp in Small Pieces.
Rem
Rem 'What kind of a lisp is sporklisp?  Which cows are sacred?
Rem
Rem 'I was working from scheme-based source material, and I have been developing - A LOT -
Rem 'in Clojure over the past year.  So, sporklisp is a lisp-1 (functions and vars share the
Rem 'same namespace). I spliced together some things I really liked from Clojure:
Rem 'the generic sequence library from Clojure, as well as lazy sequences.  So...sporklisp is
Rem 'currently a bit of a scheme/clojure hybrid.  It has lexical scope.  It has clojure-style
Rem 'literals for vectors, maps, and sets (currently VBA arrays and dictionaries, respectively).
Rem 'It also has reader support for JSON literals, which may be useful.  It does NOT have
Rem 'persistent data structures that make clojure cool, so you're stuck with the humble list.
Rem 'It DOES have lazy/infinite sequences, so you can play some cool tricks.  The sequence library
Rem 'alone is probably worth using overe stock VBA.  Keywords exist, as per Clojure.  I don't have them
Rem 'mirroring clojure semantics exactly, so you can't "apply" them to a map to get the associated value...
Rem 'yet.  I am close to having macros implemented, at which point I might re-write a ton of sporklisp in
Rem 'sporklisp.
Rem
Rem 'What about performance, and stability?
Rem
Rem 'sporklisp is actually fast enough for lots of scripting...although I haven't really tested the upper
Rem 'bounds of it's reasonable performance (i.e. doing numeric work).  I would not recommend building a monster
Rem 'spreadsheet and having tons of lispfuncs in the formulas...that might be untenable (I don't know yet).
Rem 'sporklisp currently has some ineffeciencies - the largest of which is VBA.  VBA is an interpreted language,
Rem 'and it has a really wonky garbage collector.  Large programs, or large spreadsheets, may cause sporklisp to
Rem 'leak memory, or they may just be slow.  On the plus side, sporklisp's evaluation model uses VBA dictionaries to
Rem 'store environments, so cost of looking up definitions is pretty cheap.  On the down side, the base type for
Rem 'lists is actually the vba collection, which is a bit heavy weight.  Most lisps use a simple cons-cell, or a pair,
Rem 'or represent lists as chunks of arrays, which provide much better cache coherence and speed.  Even in VBA, it'd be
Rem 'better for sporklisp to use variant arrays for everything, where it's currently using collections.  Still, sporklisp
Rem 'is fast enough for you, old man!
Rem
Rem 'Can I use sporklisp from Excel?
Rem
Rem 'The cool thing (and something I'm still working on in my spare time) is just using lisp
Rem 'for your formula logic in excel.  I need to do some more stuff to make the interop sweeter
Rem '- like wrapping array formulas into operations like map or other functions that return
Rem 'multiple values.  Still, you can eval lisp expressions as formulas and chain them along
Rem 'in a reactive manner just like normal excel stuff.  You can even bind vars from excel
Rem 'and make them available in the lisp environment.  Plenty of stuff doesn't work, but
Rem 'there's a pretty sizeable core language implemented already.  Macros are not implemented,
Rem 'although they're a skip and a jump away.  Lots of stuff is implemented in pure VBA,
Rem 'for "speed" purposes (that seems silly since VBA is interpreted anyway).
Rem '
Rem 'If I "really" wanted a reactive spreadsheet, I'd just wrap one in Swing with clojure
Rem 'driving the dataflow evaluation.  Much easier (and it's been done already), and you
Rem 'basically just get another way to talk to the repl.  This is more of a toy project, but
Rem 'it's sliding up the cool scale because, as it's VBA, it's embeddable in any Office product
Rem '(as long as MS continues to support VBA).  Just like clojure let's me live in Java without
Rem 'writing Java, one could theoretically live in VBA without writing VBA under sporklisp.
Rem
Rem
Rem '-Tom Spoon

Rem Regression Test set - copy and paste back into Excel, and apply the cell formulas

Rem     MAL Step    MAL Tests
Rem     -1  ;;Tests Cell Formulas - to leveral MAL test suite, modified for PicoLisp via emuLisp
Rem         ;; Note: Cell formulas can be "dragged down"  "Superman Fan" style and then "blanked out" for a cascading visual effect
Rem
Rem         Input Test Text ->abcABC123
Rem             =FOS(B3)
Rem         Expected Value ->;=>abcABC123
Rem                 =MID(B5,4,LEN(B12))
Rem                     =IF(C4=D6, 0, 1)
Rem
Rem     0   ;; Testing basic string
Rem         abcABC123
Rem             abcABC123
Rem         ;=>abcABC123
Rem                 abcABC123
Rem                     0
Rem         ;; Testing string containing spaces
Rem         hello mal world
Rem             hello mal world
Rem         ;=>hello mal world
Rem                 hello mal world
Rem                     0
Rem         ;; Testing string containing symbols
Rem         []{}"'* ;:()
Rem             []{}"'* ;:()
Rem         ;=>[]{}"'* ;:()
Rem                 []{}"'* ;:()
Rem                     0
Rem
Rem         ;; Test long string
Rem         hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
Rem             hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
Rem         ;=>hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
Rem                 hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
Rem                     0
Rem
Rem     1
Rem
Rem
Rem
Rem     Samples (fn (x) (inc x))    (fn (x) (if (< x 3) false true))    (fn (xs) (first (map inc xs)))  (fn (xs) (reduce + 0 (map inc xs))) (fn (xs) (nth 2 (filter odd? xs)))
Rem     1.00    2.00    FALSE   2.00    5581.00 5565.00
Rem     3.00    4.00    TRUE
Rem     5565.00 5566.00 TRUE
Rem     4.00    5.00    TRUE




Rem     0001        <!DOCTYPE html>
Rem     0002        <html>
Rem     0003        <head>
Rem     0004        "   <meta charset=""utf-8"" />"
Rem     0005        "   <title>EmuLisp Console</title>"
Rem     0006        "   <meta name=""generator"" content=""BBEdit 9.6"" />"
Rem     0007        "   <style type=""text/css"" title=""text/css"">"
Rem     0008        body {
Rem     0009        "   margin: 12px 16px 0 16px;"
Rem     0010        "   background-color: #f0ecd0;"
Rem     0011        }
Rem     0012        div#head {
Rem     0013        "   white-space: nowrap;"
Rem     0014        }
Rem     0015        span#presentation {
Rem     0016        "   border: 1px solid gray;"
Rem     0017        "   border-radius: 4px;"
Rem     0018        "   padding: 4px 12px 4px 12px;"
Rem     0019        "   font: 15px Optima;"
Rem     0020        "   background-color: white;"
Rem     0021        }
Rem     0022        span#presentation em {
Rem     0023        "   font-size: 18px;"
Rem     0024        }
Rem     0025        img#infosymbol {
Rem     0026        "   position: relative;"
Rem     0027        "   top: 5px;"
Rem     0028        "   margin: 0 0 0 8px;"
Rem     0029        "   cursor: pointer;"
Rem     0030        }
Rem     0031        div#main {
Rem     0032        "   position: relative;"
Rem     0033        "   top: 7px;"
Rem     0034        }
Rem     0035        div#dcons {
Rem     0036        "   width: 520px;"
Rem     0037        }
Rem     0038        div#log {
Rem     0039        "   margin: 0;"
Rem     0040        "   width: 101.3%;"
Rem     0041        "   border: 1px solid gray;"
Rem     0042        "   border-bottom: none;"
Rem     0043        "   overflow: auto;"
Rem     0044        "   background-color: white;"
Rem     0045        }
Rem     0046        div#log pre {
Rem     0047        "   margin: 0 1px 0 1px;"
Rem     0048        "   padding: 2px 2px 2px 4px;"
Rem     0049        }
Rem     0050        pre.oldcode {
Rem     0051        "   background-color: #f0f5f7;"
Rem     0052        "   cursor: pointer;"
Rem     0053        }
Rem     0054        pre.filedrop {
Rem     0055        "   border-left: 4px solid #c0c5c7;"
Rem     0056        "   background-color: #f0f5f7;"
Rem     0057        }
Rem     0058        pre.print {
Rem     0059        "   background-color: #def;"
Rem     0060        }
Rem     0061        pre.println {
Rem     0062        "   background-color: #def;"
Rem     0063        "   border-bottom: 1px solid #bcf;"
Rem     0064        }
Rem     0065        pre.result {
Rem     0066        "   background-color: #dfd;"
Rem     0067        "   border-bottom: 1px solid #9b9;"
Rem     0068        }
Rem     0069        pre.warning {
Rem     0070        "   border-left: 4px solid #db3;"
Rem     0071        "   background-color: #ffa;"
Rem     0072        }
Rem     0073        pre.error {
Rem     0074        "   border-left: 4px solid #f33;"
Rem     0075        "   background-color: #fdd;"
Rem     0076        }
Rem     0077        textarea#newcode {
Rem     0078        "   margin: 0 0 4px 0;"
Rem     0079        "   width: inherit;"
Rem     0080        "   border: 1px solid gray;"
Rem     0081        "   padding: 2px 0 0 6px;"
Rem     0082        "   font: inherit;"
Rem     0083        }
Rem     0084        span#version {
Rem     0085        "   margin-left: 8px;"
Rem     0086        "   font: italic 11px Arial, sans-serif;"
Rem     0087        }
Rem     0088        div#dcons span#controls {
Rem     0089        "   float: right;"
Rem     0090        }
Rem     0091        div#dcons span#controls span {
Rem     0092        "   margin: 0;"
Rem     0093        "   border: 1px solid gray;"
Rem     0094        "   padding: 2px 4px 2px 4px;"
Rem     0095        "   font: 14px monospace;"
Rem     0096        "   background-color: white;"
Rem     0097        }
Rem     0098        div#dcons span#controls .nosymbol {
Rem     0099        "   color: black;"
Rem     0100        "   cursor: text;"
Rem     0101        }
Rem     0102        div#dcons span#controls .builtin {
Rem     0103        "   color: #00e;"
Rem     0104        "   cursor: pointer;"
Rem     0105        }
Rem     0106        div#dcons span#controls .othersymbol {
Rem     0107        "   color: #00e;"
Rem     0108        "   cursor: pointer;"
Rem     0109        "   background-color: #def;"
Rem     0110        }
Rem     0111        div#dcons input[type='button'] {
Rem     0112        }
Rem     0113        div#monitor {
Rem     0114        "   position: absolute;"
Rem     0115        "   top: 0;"
Rem     0116        "   left: 534px;"
Rem     0117        "   font: 15px Optima;"
Rem     0118        }
Rem     0119        div#monitor input[type='text'] {
Rem     0120        "   margin: 0 0 4px 0;"
Rem     0121        "   width: 300px;"
Rem     0122        "   font: 15px monospace;"
Rem     0123        }
Rem     0124        canvas#monView {
Rem     0125        "   border: 1px solid gray;"
Rem     0126        "   background-color: white;"
Rem     0127        }
Rem     0128        div#prefs {
Rem     0129        "   visibility: hidden;"
Rem     0130        "   position: absolute;"
Rem     0131        "   top: 46px;"
Rem     0132        "   left: 160px;"
Rem     0133        "   border: 2px ridge #999;"
Rem     0134        "   background-color: white;"
Rem     0135        "   -moz-box-shadow: 4px 4px 8px rgba(0,0,0,0.3);"
Rem     0136        "   -webkit-box-shadow: 4px 4px 8px rgba(0,0,0,0.3);"
Rem     0137        "   box-shadow: 4px 4px 8px rgba(0,0,0,0.3);"
Rem     0138        "   padding: 0 0 2px 0;"
Rem     0139        "   font: 14px Optima;"
Rem     0140        }
Rem     0141        p.paneHead {
Rem     0142        "   margin: 0 0 8px 0;"
Rem     0143        "   border-bottom: 1px solid #bbb;"
Rem     0144        "   background-color: #ddd;"
Rem     0145        "   padding: 0 0 1px 0;"
Rem     0146        }
Rem     0147        span.closebox {
Rem     0148        "   position: relative;"
Rem     0149        "   margin: 0;"
Rem     0150        "   left: 92%;"
Rem     0151        "   border: 1px solid #999;"
Rem     0152        "   background-color: #f9f9f9;"
Rem     0153        "   padding: 0 3px 0 3px;"
Rem     0154        "   text-align: center;"
Rem     0155        "   font: 10px Arial, sans-serif;"
Rem     0156        "   cursor: default;"
Rem     0157        }
Rem     0158        span.closebox:hover {
Rem     0159        "   color: #d22;"
Rem     0160        }
Rem     0161        p.pref {
Rem     0162        "   margin: 0 16px 8px 14px;"
Rem     0163        }
Rem     0164        div#prefs input[type='checkbox'] {
Rem     0165        "   margin: 0 6px 0 0;"
Rem     0166        }
Rem     0167        div#prefs input[type='text'] {
Rem     0168        "   background-color: #ffd;"
Rem     0169        "   padding-left: 2px;"
Rem     0170        }
Rem     0171
Rem     0172        "/* below are the following script sections (in one script tag)"
Rem     0173        "   <script src=""http://folk.uio.no/jkleiser/pico/emuLisp/src/core.js"" type=""text/javascript""></script>"
Rem     0174        <script src="http://folk.uio.no/jkleiser/pico/emuLisp/src/js.js" type="text/javascript"></script>
Rem     0175        */
Rem     0176
Rem     0177
Rem     0178        "   </style>"
Rem     0179
Rem     0180        "   <script src=""http://folk.uio.no/jkleiser/pico/emuLisp/src/js.js"" type=""text/javascript""></script>"
Rem     0181
Rem     0182        <script type="text/javascript">
Rem     0183        /* 26nov10jk
Rem     0184        * (c) Jon Kleiser
Rem     0185        * http://folk.uio.no/jkleiser/pico/emuLisp/src/core.js
Rem     0186        */
Rem     0187        var BOXNAT_EXP = "Boxed native object expected",
Rem     0188        "   BOOL_EXP = ""Boolean expected"", CELL_EXP = ""Cell expected"", LIST_EXP = ""List expected"","
Rem     0189        "   NUM_EXP = ""Number expected"", SYM_EXP = ""Symbol expected"", VAR_EXP = ""Variable expected"","
Rem     0190        "   EXEC_OR_NUM_EXP = ""Executable or Number expected"","
Rem     0191        "   BAD_ARG = ""Bad argument"", BAD_DOT = ""Bad dotted pair"", BAD_INPUT = ""Bad input"", DIV_0 = ""Div/0"","
Rem     0192        "   NOT_MAK = ""Not making"", PROT_SYM = ""Protected symbol"", UNDEF = ""Undefined"","
Rem     0193        "   JS_CTORNAME_EXP = ""Constructor name expected"", JS_RESERVED = ""Reserved word"";"
Rem     0194
Rem     0195        function getFileSync(fileUrl) {
Rem     0196        "   var req = new XMLHttpRequest();"
Rem     0197        "   req.open(""GET"", fileUrl, false);      // synchronous"
Rem     0198        "   req.overrideMimeType(""text/plain; charset=utf-8"");"
Rem     0199        "   req.send(null);"
Rem     0200        "   if (req.status == 0) {"
Rem     0201        "       return req.responseText;"
Rem     0202        "   }"
Rem     0203        "   throw new Error(""XMLHttpRequest status: "" + req.status);"
Rem     0204        }
Rem     0205
Rem     0206        var NILTYPE = 0, NUMBERTYPE = 1, SYMBOLTYPE = 2, CELLTYPE = 3, TRUETYPE = 4;
Rem     0207
Rem     0208        Number.prototype.TYPEVAL = NUMBERTYPE;
Rem     0209
Rem     0210        function lispToStr(x) {
Rem     0211        "   //if (!confirm(""lispToStr: "" + x.toString() + "", "" + x.TYPEVAL)) throw new Error(""lispToStr aborted"");"
Rem     0212        "   return x.toString();"
Rem     0213        }
Rem     0214
Rem     0215        function unknown(x) {
Rem     0216        "   if (!confirm(""Unknown Lisp type: "" + x)) throw new Error(""unknown aborted"");"
Rem     0217        "   return ""???"";"
Rem     0218        }
Rem     0219
Rem     0220        function valueToStr(x) {
Rem     0221        "   //if (!confirm(""valueToStr "" + lispToStr(x))) throw new Error(""valueToStr aborted"");"
Rem     0222        "   return (x instanceof Number) ? x.toString() :"
Rem     0223        "       (x instanceof Symbol) ? x.toValueString() :"
Rem     0224        "       (x instanceof Cell) ? x.toValueString() : unknown(x);"
Rem     0225        }
Rem     0226
Rem     0227        function Cell(car, cdr) {
Rem     0228        "   this.car = car;"
Rem     0229        "   this.cdr = cdr;"
Rem     0230        }
Rem     0231
Rem     0232        Cell.prototype.TYPEVAL = CELLTYPE;
Rem     0233
Rem     0234        Cell.prototype.getVal = function() {
Rem     0235        "   return this.car;"
Rem     0236        }
Rem     0237
Rem     0238        Cell.prototype.setVal = function(val) {
Rem     0239        "   this.car = val;"
Rem     0240        }
Rem     0241
Rem     0242        Cell.prototype.toString = function() {
Rem     0243        "   if (this.car === QUOTE) return ""'"" + lispToStr(this.cdr);"
Rem     0244        "   var arr = [], c = this;"
Rem     0245        "   do {"
Rem     0246        "       arr.push(lispToStr(c.car));"
Rem     0247        "       c = c.cdr;"
Rem     0248        "       //if (!confirm(""Cell.toString: "" + lispToStr(c.car))) throw new Error(""Cell.toString aborted"");"
Rem     0249        "       if (c === this) { arr.push("".""); c = NIL; }   // why didn't break work here?"
Rem     0250        "   } while (c instanceof Cell);"
Rem     0251        "   if (c !== NIL) {"
Rem     0252        "       arr.push(""."", lispToStr(c));  // last Cell was dotted"
Rem     0253        "   }"
Rem     0254        "   return ""("" + arr.join("" "") + "")"";"
Rem     0255        }
Rem     0256
Rem     0257        Cell.prototype.toValueString = function() {
Rem     0258        "   var str = """", c = this;"
Rem     0259        "   do {"
Rem     0260        "       str += valueToStr(c.car);"
Rem     0261        "       c = c.cdr;"
Rem     0262        "   } while (c instanceof Cell);"
Rem     0263        "   if (c !== NIL) {"
Rem     0264        "       str += valueToStr(c);   // last Cell was dotted"
Rem     0265        "   }"
Rem     0266        "   return str;"
Rem     0267        }
Rem     0268
Rem     0269        function Symbol(name, val) {
Rem     0270        "   this.name = name;"
Rem     0271        "   this.trans = false;"
Rem     0272        "   this.cdr = (val === undefined) ? NIL : val;"
Rem     0273        "   this.props = NIL;"
Rem     0274        }
Rem     0275
Rem     0276        function newTransSymbol(name) {
Rem     0277        "   var ts = new Symbol(name);"
Rem     0278        "   ts.trans = true;"
Rem     0279        "   ts.cdr = ts;"
Rem     0280        "   return ts;"
Rem     0281        }
Rem     0282
Rem     0283        // Creates and returns a new anonymous symbol
Rem     0284        function box(val) {
Rem     0285        "   var ts = new Symbol(null, val);"
Rem     0286        "   ts.trans = true;"
Rem     0287        "   return ts;"
Rem     0288        }
Rem     0289
Rem     0290        function boxNativeObject(obj) {
Rem     0291        "   var ts = newTransSymbol(null);"
Rem     0292        "   ts.obj = obj;"
Rem     0293        "   return ts;"
Rem     0294        }
Rem     0295
Rem     0296        Symbol.prototype.TYPEVAL = SYMBOLTYPE;
Rem     0297
Rem     0298        Symbol.prototype.getVal = function() {
Rem     0299        "   return this.cdr;"
Rem     0300        }
Rem     0301
Rem     0302        Symbol.prototype.valueOf = function() {
Rem     0303        "   return this.name;"
Rem     0304        }
Rem     0305
Rem     0306        Symbol.prototype.setVal = function(val) {
Rem     0307        "   if (this.lock) throw new Error(newErrMsg(PROT_SYM, this));"
Rem     0308        "   this.cdr = val;"
Rem     0309        }
Rem     0310
Rem     0311        // Internal symbol names can consist of any printable (non-whitespace) character,
Rem     0312        "// except for the following meta characters:       "" ' ( ) , [ ] ` ~ { }"
Rem     0313        // It is possible, though, to include these special characters into symbol names
Rem     0314        // by escaping them with a backslash '\'.
Rem     0315        Symbol.prototype.escName = function() {
Rem     0316        "   var eName = this.name.replace(/\\/g, ""\\\\"");"
Rem     0317        "   eName = eName.replace(/\^/g, ""Error! Hyperlink reference not valid."");"
Rem     0318        "   eName = eName.replace(/\t/g, ""^I"");"
Rem     0319        "   eName = eName.replace(/\r/g, ""^M"");"
Rem     0320        "   eName = eName.replace(/\n/g, ""^J"");"
Rem     0321        "   //if (eName != this.name) alert(""Symbol.escName: "" + this.name + "" -> "" + eName);"
Rem     0322        "   return eName;"
Rem     0323        }
Rem     0324
Rem     0325        Symbol.prototype.noName = function() {
Rem     0326        "   return (this.obj !== undefined) ? ""$"" + typeof this.obj : ""$*"";"
Rem     0327        }
Rem     0328
Rem     0329        Symbol.prototype.toString = function() {
Rem     0330        "   return this.trans ? (this.name != null) ? ('""' + this.escName() + '""') : this.noName() : this.name;"
Rem     0331        }
Rem     0332
Rem     0333        Symbol.prototype.toValueString = function() {
Rem     0334        "   return (this === NIL) ? """" : (this.name != null) ? this.name : this.noName();"
Rem     0335        }
Rem     0336
Rem     0337        Symbol.prototype.pushValue = function(val) {
Rem     0338        "   if (this.stack === undefined) this.stack = [];"
Rem     0339        "   this.stack.push(this.cdr);"
Rem     0340        "   this.cdr = val;"
Rem     0341        }
Rem     0342
Rem     0343        Symbol.prototype.popValue = function() {
Rem     0344        "   var pv = this.cdr;"
Rem     0345        "   this.cdr = this.stack.pop();"
Rem     0346        "   //if (this.stack.length === 0) delete this.stack;"
Rem     0347        "   return pv;"
Rem     0348        }
Rem     0349
Rem     0350        function getSymbol(name, editMode) {
Rem     0351        "   if (name in gEmptyObj) throw new Error(newErrMsg(JS_RESERVED, name));"
Rem     0352        "   var s = gSym[name];"
Rem     0353        "   if (s === undefined) {"
Rem     0354        "       s = new Symbol(name, NIL);"
Rem     0355        "       if (! editMode) gSym[name] = s;"
Rem     0356        "   }"
Rem     0357        "   return s;"
Rem     0358        }
Rem     0359
Rem     0360        function setSymbolValue(s, val) {
Rem     0361        "   if (!(s instanceof Symbol)) throw new Error(newErrMsg(VAR_EXP, s));"
Rem     0362        "   s.setVal(val);"
Rem     0363        }
Rem     0364
Rem     0365        function Source(text, chars) {
Rem     0366        "   this.src = text;"
Rem     0367        "   // character limitation for symbols"
Rem     0368        "   if (chars instanceof Symbol) {"
Rem     0369        "       this.charset = chars.valueOf();"
Rem     0370        "   } else if (typeof chars == ""string"") {"
Rem     0371        "       //alert(""Source2: "" + chars);"
Rem     0372        "       this.charset = chars;"
Rem     0373        "   }"
Rem     0374        "   this.pos = 0;"
Rem     0375        "   this.trace = null;"
Rem     0376        }
Rem     0377
Rem     0378        Source.prototype.CLOSEPAREN = -1;
Rem     0379        Source.prototype.CLOSESYM = -2;
Rem     0380        Source.prototype.QUOTE2 = -3;
Rem     0381        Source.prototype.EOF = null;
Rem     0382
Rem     0383        Source.prototype.unescMap = {I: "\t", i: "\t", J: "\n", j: "\n", M: "\r", m: "\r"};
Rem     0384
Rem     0385        Source.prototype.getNextSignificantChar = function() {
Rem     0386        "   while (this.pos < this.src.length) {"
Rem     0387        "       while (this.src.charAt(this.pos) == ""#"") {"
Rem     0388        "           var ch;"
Rem     0389        "           do { ch = this.src.charAt(this.pos++); } while ((ch != ""\n"") && (this.pos < this.src.length));"
Rem     0390        "       }"
Rem     0391        "       if (this.src.charAt(this.pos) == ""\\"") this.pos++;"
Rem     0392        "       if ("" \t\r\n"".indexOf(this.src.charAt(this.pos)) == -1) return this.src.charAt(this.pos++);"
Rem     0393        "       this.pos++;"
Rem     0394        "   }"
Rem     0395        "   return this.EOF;"
Rem     0396        }
Rem     0397
Rem     0398        Source.prototype.getNextStringChar = function() {
Rem     0399        "   while (this.pos < this.src.length) {"
Rem     0400        "       var ch = this.src.charAt(this.pos++);"
Rem     0401        "       if (ch == ""\"""") return this.QUOTE2;"
Rem     0402        "       if (ch == ""\\"") return this.src.charAt(this.pos++);"
Rem     0403        "       if (ch != ""^"") return ch;"
Rem     0404        "       ch = this.unescMap[this.src.charAt(this.pos++)];"
Rem     0405        "       if (ch != null) return ch;"
Rem     0406        "   }"
Rem     0407        "   return this.EOF;"
Rem     0408        }
Rem     0409
Rem     0410        Source.prototype.getNextSymbolChar = function() {
Rem     0411        "   if ("" \t\r\n('\"""".indexOf(this.src.charAt(this.pos)) >= 0) return this.CLOSESYM;"
Rem     0412        "   var ch = this.src.charAt(this.pos++);"
Rem     0413        "   if (ch == "")"") return this.CLOSEPAREN;"
Rem     0414        "   if (ch == ""\\"") return this.src.charAt(this.pos++);"
Rem     0415        "   return ch;"
Rem     0416        }
Rem     0417
Rem     0418        Source.prototype.withTrace = function() {
Rem     0419        "   this.trace = [];"
Rem     0420        "   return this;"
Rem     0421        }
Rem     0422
Rem     0423        Source.prototype.traceItemEnd = function(item) {
Rem     0424        "   if (this.trace) this.trace.push({item: item, endPos: this.pos});"
Rem     0425        }
Rem     0426
Rem     0427        Source.prototype.getItemBeforePos = function(endPos) {
Rem     0428        "   for (var i=this.trace.length-1; i>=0; i--) {"
Rem     0429        "       var t = this.trace[i];"
Rem     0430        "       if ((t.endPos - t.item.toString().length) <= endPos) return {item: t.item, tInd: i};"
Rem     0431        "   }"
Rem     0432        "   return null;"
Rem     0433        }
Rem     0434
Rem     0435        Source.prototype.getSymbolBeforePos = function(endPos) {
Rem     0436        "   for (var i=this.trace.length-1; i>=0; i--) {"
Rem     0437        "       var t = this.trace[i];"
Rem     0438        "       if (((t.endPos - t.item.toString().length) <= endPos) &&"
Rem     0439        "           (t.item instanceof Symbol) && gSym[t.item.name]) return {item: t.item, tInd: i};"
Rem     0440        "   }"
Rem     0441        "   return null;"
Rem     0442        }
Rem     0443
Rem     0444        "var NIL = new Symbol(""NIL""); NIL.car = NIL;  NIL.cdr = NIL;  NIL.props = NIL;"
Rem     0445        "       NIL.lock = true; NIL.TYPEVAL = NILTYPE; NIL.bool = false;"
Rem     0446        "var T = new Symbol(""T""); T.cdr = T;  T.lock = true; T.TYPEVAL = TRUETYPE; T.bool = true;"
Rem     0447        var A1 = new Symbol("@", NIL), A2 = new Symbol("@@", NIL), A3 = new Symbol("@@@", NIL);
Rem     0448        var ZERO = new Number(0), ONE = new Number(1);
Rem     0449        "var gSym = {NIL: NIL, T: T, ""@"": A1, ""@@"": A2, ""@@@"": A3};   // dictionary/index for internal symbols"
Rem     0450        "var gTrans = {};   // dictionary/index for transient symbols (strings)"
Rem     0451        var gEmptyObj = {};
Rem     0452        var gParseCache = {};
Rem     0453        "var mk = [];   // 'make' stack"
Rem     0454        var evFrames = NIL;
Rem     0455        var gTrcIndent = "";
Rem     0456        var startupMillis = (new Date()).getTime();
Rem     0457
Rem     0458        function mkNew() { mk.unshift({h: NIL, t: NIL}); }
Rem     0459        function linkc(c) {
Rem     0460        "   if (mk.length === 0) throw new Error(newErrMsg(NOT_MAK));"
Rem     0461        "   c = (c !== NIL) ? evalArgs(c) : new Cell(NIL, NIL);"
Rem     0462        "   if (mk[0].h === NIL) { mk[0].h = c; } else { mk[0].t.cdr = c; }"
Rem     0463        "   while (c.cdr !== NIL) { c = c.cdr; }; mk[0].t = c; return c.car;"
Rem     0464        }
Rem     0465        function link(x) {
Rem     0466        "   if (mk.length === 0) throw new Error(newErrMsg(NOT_MAK));"
Rem     0467        "   var c = new Cell(x, NIL);"
Rem     0468        "   if (mk[0].h === NIL) { mk[0].h = c; } else { mk[0].t.cdr = c; }"
Rem     0469        "   mk[0].t = c; return x;"
Rem     0470        }
Rem     0471        function mkResult() { return mk.shift().h; }
Rem     0472
Rem     0473        function getString(str, editMode) {
Rem     0474        "   var s = (str in gEmptyObj) ? undefined : gTrans[str];"
Rem     0475        "   if (s === undefined) {"
Rem     0476        "       s = newTransSymbol(str);"
Rem     0477        "       if (! (editMode || (str in gEmptyObj))) gTrans[str] = s;"
Rem     0478        "   }"
Rem     0479        "   return s;"
Rem     0480        }
Rem     0481
Rem     0482        function newErrMsg(msg, badValue) {
Rem     0483        "   getSymbol(""*Msg"").setVal(newTransSymbol(msg));"
Rem     0484        "   return (badValue === undefined) ? msg : lispToStr(badValue) + "" -- "" + msg;"
Rem     0485        }
Rem     0486
Rem     0487        function deFn(name, jsFn) {
Rem     0488        "   if (name in gEmptyObj) throw new Error(newErrMsg(JS_RESERVED, name));"
Rem     0489        "   var sym = new Symbol(name, jsFn);"
Rem     0490        "   gSym[name] = sym;"
Rem     0491        }
Rem     0492
Rem     0493        function aTrue(val) { if (val !== NIL) { A1.pushValue(val); return true; } else return false; }
Rem     0494
Rem     0495        function aPop(val) { A1.popValue(); return val; }
Rem     0496
Rem     0497        function car(c) { if (c.car) return c.car; else throw new Error(newErrMsg(LIST_EXP)); }
Rem     0498        function cdr(c) { if ((c instanceof Cell) || (c === NIL)) return c.cdr;
Rem     0499        "                       else throw new Error(newErrMsg(LIST_EXP)); }"
Rem     0500
Rem     0501        function numeric(val) {
Rem     0502        "   if (val instanceof Number) return val;"
Rem     0503        "   throw new Error(newErrMsg(NUM_EXP, val));"
Rem     0504        }
Rem     0505
Rem     0506        function nth(lst, n) {
Rem     0507        "   if (lst instanceof Cell) {"
Rem     0508        "       if (n <= 0) return NIL;"
Rem     0509        "       while ((lst !== NIL) && (--n > 0)) { lst = lst.cdr; }"
Rem     0510        "   }"
Rem     0511        "   return lst;"
Rem     0512        }
Rem     0513
Rem     0514        function getAlg(c) {
Rem     0515        "   //alert(""getAlg: "" + lispToStr(c));"
Rem     0516        "   var s = c.car; c = c.cdr;"
Rem     0517        "   while (c instanceof Cell) {"
Rem     0518        "       var k = c.car;"
Rem     0519        "       if (s instanceof Symbol) {"
Rem     0520        "           if (eqVal(k, ZERO)) {"
Rem     0521        "               s = s.getVal();"
Rem     0522        "           } else {"
Rem     0523        "               var pLst = s.props, p = NIL, pk, pv;"
Rem     0524        "               while (pLst !== NIL) {"
Rem     0525        "                   var pc = pLst.car;"
Rem     0526        "                   if (pc instanceof Cell) { pk = pc.cdr; pv = pc.car; } else { pk = pc; pv = T; }"
Rem     0527        //if (!confirm("getAlg: " + lispToStr(pc) + ", " + lispToStr(pk) + ", " + lispToStr(pv))) throw new Error("getAlg aborted");
Rem     0528        "                   if (pk === k) { p = pv; break; }"
Rem     0529        "                   pLst = pLst.cdr;"
Rem     0530        "               }"
Rem     0531        "               s = p;  // the symbol or list to use in the next step"
Rem     0532        "           }"
Rem     0533        "       } else if (s instanceof Cell) {"
Rem     0534        "           if (k instanceof Number) {"
Rem     0535        "               if (k >= 0) {"
Rem     0536        "                   s = nth(s, k).car;"
Rem     0537        "               } else {"
Rem     0538        "                   do { s = s.cdr; } while ((s !== NIL) && (++k < 0));"
Rem     0539        "               }"
Rem     0540        "           }"
Rem     0541        "       } else throw new Error(newErrMsg(SYM_EXP));"
Rem     0542        "       c = c.cdr;"
Rem     0543        "   }"
Rem     0544        "   return s;"
Rem     0545        }
Rem     0546
Rem     0547        function prog(c) {
Rem     0548        "   var v = NIL; while (c instanceof Cell) { v = evalLisp(c.car); c = c.cdr; }; return v;"
Rem     0549        }
Rem     0550
Rem     0551        function iter(c) {
Rem     0552        "   var v = NIL;"
Rem     0553        "   while (c instanceof Cell) {"
Rem     0554        "       var cv = c.car, cond = false, cMatch = false;"
Rem     0555        "       if (cv instanceof Cell) {"
Rem     0556        "           if (cond = (cv.car === NIL)) {"
Rem     0557        "               cMatch = (evalLisp(cv.cdr.car) === NIL);"
Rem     0558        "           } else if (cond = (cv.car === T)) {"
Rem     0559        "               cMatch = aTrue(evalLisp(cv.cdr.car));"
Rem     0560        "           }"
Rem     0561        "       }"
Rem     0562        "       if (cond) {"
Rem     0563        "           if (cMatch) {"
Rem     0564        "               v = prog(cv.cdr.cdr);"
Rem     0565        "               if (cv.car === T) aPop(v);"
Rem     0566        "               return {v: v, m: true};"
Rem     0567        "           }"
Rem     0568        "       } else v = evalLisp(cv);"
Rem     0569        "       c = c.cdr;"
Rem     0570        "   }"
Rem     0571        "   return {v: v, m: false};"
Rem     0572        }
Rem     0573
Rem     0574        function div(c, divFn) {
Rem     0575        "   var t = evalLisp(c.car);"
Rem     0576        "   if (t === NIL) return NIL;"
Rem     0577        "   t = numeric(t);"
Rem     0578        "   while (c.cdr !== NIL) {"
Rem     0579        "       c = c.cdr;"
Rem     0580        "       var v = evalLisp(c.car); if (v === NIL) return NIL;"
Rem     0581        "       if (numeric(v) == 0) throw new Error(newErrMsg(DIV_0));"
Rem     0582        "       t = divFn(t, v);"
Rem     0583        "   }"
Rem     0584        "   return new Number(t);"
Rem     0585        }
Rem     0586
Rem     0587        function eqVal(a, b) {
Rem     0588        "   //alert(""eqVal() "" + a + "", "" + b);"
Rem     0589        "   if (a.TYPEVAL === b.TYPEVAL) {"
Rem     0590        "       if (a === b) return true;"
Rem     0591        "       if (a.TYPEVAL === CELLTYPE) {"
Rem     0592        "           return eqVal(a.car, b.car) ? eqVal(a.cdr, b.cdr) : false;"
Rem     0593        "       }"
Rem     0594        "       return (a.valueOf() == b.valueOf());    // Number or Symbol"
Rem     0595        "   }"
Rem     0596        "   return false;"
Rem     0597        }
Rem     0598
Rem     0599        function ltVal(a, b) {
Rem     0600        "   if (a.TYPEVAL === b.TYPEVAL) {"
Rem     0601        "       if (a === b) return false;"
Rem     0602        "       if (a.TYPEVAL === CELLTYPE) {"
Rem     0603        "           return eqVal(a.car, b.car) ? ltVal(a.cdr, b.cdr) : ltVal(a.car, b.car);"
Rem     0604        "       }"
Rem     0605        "       return a.valueOf() < b.valueOf();   // Number or Symbol"
Rem     0606        "   }"
Rem     0607        "   return a.TYPEVAL < b.TYPEVAL;"
Rem     0608        }
Rem     0609
Rem     0610        function idxLookup(owner, v) {
Rem     0611        "   var tree = owner.getVal();"
Rem     0612        "   if (tree === NIL) return NIL;"
Rem     0613        "   while (!eqVal(v, tree.car)) {"
Rem     0614        "       if (tree.cdr === NIL) return NIL;"
Rem     0615        "       if (ltVal(v, tree.car)) return idxLookup(tree.cdr, v);"
Rem     0616        "       tree = tree.cdr;"
Rem     0617        "       if (tree.cdr === NIL) return NIL;"
Rem     0618        "       tree = tree.cdr;"
Rem     0619        "   }"
Rem     0620        "   return tree;"
Rem     0621        }
Rem     0622
Rem     0623        function idxInsert(owner, v) {
Rem     0624        "   var tree = owner.getVal();"
Rem     0625        "   if (tree === NIL) { owner.setVal(new Cell(v, NIL)); return NIL; }"
Rem     0626        "   while (!eqVal(v, tree.car)) {"
Rem     0627        "       if (tree.cdr === NIL) tree.cdr = new Cell(NIL, NIL);"
Rem     0628        "       if (ltVal(v, tree.car)) return idxInsert(tree.cdr, v);"
Rem     0629        "       tree = tree.cdr;"
Rem     0630        "       if (tree.cdr === NIL) { tree.cdr = new Cell(v, NIL); return NIL; }"
Rem     0631        "       tree = tree.cdr;"
Rem     0632        "       //if (!confirm(""idxInsert: "" + lispToStr(tree))) throw new Error(""idxInsert aborted"");"
Rem     0633        "   }"
Rem     0634        "   return tree;"
Rem     0635        }
Rem     0636
Rem     0637        function idxDelete(owner, v) {
Rem     0638        "   var tree = owner.getVal(), pre = NIL;"
Rem     0639        "   if (tree === NIL) return NIL;"
Rem     0640        "   while (!eqVal(v, tree.car)) {"
Rem     0641        "       if (tree.cdr === NIL) return NIL;"
Rem     0642        "       if (ltVal(v, tree.car)) return idxDelete(tree.cdr, v);"
Rem     0643        "       pre = tree; tree = tree.cdr;"
Rem     0644        "       if (tree.cdr === NIL) return NIL;"
Rem     0645        "       pre = tree; tree = tree.cdr;"
Rem     0646        "       //if (!confirm(""idxDelete: "" + lispToStr(tree))) throw new Error(""idxDelete aborted"");"
Rem     0647        "   }"
Rem     0648        "   // tree.car is the value to delete"
Rem     0649        "   //var bbc = null;       // cell with ""big brother"" to replace tree.car, if needed"
Rem     0650        "   if (tree.cdr.car !== NIL) {"
Rem     0651        "       // There are lesser values that need a new ""big brother""."
Rem     0652        "       if (tree.cdr.cdr !== NIL) {"
Rem     0653        "           var pbc = tree.cdr, bbc = pbc.cdr;"
Rem     0654        "           if (bbc.cdr.car !== NIL) {"
Rem     0655        "               // There are several ""big brother"" candidates, get the smallest ..."
Rem     0656        "               do { pbc = bbc; bbc = bbc.cdr.car; } while (bbc.cdr.car !== NIL);"
Rem     0657        "               pbc.cdr.car = NIL;  // brother's old cell replaced by NIL"
Rem     0658        "           } else {"
Rem     0659        "               // Only one candidate. Cut it and following NIL from list ..."
Rem     0660        "               pbc.cdr = pbc.cdr.cdr.cdr;"
Rem     0661        "           }"
Rem     0662        "           //alert(""idxDelete: "" + lispToStr(bbc));"
Rem     0663        "           tree.car = bbc.car; // value to delete replaced by ""big brother"""
Rem     0664        "       } else {"
Rem     0665        "           // Must promote lesser values"
Rem     0666        "           if (pre === NIL) {"
Rem     0667        "               owner.setVal(tree.cdr.car);"
Rem     0668        "           } else {"
Rem     0669        "               pre.cdr = tree.cdr.car;"
Rem     0670        "           }"
Rem     0671        "       }"
Rem     0672        "   } else {"
Rem     0673        "       // No lesser values following value to delete"
Rem     0674        "       if (pre === NIL) {"
Rem     0675        "           owner.setVal(tree.cdr.cdr);"
Rem     0676        "       } else {"
Rem     0677        "           pre.cdr = tree.cdr.cdr;"
Rem     0678        "       }"
Rem     0679        "   }"
Rem     0680        "   return tree;"
Rem     0681        }
Rem     0682
Rem     0683        function idxLinkSorted(tree) {
Rem     0684        "   while (tree !== NIL)"
Rem     0685        "   { idxLinkSorted(tree.cdr.car); link(tree.car); tree = tree.cdr.cdr; }"
Rem     0686        }
Rem     0687
Rem     0688        /*
Rem     0689        * If 'evaluate' is true, each top level expression will be evaluated, and the result
Rem     0690        * of the last evaluation ('evRes') will be returned. A top level NIL or equivalent
Rem     0691        * will terminate further parsing.
Rem     0692        * If 'evaluate' is false/undefined, the source at the current level will be parsed,
Rem     0693        * and a corresponding tree of cells will be returned (through the 'cdr' at the bottom).
Rem     0694        * If 'editMode' is true, parsed symbols will not be inserted into the dictionaries.
Rem     0695        */
Rem     0696        function parseList(src, evaluate, editMode) {
Rem     0697        "   var ch, s, dotPos = 0, quotes = 0, items = [], cdr = NIL, evRes = NIL, circEnd = null;"
Rem     0698        "   do {"
Rem     0699        "       ch = src.getNextSignificantChar();"
Rem     0700        "       if (ch == ""'"") {"
Rem     0701        "           quotes++;"
Rem     0702        "       } else if (ch == "")"") {"
Rem     0703        "           break;"
Rem     0704        "       } else if ((ch == ""."") && (items.length > 0)) {"
Rem     0705        "           if (dotPos > 0) throw new Error(newErrMsg(BAD_DOT,"
Rem     0706        "                                               ""("" + lispToStr(items[items.length-1]) + "" . \\.)""));"
Rem     0707        "           dotPos = items.length;"
Rem     0708        "       } else if (ch !== src.EOF) {"
Rem     0709        "           var item;"
Rem     0710        "           if (ch == ""("") {"
Rem     0711        "               var tmp = parseList(src, false, editMode);"
Rem     0712        "               if (evaluate && (tmp !== NIL)) evRes = evalLisp(tmp);"
Rem     0713        "               item = tmp;"
Rem     0714        "           } else if (ch == ""\"""") {"
Rem     0715        "               s = """";"
Rem     0716        "               while (typeof (ch = src.getNextStringChar()) == ""string"") s += ch;"
Rem     0717        "               item = (s == """") ? NIL : getString(s, editMode);"
Rem     0718        "               src.traceItemEnd(item);     // in case we would like to know item's position"
Rem     0719        "           } else {"
Rem     0720        "               s = ch;"
Rem     0721        "               while (typeof (ch = src.getNextSymbolChar()) == ""string"") s += ch;"
Rem     0722        "               item = isNaN(s) ? getSymbol(s, editMode) : new Number(s);"
Rem     0723        "               src.traceItemEnd(item);     // in case we would like to know item's position"
Rem     0724        "           }"
Rem     0725        "           if (evaluate && (item === NIL)) return evRes;"
Rem     0726        "           if ((dotPos > 0) && (items.length > dotPos)) throw new Error(newErrMsg(BAD_DOT));"
Rem     0727        "           // TODO: provide a 'badValue' param for newErrMsg(BAD_DOT) above. Case: (1 (2 3) . 4 5)"
Rem     0728        "           while (quotes > 0) { item = new Cell(QUOTE, item); quotes--; }"
Rem     0729        "           items.push(item);"
Rem     0730        "       }"
Rem     0731        "   } while ((ch !== src.CLOSEPAREN) && (ch !== src.EOF));"
Rem     0732        "   if (evaluate) return evRes;"
Rem     0733        "   if (dotPos > 0) {"
Rem     0734        "       if (dotPos == items.length) {"
Rem     0735        "           cdr = new Cell(items.pop(), cdr);"
Rem     0736        "           circEnd = cdr;      // last cell in circular (x y z .) notation"
Rem     0737        "       } else { cdr = items.pop(); }   // normal dot notation"
Rem     0738        "   }"
Rem     0739        "   while (items.length > 0) cdr = new Cell(items.pop(), cdr);"
Rem     0740        "   if (circEnd != null) circEnd.cdr = cdr;"
Rem     0741        "   return cdr;"
Rem     0742        }
Rem     0743
Rem     0744        function cachedTextParse(str) {
Rem     0745        "   var lst = gParseCache[str];"
Rem     0746        "   if (lst === undefined) {"
Rem     0747        "       lst = parseList(new Source(str));"
Rem     0748        "       gParseCache[str] = lst;"
Rem     0749        "   }"
Rem     0750        "   return lst;"
Rem     0751        }
Rem     0752
Rem     0753        function unevalArgs(lst) {
Rem     0754        "   // Putting elements of lst into anonymous symbols"
Rem     0755        "   mkNew(); while (lst !== NIL) { link(box(lst.car)); lst = lst.cdr; }"
Rem     0756        "   return mkResult();"
Rem     0757        }
Rem     0758
Rem     0759        function applyFn(rawFn, lst, more) {
Rem     0760        "   if (more !== NIL) {"
Rem     0761        "       mkNew(); do { link(evalLisp(more.car)); more = more.cdr; } while (more !== NIL);"
Rem     0762        "       mk[0].t.cdr = lst; lst = mkResult();"
Rem     0763        "   }"
Rem     0764        "   var fn = evalLisp(rawFn); if (! (fn instanceof Symbol)) fn = box(fn);"
Rem     0765        "   return evalLisp(new Cell(fn, unevalArgs(lst)));"
Rem     0766        }
Rem     0767
Rem     0768        deFn("apply", function(c) { return applyFn(c.car, evalLisp(c.cdr.car), c.cdr.cdr); });
Rem     0769        deFn("arg", function(c) { var n = 0, f = evFrames.car;
Rem     0770        "   if (c !== NIL) {"
Rem     0771        "       n = Math.round(numeric(evalLisp(c.car))); if (n < 1) return NIL;"
Rem     0772        "   }"
Rem     0773        "   while (n-- > 0) f = f.cdr;"
Rem     0774        "   return f.car;"
Rem     0775        });
Rem     0776        deFn("args", function(c) { return (evFrames.car.cdr === NIL) ? NIL : T; });
Rem     0777        deFn("bench", function(c) { var t0 = (new Date()).getTime(), r = prog(c);
Rem     0778        "   _stdPrint(((new Date()).getTime() - t0) / 1000 + "" sec\n""); return r;"
Rem     0779        });
Rem     0780        deFn("box", function(c) { return box(evalLisp(c.car)); });
Rem     0781        deFn("caar", function(c) { return car(car(evalLisp(c.car))); });
Rem     0782        deFn("caddr", function(c) { return car(cdr(cdr(evalLisp(c.car)))); });
Rem     0783        deFn("cadr", function(c) { return car(cdr(evalLisp(c.car))); });
Rem     0784        deFn("car", function(c) { return car(evalLisp(c.car)); });
Rem     0785        deFn("cdar", function(c) { return cdr(car(evalLisp(c.car))); });
Rem     0786        deFn("cddr", function(c) { return cdr(cdr(evalLisp(c.car))); });
Rem     0787        deFn("cdr", function(c) { return cdr(evalLisp(c.car)); });
Rem     0788        deFn("chop", function(c) { var cv = evalLisp(c.car);
Rem     0789        "   if ((cv === NIL) || (cv instanceof Cell)) return cv;"
Rem     0790        "   var s = (cv instanceof Symbol) ? cv.valueOf() : cv.toString();"
Rem     0791        "   if (s === null) return NIL;"
Rem     0792        "   var arr = s.split(""""), v = NIL;"
Rem     0793        "   while (arr.length > 0) v = new Cell(newTransSymbol(arr.pop()), v);"
Rem     0794        "   return v;"
Rem     0795        });
Rem     0796        deFn("cond", function(c) {
Rem     0797        "   while (c.car instanceof Cell) {"
Rem     0798        "       if (aTrue(evalLisp(c.car.car))) return aPop(prog(c.car.cdr));"
Rem     0799        "       c = c.cdr;"
Rem     0800        "   }"
Rem     0801        "   return NIL;"
Rem     0802        });
Rem     0803        deFn("cons", function(c) { var r = new Cell(evalLisp(c.car), evalLisp(c.cdr.car)), t = r;
Rem     0804        "   c = c.cdr.cdr;"
Rem     0805        "   while (c !== NIL) { var d = new Cell(t.cdr, evalLisp(c.car)); t.cdr = d; t = d; c = c.cdr; }"
Rem     0806        "   return r;"
Rem     0807        });
Rem     0808        deFn("de", function(c) { var old = c.car.getVal();
Rem     0809        "   setSymbolValue(c.car, c.cdr);"
Rem     0810        "   if ((old !== NIL) && !eqVal(c.cdr, old)) _warn(""# "" + c.car.valueOf() + "" redefined"");"
Rem     0811        "   return c.car;"
Rem     0812        });
Rem     0813        deFn("dec", function(c) {
Rem     0814        "   if (c === NIL) return NIL;"
Rem     0815        "   var ns = evalLisp(c.car);"
Rem     0816        "   if (ns instanceof Number) return new Number(ns - 1);"
Rem     0817        "   var v = new Number(ns.getVal() - ((c.cdr !== NIL) ? numeric(evalLisp(c.cdr.car)) : 1));"
Rem     0818        "   ns.setVal(v); return v;"
Rem     0819        });
Rem     0820        deFn("delete", function(c) { var a = evalLisp(c.car), lst = evalLisp(c.cdr.car);
Rem     0821        "   if (!(lst instanceof Cell)) return lst;"
Rem     0822        "   if (eqVal(a, lst.car)) return lst.cdr;"
Rem     0823        "   mkNew(); link(lst.car); lst = lst.cdr;"
Rem     0824        "   while (lst instanceof Cell) {"
Rem     0825        "       if (eqVal(a, lst.car)) { mk[0].t.cdr = lst.cdr; return mkResult(); }"
Rem     0826        "       link(lst.car); lst = lst.cdr;"
Rem     0827        "   }"
Rem     0828        "   mk[0].t.cdr = lst;  // taking care of dotted tail"
Rem     0829        "   return mkResult();"
Rem     0830        });
Rem     0831        deFn("do", function(c) {
Rem     0832        "   var n = evalLisp(c.car);"
Rem     0833        "   if (n === NIL) return NIL;"
Rem     0834        "   var step = 1, b = c.cdr, v = NIL;"
Rem     0835        "   if (n === T) { n = 1; step = 0; }"
Rem     0836        "   for (var i=1; i<=n; i+=step) {"
Rem     0837        "       var r = iter(b); v = r.v; if (r.m) break;"
Rem     0838        "   }"
Rem     0839        "   return v;"
Rem     0840        });
Rem     0841        "deFn(""eval"", function(c) { return evalLisp(evalLisp(c.car)); }); // TODO: binding env. offset cnt"
Rem     0842        deFn("fin", function(c) { c = evalLisp(c.car); while (c instanceof Cell) { c = c.cdr; }; return c; });
Rem     0843        deFn("for", function(c) {
Rem     0844        "   var s = null, s2 = null, v = NIL;"
Rem     0845        "   if (c.car instanceof Symbol) {"
Rem     0846        "       s = c.car;"
Rem     0847        "   } else if (c.car.cdr instanceof Symbol) {"
Rem     0848        "       s2 = c.car.car; s = c.car.cdr;"
Rem     0849        "   }"
Rem     0850        "   if (s != null) {"
Rem     0851        "       s.pushValue(NIL);   if (s2 != null) s2.pushValue(ZERO);"
Rem     0852        "       var nl = evalLisp(c.cdr.car), b = c.cdr.cdr, i = 0;"
Rem     0853        "       if (nl instanceof Number) {"
Rem     0854        "           //alert(""for: 1st form""); // (for I 3 (js:confirm I))"
Rem     0855        "           while (++i <= nl) {"
Rem     0856        "               s.setVal(new Number(i));"
Rem     0857        "               var r = iter(b); v = r.v; if (r.m) break;"
Rem     0858        "           }"
Rem     0859        "       } else {"
Rem     0860        "           //alert(""for: 2nd form""); // (for (I . X) (22 33 44) (js:confirm (+ I X)) (+ I X))"
Rem     0861        "           while (nl instanceof Cell) {"
Rem     0862        "               s.setVal(nl.car); if (s2 != null) s2.setVal(new Number(++i));"
Rem     0863        "               var r = iter(b); v = r.v; if (r.m) break;"
Rem     0864        "               nl = nl.cdr;"
Rem     0865        "           }"
Rem     0866        "       }"
Rem     0867        "   } else {"
Rem     0868        "       //alert(""for: 3rd form"");"
Rem     0869        "       if (c.car.car instanceof Symbol) {"
Rem     0870        "           s = c.car.car;"
Rem     0871        "       } else {"
Rem     0872        "           s2 = c.car.car.car; s = c.car.car.cdr;"
Rem     0873        "       }"
Rem     0874        "       s.pushValue(evalLisp(c.car.cdr.car));   if (s2 != null) s2.pushValue(ZERO);"
Rem     0875        "       var a2p = c.car.cdr.cdr, a2 = a2p.car, b = c.cdr, i = 0;"
Rem     0876        "       var p = (a2p.cdr instanceof Cell) ? a2p.cdr.car : null;"
Rem     0877        "       while (evalLisp(a2) !== NIL) {"
Rem     0878        "           if (s2 != null) s2.setVal(new Number(++i));"
Rem     0879        "           var r = iter(b); v = r.v; if (r.m) break;"
Rem     0880        "           if (p != null) s.setVal(evalLisp(p));"
Rem     0881        "       }"
Rem     0882        "   }"
Rem     0883        "   s.popValue();   if (s2 != null) s2.popValue();"
Rem     0884        "   return v;"
Rem     0885        });
Rem     0886        deFn("get", function(c) { return getAlg(evalArgs(c)); });
Rem     0887        deFn("getl", function(c) { var s = getAlg(evalArgs(c));
Rem     0888        "   if (s instanceof Symbol) return s.props;"
Rem     0889        "   throw new Error(newErrMsg(SYM_EXP, s));"
Rem     0890        });
Rem     0891        deFn("idx", function(c) { var s = evalLisp(c.car);
Rem     0892        "   if (!(s instanceof Symbol)) return NIL;"
Rem     0893        "   if (c.cdr === NIL) { mkNew(); idxLinkSorted(s.getVal()); return mkResult(); }"
Rem     0894        "   var a = evalLisp(c.cdr.car);"
Rem     0895        "   if (c.cdr.cdr === NIL) return idxLookup(s, a);"
Rem     0896        "   return (evalLisp(c.cdr.cdr.car) === NIL) ? idxDelete(s, a) : idxInsert(s, a);"
Rem     0897        });
Rem     0898        deFn("if", function(c) { return aTrue(evalLisp(c.car)) ? aPop(evalLisp(c.cdr.car)) : prog(c.cdr.cdr); });
Rem     0899        deFn("ifn", function(c) { return aTrue(evalLisp(c.car)) ? aPop(prog(c.cdr.cdr)) : evalLisp(c.cdr.car); });
Rem     0900        deFn("inc", function(c) {
Rem     0901        "   if (c === NIL) return NIL;"
Rem     0902        "   var ns = evalLisp(c.car);"
Rem     0903        "   if (ns instanceof Number) return new Number(ns + 1);"
Rem     0904        "   var v = new Number(ns.getVal() + ((c.cdr !== NIL) ? numeric(evalLisp(c.cdr.car)) : 1));"
Rem     0905        "   ns.setVal(v); return v;"
Rem     0906        });
Rem     0907        deFn("length", function(c) { var cv = evalLisp(c.car), v = 0;
Rem     0908        "   if (cv instanceof Number) { v = cv.toString().length; }"
Rem     0909        "   else if (cv instanceof Symbol) { v = cv.lock ? cv.toValueString().length :"
Rem     0910        "       (cv.name === null) ? 0 : cv.name.length; }"
Rem     0911        "   else if (cv instanceof Cell) { var cs = cv;"
Rem     0912        "       while (cs !== NIL) { v++; cs = cs.cdr; if (cs === cv) return T; }}"
Rem     0913        "   return new Number(v);"
Rem     0914        });
Rem     0915        deFn("let", function(c) {
Rem     0916        "   var symArr = [], p = c.cdr;"
Rem     0917        "   if (c.car instanceof Symbol) {"
Rem     0918        "       if (c.car !== NIL) {"
Rem     0919        "           c.car.pushValue(evalLisp(c.cdr.car)); symArr.push(c.car); p = c.cdr.cdr;"
Rem     0920        "       }"
Rem     0921        "   } else if (c.car instanceof Cell) {"
Rem     0922        "       var sv = c.car;"
Rem     0923        "       while (sv !== NIL) {"
Rem     0924        "           sv.car.pushValue(evalLisp(sv.cdr.car)); symArr.push(sv.car); sv = sv.cdr.cdr;"
Rem     0925        "       }"
Rem     0926        "   }"
Rem     0927        "   var v = prog(p);"
Rem     0928        "   while (symArr.length > 0) { symArr.pop().popValue(); }"
Rem     0929        "   return v;"
Rem     0930        });
Rem     0931        deFn("link", linkc);
Rem     0932        deFn("list", function(c) { return (c !== NIL) ? evalArgs(c) : new Cell(NIL, NIL); });
Rem     0933        deFn("load", function(c) { var r = NIL;
Rem     0934        "   while (c instanceof Cell) {"
Rem     0935        "       var cv = evalLisp(c.car);"
Rem     0936        "       if (cv instanceof Symbol) {"
Rem     0937        "           var f = cv.toValueString();"
Rem     0938        "           if (f.charAt(0) == ""-"") {"
Rem     0939        "               r = parseList(new Source(""("" + f.substring(1) + "")""), true);"
Rem     0940        "           } else {"
Rem     0941        "               r = (f.match(/\.js$/)) ? loadJavaScript(f) : loadLisp(f);"
Rem     0942        "           }"
Rem     0943        "       }"
Rem     0944        "       c = c.cdr;"
Rem     0945        "   }"
Rem     0946        "   return r;"
Rem     0947        });
Rem     0948        deFn("loop", function(c) {
Rem     0949        "   var v = NIL; while (true) { var r = iter(c); v = r.v; if (r.m) break; }; return v;"
Rem     0950        });
Rem     0951        deFn("make", function(c) { mkNew(); prog(c); return mkResult(); });
Rem     0952        deFn("mapc", function(c) { var r = NIL, fn = evalLisp(c.car), ci = evalArgs(c.cdr);
Rem     0953        "   if (! (fn instanceof Symbol)) fn = box(fn);"
Rem     0954        "   while (ci.car !== NIL) { var cj = ci; mkNew();"
Rem     0955        "       while (cj !== NIL) { link(cj.car.car); cj.car = cj.car.cdr; cj = cj.cdr; }"
Rem     0956        "       r = evalLisp(new Cell(fn, unevalArgs(mkResult())));"
Rem     0957        "   }"
Rem     0958        "   return r;"
Rem     0959        });
Rem     0960        deFn("mapcar", function(c) { var fn = evalLisp(c.car), ci = evalArgs(c.cdr);
Rem     0961        "   if (! (fn instanceof Symbol)) fn = box(fn);"
Rem     0962        "   mkNew();"
Rem     0963        "   while (ci.car !== NIL) { var cj = ci; mkNew();"
Rem     0964        "       //if (!confirm(lispToStr(cj))) throw new Error(""mapcar aborted"");"
Rem     0965        "       while (cj !== NIL) { link(cj.car.car); cj.car = cj.car.cdr; cj = cj.cdr; }"
Rem     0966        "       link(evalLisp(new Cell(fn, unevalArgs(mkResult()))));"
Rem     0967        "   }"
Rem     0968        "   return mkResult();"
Rem     0969        });
Rem     0970        deFn("next", function(c) { evFrames.car = evFrames.car.cdr; return evFrames.car.car; });
Rem     0971        deFn("not", function(c) { return (evalLisp(c.car) === NIL) ? T : NIL; });
Rem     0972        deFn("nth", function(c) { var lst = evalArgs(c); c = lst.cdr;
Rem     0973        "   do { lst = nth(lst.car, numeric(c.car)); c = c.cdr; } while(c !== NIL); return lst; });"
Rem     0974        // pack has no support for circular lists, same as in PicoLisp
Rem     0975        deFn("pack", function(c) { return (c !== NIL) ? newTransSymbol(valueToStr(evalArgs(c))) : NIL; });
Rem     0976        deFn("pass", function(c) { return applyFn(c.car, evFrames.car.cdr, c.cdr); });
Rem     0977        deFn("pop", function(c) { var cv = evalLisp(c.car);
Rem     0978        "   if (cv.getVal) {"
Rem     0979        "       var v = cv.getVal();"
Rem     0980        "       if (v instanceof Cell) { cv.setVal(v.cdr); return v.car; }"
Rem     0981        "       if (v === NIL) return NIL;"
Rem     0982        "       if (cv instanceof Cell) return cv.car;"
Rem     0983        "   }"
Rem     0984        "   throw new Error(newErrMsg(VAR_EXP, cv));"
Rem     0985        });
Rem     0986        deFn("prin", function(c) {
Rem     0987        "   c = evalArgs(c); _stdPrint(c.toValueString());"
Rem     0988        "   while (c.cdr !== NIL) { c = c.cdr; }; return c.car;"
Rem     0989        });
Rem     0990        deFn("prinl", function(c) {
Rem     0991        "   c = evalArgs(c); _stdPrint(c.toValueString() + ""\n"");"
Rem     0992        "   while (c.cdr !== NIL) { c = c.cdr; }; return c.car;"
Rem     0993        });
Rem     0994
Rem     0995        function printx(c, x) { var arr = [];
Rem     0996        "   c = evalArgs(c); arr.push(lispToStr(c.car));"
Rem     0997        "   while (c.cdr !== NIL) { c = c.cdr; arr.push(lispToStr(c.car)); }"
Rem     0998        "   _stdPrint(arr.join("" "") + x); return c.car;"
Rem     0999        }
Rem     1000
Rem     1001        deFn("print", function(c) { return printx(c, ""); });
Rem     1002        deFn("println", function(c) { return printx(c, "\n"); });
Rem     1003        deFn("printsp", function(c) { return printx(c, " "); });
Rem     1004        deFn("prog", prog);
Rem     1005        deFn("push", function(c) { var t = evalLisp(c.car), v;
Rem     1006        "   if (t.getVal) {"
Rem     1007        "       do { c = c.cdr; v = evalLisp(c.car); t.setVal(new Cell(v, t.getVal())); } while (c.cdr !== NIL);"
Rem     1008        "       return v;"
Rem     1009        "   }"
Rem     1010        "   throw new Error(newErrMsg(VAR_EXP, t));"
Rem     1011        });
Rem     1012        deFn("put", function(c) {
Rem     1013        "   var kc, vc;"
Rem     1014        "   c = evalArgs(c); mkNew();"
Rem     1015        "   do { link(c.car); kc = c.cdr; vc = kc.cdr; c = c.cdr; } while (vc.cdr !== NIL);"
Rem     1016        "   var s = getAlg(mkResult()), k = kc.car;"
Rem     1017        "   if (!(s instanceof Symbol)) throw new Error(newErrMsg(SYM_EXP, s));"
Rem     1018        "   if (s === NIL) throw new Error(newErrMsg(PROT_SYM, s));"
Rem     1019        "   if (eqVal(k, ZERO)) {"
Rem     1020        "       s.setVal(vc.car);"
Rem     1021        "   } else {"
Rem     1022        "       var pLst = s.props, pre = NIL;"
Rem     1023        "       while (pLst !== NIL) {"
Rem     1024        "           var pc = pLst.car, pk = (pc instanceof Cell) ? pc.cdr : pc;"
Rem     1025        "           if (pk === k) {"
Rem     1026        "               if (pre === NIL) { s.props = pLst.cdr; } else { pre.cdr = pLst.cdr; }   // removing old"
Rem     1027        "               break;"
Rem     1028        "           }"
Rem     1029        "           pre = pLst; pLst = pLst.cdr;"
Rem     1030        "       }"
Rem     1031        "       if (vc.car !== NIL) {"
Rem     1032        "           var pc = new Cell((vc.car === T) ? k : new Cell(vc.car, k), s.props);"
Rem     1033        "           s.props = pc;"
Rem     1034        "       }"
Rem     1035        "       //alert(""put props: "" + lispToStr(s.props));"
Rem     1036        "   }"
Rem     1037        "   return vc.car;"
Rem     1038        });
Rem     1039        deFn("queue", function(c) { var s = evalLisp(c.car);
Rem     1040        "   if (s.getVal) {"
Rem     1041        "       var cv = s.getVal(), t = new Cell(evalLisp(c.cdr.car), NIL);"
Rem     1042        "       if (cv === NIL) { s.setVal(t); return t.car; }"
Rem     1043        "       if (cv instanceof Cell) {"
Rem     1044        "           while (cv.cdr !== NIL) cv = cv.cdr;"
Rem     1045        "           cv.cdr = t; return t.car;"
Rem     1046        "       }"
Rem     1047        "   }"
Rem     1048        "   throw new Error(newErrMsg(VAR_EXP, s));"
Rem     1049        });
Rem     1050        deFn("quote", function(c) { return c; });
Rem     1051        var QUOTE = getSymbol("quote");
Rem     1052        deFn("rand", function(c) { var r = Math.random();
Rem     1053        "   if (c === NIL) return new Number(r);    // range 0.0 .. 1.0"
Rem     1054        "   var n = evalLisp(c.car);"
Rem     1055        "   if (n === T) return (r < 0.5) ? NIL : T;"
Rem     1056        "   return new Number((-numeric(n) + numeric(evalLisp(c.cdr.car))) * r + n);"
Rem     1057        });
Rem     1058        deFn("range", function(c) {
Rem     1059        "   var n = numeric(evalLisp(c.car)), n2 = numeric(evalLisp(c.cdr.car)), s = evalLisp(c.cdr.cdr.car);"
Rem     1060        "   if (s === NIL) { s = 1; } else if (numeric(s) <= 0) throw new Error(newErrMsg(BAD_ARG, s));"
Rem     1061        "   if (n > n2) s = -s;"
Rem     1062        "   mkNew(); do { link(n); n = new Number(n + s); } while ((s > 0) ? (n <= n2) : (n >= n2));"
Rem     1063        "   return mkResult();"
Rem     1064        });
Rem     1065        deFn("rest", function(c) { return evFrames.car.cdr; });
Rem     1066        deFn("reverse", function(c) { var lst = evalLisp(c.car), r = NIL;
Rem     1067        "   if (!(lst instanceof Cell)) return NIL;"
Rem     1068        "   do { r = new Cell(lst.car, r); lst = lst.cdr; } while (lst instanceof Cell);"
Rem     1069        "   return r;"
Rem     1070        });
Rem     1071        deFn("setq", function(c) {
Rem     1072        "   var v = NIL;"
Rem     1073        "   while (c instanceof Cell) {"
Rem     1074        "       v = (c.cdr instanceof Cell) ? evalLisp(c.cdr.car) : NIL;"
Rem     1075        "       setSymbolValue(c.car, v);"
Rem     1076        "       c = (c.cdr instanceof Cell) ? c.cdr.cdr : NIL;"
Rem     1077        "   }"
Rem     1078        "   return v;"
Rem     1079        });
Rem     1080
Rem     1081        function ascending(a, b) { return ltVal(a, b) ? -1 : eqVal(a, b) ? 0 : 1; }
Rem     1082        //function descending(a, b) { return ltVal(a, b) ? 1 : eqVal(a, b) ? 0 : -1; }
Rem     1083
Rem     1084        "var compExprArr = [];  // sort expression stack"
Rem     1085
Rem     1086        function CompExpr(fn) {
Rem     1087        "   if (! (fn instanceof Symbol)) fn = box(fn);"
Rem     1088        "   this.arg1Sym = box(NIL);"
Rem     1089        "   this.arg2Sym = box(NIL);"
Rem     1090        "   this.expr = new Cell(fn, new Cell(this.arg1Sym, new Cell(this.arg2Sym, NIL)));"
Rem     1091        }
Rem     1092
Rem     1093        CompExpr.prototype.evalTrue = function(a, b) {
Rem     1094        "   this.arg1Sym.cdr = a;   // faster than this.arg1Sym.setVal(a);"
Rem     1095        "   this.arg2Sym.cdr = b;"
Rem     1096        "   return (evalLisp(this.expr) === T);"
Rem     1097        }
Rem     1098
Rem     1099        function lispFnOrder(a, b) { return compExprArr[0].evalTrue(a, b) ? -1 : 1; }
Rem     1100
Rem     1101        deFn("sort", function(c) {
Rem     1102        "   var lst = evalLisp(c.car);"
Rem     1103        "   if (lst instanceof Cell) {"
Rem     1104        "       var fn = evalLisp(c.cdr.car), arr = [];"
Rem     1105        "       do { arr.push(lst.car); lst = lst.cdr; } while (lst instanceof Cell);"
Rem     1106        "       if (fn === NIL) {"
Rem     1107        "           arr.sort(ascending);"
Rem     1108        "       } else {"
Rem     1109        "           compExprArr.unshift(new CompExpr(fn));"
Rem     1110        "           arr.sort(lispFnOrder);  // roughly twice as slow as 'ascending' (above), if fn is '>'"
Rem     1111        "           compExprArr.shift();"
Rem     1112        "       }"
Rem     1113        "       lst = NIL;"
Rem     1114        "       while (arr.length > 0) lst = new Cell(arr.pop(), lst);"
Rem     1115        "   }"
Rem     1116        "   return lst;"
Rem     1117        });
Rem     1118        deFn("str", function(c) {
Rem     1119        "   var cv = evalLisp(c.car);"
Rem     1120        "   if (cv instanceof Symbol) {"
Rem     1121        "       var cs = evalLisp(c.cdr.car);"
Rem     1122        "       return (cs === NIL) ? cachedTextParse(cv.valueOf()) :"
Rem     1123        "               parseList(new Source(cv.valueOf(), cs.valueOf()));"
Rem     1124        "   }"
Rem     1125        "   if (cv instanceof Cell) {"
Rem     1126        "       var arr = [];"
Rem     1127        "       do { arr.push(lispToStr(cv.car)); cv = cv.cdr; } while (cv instanceof Cell);"
Rem     1128        "       return newTransSymbol(arr.join("" ""));"
Rem     1129        "   }"
Rem     1130        "   if (cv === NIL) return NIL;"
Rem     1131        "   throw new Error(newErrMsg(CELL_EXP, cv));"
Rem     1132        });
Rem     1133        deFn("tail", function(c) {
Rem     1134        "   var cl = evalLisp(c.car), lst = evalLisp(c.cdr.car);"
Rem     1135        "   if (cl instanceof Cell) {"
Rem     1136        "       var cv = cl, arr = []; while (lst !== NIL) { arr.unshift(lst.car); lst = lst.cdr; }"
Rem     1137        "       if (arr.length == 0) return NIL;"
Rem     1138        "       var sub = []; while (cl !== NIL) { sub.unshift(cl.car); cl = cl.cdr; }"
Rem     1139        "       if (arr.length < sub.length) return NIL;"
Rem     1140        "       for (var i=0; i<sub.length; i++) {"
Rem     1141        "           if (!eqVal(sub[i], arr[i])) return NIL;"
Rem     1142        "       }"
Rem     1143        "       return cv;"
Rem     1144        "   }"
Rem     1145        "   if (cl instanceof Number) {"
Rem     1146        "       cl = Math.round(cl);"
Rem     1147        "       if (cl > 0) {"
Rem     1148        "           var arr = []; while (lst !== NIL) { arr.push(lst); lst = lst.cdr; }"
Rem     1149        "           return arr[Math.max(arr.length - cl, 0)];"
Rem     1150        "       }"
Rem     1151        "       if (cl < 0) {"
Rem     1152        "           do { lst = lst.cdr; if (++cl == 0) return lst; } while (lst !== NIL);"
Rem     1153        "       }"
Rem     1154        "       return NIL; // cl == 0, or we did not return above"
Rem     1155        "   }"
Rem     1156        "   if (cl === NIL) return NIL;"
Rem     1157        "   throw new Error(newErrMsg(NUM_EXP, cl));"
Rem     1158        });
Rem     1159        deFn("trace", function(c) { var s = evalLisp(c.car), f = evalLisp(s);
Rem     1160        "   if (f instanceof Cell) {"
Rem     1161        "       setSymbolValue(s, new Cell(f.car, new Cell(new Cell(gSym[""$""], new Cell(s, f)), NIL)));"
Rem     1162        "   } else {"
Rem     1163        "       setSymbolValue(s, new Cell(A1, new Cell(new Cell(gSym[""$""], new Cell(s,"
Rem     1164        "           new Cell(A1, new Cell(new Cell(gSym[""pass""], new Cell(box(f), NIL)), NIL)))), NIL)));"
Rem     1165        "   }"
Rem     1166        "   return s;"
Rem     1167        });
Rem     1168        deFn("untrace", function(c) {
Rem     1169        "   var s = evalLisp(c.car), f = cdr(cdr(car(cdr(evalLisp(s))))), b = car(cdr(f));"
Rem     1170        "   if (car(b) === gSym[""pass""]) f = evalLisp(car(cdr(b)));"
Rem     1171        "   setSymbolValue(s, f);"
Rem     1172        "   return s;"
Rem     1173        });
Rem     1174        deFn("usec", function(c) { return new Number(((new Date()).getTime() - startupMillis) * 1000); });
Rem     1175        deFn("yoke", function(c) { if (mk.length === 0) throw new Error(newErrMsg(NOT_MAK));
Rem     1176        "   var tn = (mk[0].t === NIL);"
Rem     1177        "   do { var h = new Cell(evalLisp(c.car), mk[0].h);"
Rem     1178        "       mk[0].h = h; if (tn) { mk[0].t = h; tn = false; }"
Rem     1179        "       c = c.cdr; } while (c !== NIL);"
Rem     1180        "   return mk[0].h.car;"
Rem     1181        });
Rem     1182        deFn("zero", function(c) {
Rem     1183        "   do { setSymbolValue(c.car, ZERO); c = c.cdr; } while (c instanceof Cell); return ZERO;"
Rem     1184        });
Rem     1185        // Test: (let (A 3 B 5) ($ f1 (A B) ($ f2 (A B) (* A B))))
Rem     1186        "// (de foo (X Y . @) (+ X Y (next) (next))) (trace 'foo) (foo 4 5 6 7) // not yet"
Rem     1187        deFn("$", function(c) { var lst = c.cdr.car;
Rem     1188        "   gTrcIndent += "" "";"
Rem     1189        "   _stdPrint(gTrcIndent + c.car.name + "" :"");    // TODO: Handle methods"
Rem     1190        "   while (lst instanceof Cell) { _stdPrint("" "" + lispToStr(lst.car.getVal())); lst = lst.cdr; }"
Rem     1191        "   if (lst === A1) {"
Rem     1192        "       lst = evFrames.car.cdr;"
Rem     1193        "       while (lst instanceof Cell) { _stdPrint("" "" + lispToStr(lst.car)); lst = lst.cdr; }"
Rem     1194        "   }"
Rem     1195        "   _stdPrint(""\n"");"
Rem     1196        "   var res = prog(c.cdr.cdr);"
Rem     1197        "   _stdPrint(gTrcIndent + c.car.name + "" = "" + lispToStr(res) + ""\n"");"
Rem     1198        "   gTrcIndent = gTrcIndent.substring(1);"
Rem     1199        "   return res;"
Rem     1200        });
Rem     1201        deFn("+", function(c) { var t = 0;
Rem     1202        "   do { var v = evalLisp(c.car); if (v === NIL) return NIL;"
Rem     1203        "       t += numeric(v); c = c.cdr; } while (c instanceof Cell); return new Number(t);"
Rem     1204        });
Rem     1205        deFn("-", function(c) { var t = evalLisp(c.car);
Rem     1206        "   if (t === NIL) return NIL;"
Rem     1207        "   t = numeric(t); c = c.cdr;"
Rem     1208        "   if (c === NIL) return new Number(-t);"
Rem     1209        "   do { var v = evalLisp(c.car); if (v === NIL) return NIL;"
Rem     1210        "       t -= numeric(v); c = c.cdr; } while (c instanceof Cell); return new Number(t);"
Rem     1211        });
Rem     1212        deFn("*", function(c) { var t = 1;
Rem     1213        "   do { var v = evalLisp(c.car); if (v === NIL) return NIL;"
Rem     1214        "       t *= numeric(v); c = c.cdr; } while (c instanceof Cell); return new Number(t);"
Rem     1215        });
Rem     1216        "deFn(""/"", function(c) { return div(c, function(a, b) { return a / b; }); }); // floating point division"
Rem     1217        deFn("/t", function(c) { return div(c, function(a, b) { var d = a / b;
Rem     1218        "   return (d >= 0) ? Math.floor(d) : Math.ceil(d); }); }); // truncated division"
Rem     1219        deFn("=", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1220        "   while (d.cdr !== NIL) { d = d.cdr; dv = evalLisp(d.car); if (!eqVal(cv, dv)) return NIL; }; return T; });"
Rem     1221        deFn("==", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1222        "   while (d.cdr !== NIL) { d = d.cdr; dv = evalLisp(d.car); if (cv !== dv) return NIL; }; return T; });"
Rem     1223        deFn("<", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1224        "   while (d.cdr !== NIL) {"
Rem     1225        "       d = d.cdr; dv = evalLisp(d.car); if (!ltVal(cv, dv)) return NIL;"
Rem     1226        "       cv = dv;"
Rem     1227        "   }; return T;"
Rem     1228        });
Rem     1229        deFn("<=", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1230        "   while (d.cdr !== NIL) {"
Rem     1231        "       d = d.cdr; dv = evalLisp(d.car); if (ltVal(dv, cv)) return NIL;"
Rem     1232        "       cv = dv;"
Rem     1233        "   }; return T;"
Rem     1234        });
Rem     1235        deFn(">", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1236        "   while (d.cdr !== NIL) {"
Rem     1237        "       d = d.cdr; dv = evalLisp(d.car); if (!ltVal(dv, cv)) return NIL;"
Rem     1238        "       cv = dv;"
Rem     1239        "   }; return T;"
Rem     1240        });
Rem     1241        deFn(">=", function(c) { var cv = evalLisp(c.car), d = c, dv;
Rem     1242        "   while (d.cdr !== NIL) {"
Rem     1243        "       d = d.cdr; dv = evalLisp(d.car); if (ltVal(cv, dv)) return NIL;"
Rem     1244        "       cv = dv;"
Rem     1245        "   }; return T;"
Rem     1246        });
Rem     1247        deFn(";", function(c) { return getAlg(new Cell(evalLisp(c.car), c.cdr)); });
Rem     1248
Rem     1249        function evalDef(def, inExprLst) {
Rem     1250        "   //alert(""evalDef: "" + lispToStr(def.cdr) + "", "" + lispToStr(inExprLst));"
Rem     1251        "   var locVars = null, locSym = null, evFrame = null;"
Rem     1252        "   if (def.car instanceof Symbol) {"
Rem     1253        "       if (def.car === A1) {"
Rem     1254        "           evFrame = new Cell(NIL, evalArgs(inExprLst));"
Rem     1255        "           evFrames = new Cell(evFrame, evFrames); // pushing evFrame onto evFrames"
Rem     1256        "       } else {"
Rem     1257        "           locSym = def.car;"
Rem     1258        "           locSym.pushValue(inExprLst);    // Binding unevaluated list to a single symbol"
Rem     1259        "       }"
Rem     1260        "   } else {"
Rem     1261        "       locVars = def.car;"
Rem     1262        "       var evArgs = evalArgs(inExprLst);"
Rem     1263        "       // Saving old symbol values and binding new values ..."
Rem     1264        "       while (locVars instanceof Cell) {"
Rem     1265        "           //if (!confirm(""locVars: "" + lispToStr(locVars.car))) throw new Error(""evalDef aborted"");"
Rem     1266        "           locVars.car.pushValue(evArgs.car);"
Rem     1267        "           locVars = locVars.cdr;"
Rem     1268        "           evArgs = evArgs.cdr;"
Rem     1269        "       }"
Rem     1270        "       locVars = def.car;"
Rem     1271        "   }"
Rem     1272        "   // Executing body ..."
Rem     1273        "   var res = prog(def.cdr);"
Rem     1274        "   // Restoring previous symbol values ..."
Rem     1275        "   if (locSym instanceof Symbol) locSym.popValue();"
Rem     1276        "   if (locVars instanceof Cell) {"
Rem     1277        "       while (locVars instanceof Cell) { locVars.car.popValue(); locVars = locVars.cdr; }"
Rem     1278        "   }"
Rem     1279        "   if (evFrame instanceof Cell) evFrames = evFrames.cdr;       // popping evFrame"
Rem     1280        "   return res;"
Rem     1281        }
Rem     1282
Rem     1283        function evalLisp(lst) {
Rem     1284        "   if (lst instanceof Symbol) return lst.cdr;"
Rem     1285        "   if (lst instanceof Cell) {"
Rem     1286        "       if (typeof lst.car.cdr === ""function"") {"
Rem     1287        "           return lst.car.cdr(lst.cdr);"
Rem     1288        "       }"
Rem     1289        "       if (lst.car instanceof Symbol) {"
Rem     1290        "           if (lst.car.cdr === NIL) throw new Error(newErrMsg(UNDEF, lst.car));"
Rem     1291        "           return evalDef(lst.car.cdr, lst.cdr);"
Rem     1292        "       }"
Rem     1293        "       if ((lst.car.car === QUOTE) && (lst.car.cdr instanceof Cell)) {"
Rem     1294        "           return evalDef(lst.car.cdr, lst.cdr);"
Rem     1295        "       }"
Rem     1296        "       if (lst.car instanceof Number) return lst;"
Rem     1297        "       throw new Error(newErrMsg(EXEC_OR_NUM_EXP, lst.car));"
Rem     1298        "   }"
Rem     1299        "   return lst;     // a number, or text"
Rem     1300        }
Rem     1301
Rem     1302        function evalArgs(lst) {
Rem     1303        "   if (lst === NIL) return NIL;"
Rem     1304        "   var resLst = new Cell(NIL, NIL);    // to become new list of evaluation results"
Rem     1305        "   var res = resLst;"
Rem     1306        "   do {"
Rem     1307        "       //alert(""evalArgs: "" + lispToStr(lst.car));"
Rem     1308        "       res.car = evalLisp(lst.car);"
Rem     1309        "       lst = lst.cdr;"
Rem     1310        "       if (lst instanceof Cell) {"
Rem     1311        "           res.cdr = new Cell(NIL, NIL);"
Rem     1312        "           res = res.cdr;"
Rem     1313        "       }"
Rem     1314        "   } while (lst instanceof Cell);"
Rem     1315        "   return resLst;"
Rem     1316        }
Rem     1317
Rem     1318        function loadLisp(fileUrl) {
Rem     1319        "   gTrans = {};"
Rem     1320        "   var res = parseList(new Source(getFileSync(fileUrl)), true);"
Rem     1321        "   gTrans = {};"
Rem     1322        "   //alert(""loadLisp: "" + lispToStr(res));"
Rem     1323        "   return res;"
Rem     1324        }
Rem     1325
Rem     1326        function loadJavaScript(fileUrl) {
Rem     1327        "   return newTransSymbol(eval(getFileSync(fileUrl)).toString());"
Rem     1328        }
Rem     1329
Rem     1330        function _stdPrint(text) {
Rem     1331        "   if (typeof stdPrint === ""function"") stdPrint(text)"
Rem     1332        "   else // when function stdPrint is not available in front end"
Rem     1333        "   if (!confirm(""_stdPrint:\n"" + text)) throw new Error(""_stdPrint aborted"");"
Rem     1334        }
Rem     1335
Rem     1336        function _warn(msg) {
Rem     1337        "   if (typeof warn === ""function"") warn(msg);"
Rem     1338        }
Rem     1339
Rem     1340        /*
Rem     1341        * Objects of the Params class are used to deliver evaluated parameter values to
Rem     1342        * JavaScript functions. Some functions take an optional default input value.
Rem     1343        */
Rem     1344        function Params(lst) {
Rem     1345        "   this.lst = lst;"
Rem     1346        }
Rem     1347
Rem     1348        Params.prototype.any = function() {
Rem     1349        "   var val = null;"
Rem     1350        "   if (this.lst !== NIL) {"
Rem     1351        "       val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1352        "   }"
Rem     1353        "   return val;"
Rem     1354        }
Rem     1355
Rem     1356        Params.prototype.bool = function(val) {
Rem     1357        "   if (this.lst !== NIL) {"
Rem     1358        "       val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1359        "   }"
Rem     1360        "   if ((val === NIL) || (val === T)) return val.bool;"
Rem     1361        "   throw new Error(newErrMsg(BOOL_EXP, val));"
Rem     1362        }
Rem     1363
Rem     1364        Params.prototype.natObj = function() {
Rem     1365        "   if (this.lst !== NIL) {"
Rem     1366        "       val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1367        "   }"
Rem     1368        "   if ((val instanceof Symbol) && (val.obj !== undefined)) return val.obj;"
Rem     1369        "   throw new Error(newErrMsg(BOXNAT_EXP, val));"
Rem     1370        }
Rem     1371
Rem     1372        Params.prototype.num = function(val) {
Rem     1373        "   if (this.lst !== NIL) {"
Rem     1374        "       val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1375        "   }"
Rem     1376        "   if (val instanceof Number) return val;"
Rem     1377        "   throw new Error(newErrMsg(NUM_EXP, val));"
Rem     1378        }
Rem     1379
Rem     1380        Params.prototype.optNum = function() {
Rem     1381        "   if (this.lst !== NIL) {"
Rem     1382        "       var val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1383        "       if (val instanceof Number) return val;"
Rem     1384        "       throw new Error(newErrMsg(NUM_EXP, val));"
Rem     1385        "   }"
Rem     1386        "   return null;"
Rem     1387        }
Rem     1388
Rem     1389        Params.prototype.str = function(val) {
Rem     1390        "   if (this.lst !== NIL) {"
Rem     1391        "       val = evalLisp(this.lst.car); this.lst = this.lst.cdr;"
Rem     1392        "   }"
Rem     1393        "   if (val instanceof Symbol) return val.valueOf();"
Rem     1394        "   throw new Error(newErrMsg(SYM_EXP, val));"
Rem     1395        }
Rem     1396
Rem     1397        function symbolRefUrl(symbolName) {
Rem     1398        "   if (symbolName == ""NIL"") {"
Rem     1399        "       return ""ref.html#nilSym"";"
Rem     1400        "   } else if (symbolName.match(/^[a-zA-Z_]/)) {"
Rem     1401        "       return ""ref"" + symbolName.substring(0, 1).toUpperCase() + "".html#"" + symbolName;"
Rem     1402        "   } else if (symbolName.match(/^\*[a-zA-Z_]/)) {"
Rem     1403        "       return ""ref"" + symbolName.substring(1, 2) + "".html#"" + symbolName;"
Rem     1404        "   } else {"
Rem     1405        "       return ""reLI__M_.html#"" + symbolName;"
Rem     1406        "   }"
Rem     1407        }
Rem     1408
Rem     1409
Rem     1410
Rem     1411        "   "
Rem     1412
Rem     1413
Rem     1414        </script>
Rem     1415
Rem     1416        <script type="text/javascript">
Rem     1417        /* 26nov10jk
Rem     1418        * (c) Jon Kleiser
Rem     1419        * http://folk.uio.no/jkleiser/pico/emuLisp/src/js.js
Rem     1420        */
Rem     1421
Rem     1422        /* 26nov10jk
Rem     1423        * (c) Jon Kleiser
Rem     1424        */
Rem     1425
Rem     1426        getSymbol("js:E").setVal(new Number(Math.E));
Rem     1427        getSymbol("js:PI").setVal(new Number(Math.PI));
Rem     1428        getSymbol("js:Doc").setVal(boxNativeObject(document));
Rem     1429        getSymbol("js:Win").setVal(boxNativeObject(window));
Rem     1430
Rem     1431        deFn("js:alert", function(c) { var arr = [], v = NIL;
Rem     1432        "   c = evalArgs(c); while (c !== NIL) { v = c.car; arr.push(valueToStr(v)); c = c.cdr; }"
Rem     1433        "   alert(arr.join(""\n"")); return v;"
Rem     1434        });
Rem     1435
Rem     1436        deFn("js:confirm", function(c) { var arr = [];
Rem     1437        "   c = evalArgs(c); while (c !== NIL) { arr.push(valueToStr(c.car)); c = c.cdr; }"
Rem     1438        "   return confirm(arr.join(""\n"")) ? T : NIL;"
Rem     1439        });
Rem     1440
Rem     1441        // (js:prompt "What's your age?" "fiftysomething")
Rem     1442        deFn("js:prompt", function(c) {
Rem     1443        "   var r = prompt(valueToStr(evalLisp(c.car)), valueToStr(evalLisp(c.cdr.car)));"
Rem     1444        "   return (r !== null) ? newTransSymbol(r) : NIL;"
Rem     1445        });
Rem     1446
Rem     1447        deFn("js:getElementById", function(c) {
Rem     1448        "   var doc = document, elem = doc.getElementById(evalLisp(c.car).valueOf());"
Rem     1449        "   return (elem != null) ? boxNativeObject(elem) : NIL;"
Rem     1450        });
Rem     1451
Rem     1452        // (js:onEventLisp (js:getElementById "parGuide") "click" (prinl "A click on " js:Target))
Rem     1453        deFn("js:onEventLisp", function(c) {
Rem     1454        "   var objBox = evalLisp(c.car), obj = objBox.obj, evtType = evalLisp(c.cdr.car).valueOf();"
Rem     1455        "   obj[evtType + ""Lisp""] = c.cdr.cdr;    // Lisp code to execute on event"
Rem     1456        "   if (c.cdr.cdr != NIL) {"
Rem     1457        "       // Installing event handler"
Rem     1458        "       obj[""on"" + evtType] = function(evt) {"
Rem     1459        "           try {"
Rem     1460        "               var ts = getSymbol(""js:Target""); ts.pushValue(objBox);"
Rem     1461        "               var es = getSymbol(""js:Event""); es.pushValue(boxNativeObject(evt ? evt : window.event));"
Rem     1462        "               prog(obj[evtType + ""Lisp""]);"
Rem     1463        "               ts.popValue();"
Rem     1464        "               es.popValue();"
Rem     1465        "           } catch (e) { alert(evtType + ""Lisp: "" + e); }"
Rem     1466        "       };"
Rem     1467        "   } else {"
Rem     1468        "       // Removing event handler"
Rem     1469        "       obj[""on"" + evtType] = null;"
Rem     1470        "   }"
Rem     1471        "   return objBox;"
Rem     1472        });
Rem     1473
Rem     1474
Rem     1475        // (js:clearInterval intervalId)
Rem     1476        deFn("js:clearInterval", function(c) { return clearInterval(evalLisp(c.car)) ? T : NIL; });
Rem     1477
Rem     1478        // (js:clearTimeout timeoutId)
Rem     1479        deFn("js:clearTimeout", function(c) { return clearTimeout(evalLisp(c.car)) ? T : NIL; });
Rem     1480
Rem     1481        /* Most browsers seem to support the form of setInterval(f,t,p) and setTimeout(f,t,p) where
Rem     1482        the first parameter is of type function, and the parameters after the second are parameters
Rem     1483        to that function. If your browser requires the first parameter to be of type string, then
Rem     1484        you can use the two slightly longer alternatives.
Rem     1485        */
Rem     1486        // (js:setIntervalLisp (prinl "ping") 5000)
Rem     1487        deFn("js:setIntervalLisp", function(c) {
Rem     1488        "   var id = setInterval(evalLisp, evalLisp(c.cdr.car), c.car);"
Rem     1489        "   return new Number(id);"
Rem     1490        });
Rem     1491        /*
Rem     1492        deFn("js:setIntervalLisp", function(c) {
Rem     1493        "   var str = lispToStr(c.car);"
Rem     1494        "   gParseCache[str] = c.car;"
Rem     1495        "   var jsStr = ""evalLisp(gParseCache[\"""" + str.replace(/""/g, ""\\\"""") + ""\""])"";"
Rem     1496        "   var id = setInterval(jsStr, evalLisp(c.cdr.car));"
Rem     1497        "   return new Number(id);"
Rem     1498        });
Rem     1499        */
Rem     1500        // (js:setTimeoutLisp (prinl "ping") 3000)
Rem     1501        deFn("js:setTimeoutLisp", function(c) {
Rem     1502        "   var id = setTimeout(evalLisp, evalLisp(c.cdr.car), c.car);"
Rem     1503        "   return new Number(id);"
Rem     1504        });
Rem     1505        /*
Rem     1506        deFn("js:setTimeoutLisp", function(c) {
Rem     1507        "   var str = lispToStr(c.car);"
Rem     1508        "   gParseCache[str] = c.car;"
Rem     1509        "   var jsStr = ""evalLisp(gParseCache[\"""" + str.replace(/""/g, ""\\\"""") + ""\""])"";"
Rem     1510        "   var id = setTimeout(jsStr, evalLisp(c.cdr.car));"
Rem     1511        "   return new Number(id);"
Rem     1512        });
Rem     1513        */
Rem     1514
Rem     1515
Rem     1516        // Some reflection stuff similar to the 'java' and 'public' functions in ErsatzLisp
Rem     1517
Rem     1518        function applyConstructor(ctor, args) {
Rem     1519        "   switch (args.length) {"
Rem     1520        "       case 0: return new ctor();"
Rem     1521        "       case 1: return new ctor(args[0]);"
Rem     1522        "       case 2: return new ctor(args[0], args[1]);"
Rem     1523        "       case 3: return new ctor(args[0], args[1], args[2]);"
Rem     1524        "       // add more cases if you like"
Rem     1525        "   }"
Rem     1526        "   var jsStr = ""new ctor(args[0]"";"
Rem     1527        "   for (var i=1; i<args.length; i++) jsStr += "",args["" + i + ""]"";"
Rem     1528        "   jsStr += "")"";"
Rem     1529        "   return eval(jsStr);"
Rem     1530        }
Rem     1531
Rem     1532        // First a couple of conversion functions ...
Rem     1533        function lispToNativeData(vl) {
Rem     1534        "   if (vl instanceof Number) return vl.valueOf();  // primitive value required some places"
Rem     1535        "   if (vl instanceof Symbol) {"
Rem     1536        "       if (vl.obj !== undefined) return vl.obj;"
Rem     1537        "       return vl.toValueString();"
Rem     1538        "   }"
Rem     1539        "   if ((vl === NIL) || (vl === T)) return vl.bool;"
Rem     1540        "   return undefined;"
Rem     1541        }
Rem     1542
Rem     1543        function nativeToLispData(vn) {
Rem     1544        "   if ((typeof vn == ""number"") || (vn instanceof Number)) return new Number(vn);"
Rem     1545        "   if (vn instanceof String) vn = vn.valueOf();"
Rem     1546        "   if (typeof vn == ""string"") return (vn == """") ? NIL : newTransSymbol(vn);"
Rem     1547        "   if (vn instanceof Boolean) vn = vn.valueOf();"
Rem     1548        "   if ((vn === false) || (vn === null)) return NIL;"
Rem     1549        "   if (vn === true) return T;"
Rem     1550        "   return boxNativeObject(vn);"
Rem     1551        }
Rem     1552
Rem     1553        function lispParamsToArray(c) {
Rem     1554        "   var arr = [];"
Rem     1555        "   while (c !== NIL) {"
Rem     1556        "       arr.push(lispToNativeData(evalLisp(c.car))); c = c.cdr;"
Rem     1557        "   }"
Rem     1558        "   return arr;"
Rem     1559        }
Rem     1560
Rem     1561        // (js:eval "2+3")
Rem     1562        deFn("js:eval", function(c) { return nativeToLispData(eval(valueToStr(evalLisp(c.car)))); });
Rem     1563
Rem     1564        // (setq *MyArr (js:obj "Array" T)) (js:put *MyArr "2" "X") (list (js:get *MyArr 2) (js:get *MyArr "length"))
Rem     1565        // (js:obj (js:obj "Date" T) "getMinutes")
Rem     1566        // (js:obj (js:obj "Date" T 2010 10 20 15 15) "toString")
Rem     1567        // (let D (js:obj "Date" T) (js:obj D "setHours" 16 30) (js:obj D "toString"))
Rem     1568        deFn("js:obj", function(c) {
Rem     1569        "   var obj = evalLisp(c.car), msg = evalLisp(c.cdr.car);"
Rem     1570        "   if (msg === T) {"
Rem     1571        "       if (obj instanceof Symbol) {"
Rem     1572        "           var ctor = eval(obj.valueOf());"
Rem     1573        "           //if (typeof ctor != ""function"") throw new Error(newErrMsg(JS_CTORNAME_EXP, obj.valueOf()));"
Rem     1574        "           // typeof Date == ""function"", but typeof Image == ""object"" !"
Rem     1575        "           return nativeToLispData(applyConstructor(ctor, lispParamsToArray(c.cdr.cdr)));"
Rem     1576        "       }"
Rem     1577        "       throw new Error(newErrMsg(SYM_EXP, obj));"
Rem     1578        "   }"
Rem     1579        "   if ((obj instanceof Symbol) && (obj.obj instanceof Object)) {"
Rem     1580        "       var fn = obj.obj[lispToNativeData(msg)];"
Rem     1581        "       return nativeToLispData(fn.apply(obj.obj, lispParamsToArray(c.cdr.cdr)));"
Rem     1582        "   }"
Rem     1583        "   throw new Error(newErrMsg(BOXNAT_EXP, obj));"
Rem     1584        });
Rem     1585
Rem     1586        function jsGetPutAlg(c, put) {
Rem     1587        "   var obj = evalLisp(c.car), k;"
Rem     1588        "   if ((obj instanceof Symbol) && (obj.obj !== undefined)) {"
Rem     1589        "       obj = obj.obj; c = c.cdr;"
Rem     1590        "       do {"
Rem     1591        "           k = lispToNativeData(evalLisp(c.car));"
Rem     1592        "           c = c.cdr;"
Rem     1593        "           if (put && ! (c.cdr instanceof Cell)) {"
Rem     1594        "               var vl = evalLisp(c.car), vn = lispToNativeData(vl);"
Rem     1595        "               obj[k] = vn;    // handles both maps/keys and arrays/indices"
Rem     1596        "               return vl;"
Rem     1597        "           }"
Rem     1598        "           obj = obj[k];   // handles both maps/keys and arrays/indices"
Rem     1599        "       } while (c instanceof Cell);"
Rem     1600        "       return nativeToLispData(obj);"
Rem     1601        "   }"
Rem     1602        "   throw new Error(newErrMsg(BOXNAT_EXP, obj));"
Rem     1603        }
Rem     1604
Rem     1605        // (js:get js:Doc "body" "nodeName")
Rem     1606        deFn("js:get", function(c) { return jsGetPutAlg(c, false); });
Rem     1607
Rem     1608        // (js:put js:Doc "body" "contentEditable" "true")
Rem     1609        deFn("js:put", function(c) { return jsGetPutAlg(c, true); });
Rem     1610
Rem     1611
Rem     1612
Rem     1613        </script>
Rem     1614
Rem     1615        "   <script type=""text/javascript"">"
Rem     1616        var dcons, consLog, newcode;
Rem     1617        var initialLogScrollWidth = null;
Rem     1618        var currentPrintRec = null;
Rem     1619        var prevNewcode = "";
Rem     1620        "var savedNewcodes = [];    // maybe"
Rem     1621
Rem     1622        var consPrefs = {
Rem     1623        "   codeGuidesEnabled: true,"
Rem     1624        "   evaluateOnReturn: true,"
Rem     1625        "   newcodeClearAfterEvaluation: false,"
Rem     1626        "   newcodeFocusAfterEvaluation: true,"
Rem     1627        "   closeWindowWarningEnabled: false"
Rem     1628        };
Rem     1629
Rem     1630        function copyOldToNewcode(evt) {
Rem     1631        "   savedNewcodes.push(newcode.value);"
Rem     1632        "   newcode.focus();"
Rem     1633        "   if (evt.shiftKey) {"
Rem     1634        "       newcode.value += "" "" + this.firstChild.nodeValue; // append"
Rem     1635        "   } else {"
Rem     1636        "       newcode.value = this.firstChild.nodeValue;          // replace"
Rem     1637        "   }"
Rem     1638        "   prevNewcode = """";"
Rem     1639        "   updateCodeGuides();"
Rem     1640        }
Rem     1641
Rem     1642        function appendToHistory(styleclass, text) {
Rem     1643        "   currentPrintRec = null;"
Rem     1644        "   var pre = document.createElement(""pre"");"
Rem     1645        "   pre.setAttribute(""class"", styleclass);"
Rem     1646        "   var textNode = document.createTextNode(text);"
Rem     1647        "   pre.appendChild(textNode);"
Rem     1648        "   if (styleclass == ""oldcode"") pre.onclick = copyOldToNewcode;"
Rem     1649        "   consLog.appendChild(pre);"
Rem     1650        "   consLog.scrollTop = consLog.scrollHeight;"
Rem     1651        "   if (consLog.scrollWidth > initialLogScrollWidth) {"
Rem     1652        "       pre.style.width = """" + (consLog.scrollWidth - 8) + ""px"";"
Rem     1653        "   }"
Rem     1654        "   return {elem: pre, node: textNode};"
Rem     1655        }
Rem     1656
Rem     1657        function stdPrint(text) {
Rem     1658        "   if (currentPrintRec == null) {"
Rem     1659        "       currentPrintRec = appendToHistory(""print"", text);"
Rem     1660        "   } else {"
Rem     1661        "       currentPrintRec.node.nodeValue += text;"
Rem     1662        "   }"
Rem     1663        "   var len = text.length;"
Rem     1664        "   if (len > 0) {"
Rem     1665        "       currentPrintRec.elem.setAttribute(""class"","
Rem     1666        "           (text.charAt(len - 1) === ""\n"") ? ""println"" : ""print"");"
Rem     1667        "   }"
Rem     1668        }
Rem     1669
Rem     1670        function warn(msg) {
Rem     1671        "   appendToHistory(""warning"", msg);"
Rem     1672        }
Rem     1673
Rem     1674        function drawLisp(ctx, c) {
Rem     1675        "   var  segx = 16, dy = 16, c0 = c, h = 0;"
Rem     1676        "   if (c instanceof Cell) {"
Rem     1677        "       while (c instanceof Cell) {"
Rem     1678        "           ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(segx, 0); ctx.stroke();"
Rem     1679        "           ctx.save();"
Rem     1680        "           ctx.translate(segx, 0);"
Rem     1681        "           var cy = drawLisp(ctx, c.car);"
Rem     1682        "           h += cy;"
Rem     1683        "           ctx.restore();"
Rem     1684        "           c = c.cdr;"
Rem     1685        "           if (c !== NIL) {"
Rem     1686        "               ctx.translate(0, cy);"
Rem     1687        "               ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -h); ctx.stroke();"
Rem     1688        "               if (c === c0) {"
Rem     1689        "                   // Indicating circular list ..."
Rem     1690        "                   var up = -dy/4;"
Rem     1691        "                   ctx.beginPath(); ctx.moveTo(0, up*2); ctx.lineTo(segx/2, up*2); ctx.stroke();"
Rem     1692        "                   ctx.beginPath(); ctx.moveTo(0, up); ctx.lineTo(segx/2, up); ctx.stroke();"
Rem     1693        "                   h += dy;"
Rem     1694        "                   break;"
Rem     1695        "               }"
Rem     1696        "           }"
Rem     1697        "       }"
Rem     1698        "       if ((c !== NIL) && (c !== c0)) {"
Rem     1699        "           ctx.fillText(lispToStr(c), -3, 12);"
Rem     1700        "           h += dy * 1.7;"
Rem     1701        "       }"
Rem     1702        "   } else {"
Rem     1703        "       ctx.fillText(lispToStr(c), 4, 3);"
Rem     1704        "       h = dy;"
Rem     1705        "   }"
Rem     1706        "   return h;"
Rem     1707        }
Rem     1708
Rem     1709        function hideMonitorIfCanvasNotSupported() {
Rem     1710        "   var cv = document.getElementById(""monView"");"
Rem     1711        "   if (cv && cv.getContext) return;"
Rem     1712        "   var mon = document.getElementById(""monitor"");"
Rem     1713        "   mon.style.display = ""none"";"
Rem     1714        }
Rem     1715
Rem     1716        function clearMonitorView() {
Rem     1717        "   var cv = document.getElementById(""monView"");"
Rem     1718        "   if (cv && cv.getContext) {"
Rem     1719        "       cv.width = cv.width;        // resetting the canvas"
Rem     1720        "       cv.getContext(""2d"").clearRect(0, 0, cv.width, cv.height);"
Rem     1721        "   }"
Rem     1722        }
Rem     1723
Rem     1724        function updateMonitorView(lispValue) {
Rem     1725        "   var cv = document.getElementById(""monView"");"
Rem     1726        "   if (cv && cv.getContext) {"
Rem     1727        "       var ctx = cv.getContext(""2d"");"
Rem     1728        "       if (lispValue != null) {"
Rem     1729        "           ctx.save();"
Rem     1730        "           ctx.strokeStyle = ""#933"";"
Rem     1731        "           ctx.lineWidth = 1;"
Rem     1732        "           ctx.fillStyle = ""#000"";"
Rem     1733        "           ctx.font = ""12px Arial, sans-serif"";"
Rem     1734        "           ctx.translate(16.5, 16.5);"
Rem     1735        "           drawLisp(ctx, lispValue);"
Rem     1736        "           ctx.restore();"
Rem     1737        "       }"
Rem     1738        "   }"
Rem     1739        }
Rem     1740
Rem     1741        function getValueToMonitor() {
Rem     1742        "   try {"
Rem     1743        "       var mScr = document.getElementById(""monitorobject"").value;"
Rem     1744        "       if ((mScr != null) && mScr.match(/\S/)) return prog(cachedTextParse(mScr));"
Rem     1745        "   } catch (e) { alert(""getValueToMonitor: "" + e); }"
Rem     1746        "   return null;"
Rem     1747        }
Rem     1748
Rem     1749        var dbg_e;
Rem     1750        function evalExpr() {
Rem     1751        "   if (document.getElementById(""clearMonView"").checked) clearMonitorView();"
Rem     1752        "   appendToHistory(""oldcode"", newcode.value);"
Rem     1753        "   try {"
Rem     1754        "       var result = prog(parseList(new Source(newcode.value)));"
Rem     1755        "       A3.setVal(A2.getVal()); A2.setVal(A1.getVal()); A1.setVal(result);"
Rem     1756        "       appendToHistory(""result"", lispToStr(result));"
Rem     1757        "   } catch (e) {dbg_e = e;"
Rem     1758        "       if (e.lineNumber === undefined) appendToHistory(""error"", e.message)"
Rem     1759        "       else appendToHistory(""error"", e.message + ""\nLine "" + e.lineNumber);"
Rem     1760        "   }"
Rem     1761        "   if (consPrefs.newcodeClearAfterEvaluation) newcode.value = """";"
Rem     1762        "   if (consPrefs.newcodeFocusAfterEvaluation) newcode.focus();"
Rem     1763        "   updateMonitorView(getValueToMonitor());"
Rem     1764        }
Rem     1765
Rem     1766        function refreshMonitor() {
Rem     1767        "   clearMonitorView();"
Rem     1768        "   updateMonitorView(getValueToMonitor());"
Rem     1769        }
Rem     1770
Rem     1771        var numFilesToLoad;
Rem     1772
Rem     1773        function handleFileDrop(evt) {
Rem     1774        "   evt.preventDefault();"
Rem     1775        "   if (typeof window.FileReader === ""function"") {"
Rem     1776        "       var srcFiles = [];"
Rem     1777        "       for (var i=0; i<evt.dataTransfer.files.length; i++) {"
Rem     1778        "           var f = evt.dataTransfer.files[i];"
Rem     1779        "           if (f.name.match(/\.l$/) || f.name.match(/\.js$/)) {"
Rem     1780        "               srcFiles.push(f);"
Rem     1781        "           } else {"
Rem     1782        "               warn(f.name + "" is probably not a Lisp or JavaScript file"");"
Rem     1783        "           }"
Rem     1784        "       }"
Rem     1785        "       numFilesToLoad = srcFiles.length;"
Rem     1786        "       for (var i=0; i<srcFiles.length; i++) {"
Rem     1787        "           var reader = new FileReader();"
Rem     1788        "           reader.srcFile = srcFiles[i];"
Rem     1789        "           reader.onload = function(rEvt) {"
Rem     1790        "               try {"
Rem     1791        "                   var fileName = rEvt.target.srcFile.name, dropResult = ""(unknown result)"";"
Rem     1792        "                   appendToHistory(""filedrop"", ""loading: "" + fileName);"
Rem     1793        "                   if (fileName.match(/\.l$/)) {"
Rem     1794        "                       // Lisp file"
Rem     1795        "                       dropResult = lispToStr(prog(parseList(new Source(rEvt.target.result), true)));"
Rem     1796        "                   } else if (fileName.match(/\.js$/)) {"
Rem     1797        "                       // JavaScript file"
Rem     1798        "                       dropResult = eval(rEvt.target.result).toString();"
Rem     1799        "                   } else {"
Rem     1800        "                       dropResult = ""Why did this happen?"";  // very unlikely"
Rem     1801        "                   }"
Rem     1802        "                   if (--numFilesToLoad == 0) appendToHistory(""result"", dropResult);"
Rem     1803        "               } catch (e) {"
Rem     1804        "                   if (e.lineNumber === undefined) appendToHistory(""error"", e.message)"
Rem     1805        "                   else appendToHistory(""error"", e.message + ""\nLine "" + e.lineNumber);"
Rem     1806        "               }"
Rem     1807        "           }"
Rem     1808        "           reader.readAsText(srcFiles[i]);"
Rem     1809        "       }"
Rem     1810        "   } else {"
Rem     1811        "       warn(""File Drop not supported by this browser"");"
Rem     1812        "   }"
Rem     1813        "   return false;"
Rem     1814        }
Rem     1815
Rem     1816        function newcodeCheck(srcObj) {
Rem     1817        "   var newMod = srcObj.src;"
Rem     1818        "   if (newMod.match(/^[\.\s]*\)/)) throw new Error(BAD_INPUT);"
Rem     1819        "   // Replacing ""()"" with ""NIL"" ..."
Rem     1820        "   newMod = newMod.replace(/\(\s*\)/g, "" NIL "");"
Rem     1821        "   // Removing dots and spaces before "")"", removing trailing dots and spaces ..."
Rem     1822        "   newMod = newMod.replace(/[\.\s]*\)/g, "")"").replace(/[\.\s]*$/, """");"
Rem     1823        "   //alert(""newcodeCheck: "" + srcObj.src + "", "" + newMod);"
Rem     1824        "   var newParMatch = newMod.match(/\)*$/);"
Rem     1825        "   var newParCount = newParMatch ? newParMatch[0].length : 0;"
Rem     1826        "   var tmpLisp = parseList(srcObj, false, true);"
Rem     1827        "   if (false) {"
Rem     1828        "       getSymbol(""*Newcode"").setVal(tmpLisp);"
Rem     1829        "       refreshMonitor();"
Rem     1830        "   }"
Rem     1831        "   var parseResult = lispToStr(tmpLisp);"
Rem     1832        "   var parseParMatch = parseResult.match(/\)*$/);"
Rem     1833        "   var parseParCount = parseParMatch ? parseParMatch[0].length : 0;"
Rem     1834        "   var parBalance = newParCount - parseParCount + ((newMod == """") || newMod.match(/\($/) ? 0 : 1);"
Rem     1835        "   //stdPrint(newMod + "" -> "" + parseResult + "", "" + newParCount + "", "" + parseParCount + ""\n"");"
Rem     1836        "   return parBalance;"
Rem     1837        }
Rem     1838
Rem     1839        function openDocWindow(evt) {
Rem     1840        "   var docUrl = ""http://software-lab.de/doc/"";"
Rem     1841        "   window.open(docUrl + symbolRefUrl(this.symbol.name), ""refdoc"","
Rem     1842        "       ""fullscreen=no, toolbar=no, status=no, menubar=no, resizable=yes, scrollbars=yes, "" +"
Rem     1843        "       ""directories=no, location=no, width=980, height=600"");"
Rem     1844        }
Rem     1845
Rem     1846        function printSymbolValue(evt) {
Rem     1847        "   stdPrint(lispToStr(this.symbol.getVal()) + ""\n"");"
Rem     1848        "   newcode.focus();"
Rem     1849        }
Rem     1850
Rem     1851        function updateCodeGuides() {
Rem     1852        "   if (! consPrefs.codeGuidesEnabled) return;"
Rem     1853        "   var srcObj = new Source(newcode.value).withTrace();"
Rem     1854        "   var parGuide = document.getElementById(""parGuide"").firstChild;"
Rem     1855        "   try {"
Rem     1856        "       var parHint = """";"
Rem     1857        "       var parBalance = newcodeCheck(srcObj);  // will call parseList(srcObj, ...)"
Rem     1858        "       if (parBalance == 0) {"
Rem     1859        "           parHint = ""?"";"
Rem     1860        "       } else if (parBalance < 0) {"
Rem     1861        "           for (var i=0; i>parBalance; i--) parHint += ""("";  // one or more )'s needed"
Rem     1862        "       } else {"
Rem     1863        "           for (var i=0; i<parBalance; i++) parHint += "")"";  // probably too many )'s"
Rem     1864        "       }"
Rem     1865        "       parGuide.nodeValue = parHint;"
Rem     1866        "   } catch (e) { parGuide.nodeValue = e.toString(); }"
Rem     1867        "   "
Rem     1868        "   var symGuide = document.getElementById(""symGuide""), symText = symGuide.firstChild;"
Rem     1869        "   try {"
Rem     1870        "       if (newcode.value != prevNewcode) {"
Rem     1871        "           symGuide.onclick = function() { newcode.focus(); };"
Rem     1872        "           symGuide.className = ""nosymbol"";"
Rem     1873        "           symGuide.title = null;"
Rem     1874        "           var sName = ""?"";"
Rem     1875        "           for (var ni=newcode.value.length-1, pi=prevNewcode.length-1; ni >= 0; ni-- & pi--) {"
Rem     1876        "               if ((pi < 0) || (newcode.value[ni] != prevNewcode[pi])) {"
Rem     1877        "                   var itemInd = srcObj.getSymbolBeforePos(ni + 1);"
Rem     1878        "                   if (itemInd != null) {"
Rem     1879        "                       sName = itemInd.item.name;"
Rem     1880        "                       symGuide.symbol = itemInd.item;"
Rem     1881        "                       if (typeof itemInd.item.cdr === ""function"") {"
Rem     1882        "                           if (sName.match(/\w+\:\w+/)) {"
Rem     1883        "                               symGuide.title = ""No ref. yet for this function"";"
Rem     1884        "                           } else {"
Rem     1885        "                               symGuide.onclick = openDocWindow;"
Rem     1886        "                               symGuide.className = ""builtin"";"
Rem     1887        "                               symGuide.title = ""Open ref. in new window"";"
Rem     1888        "                           }"
Rem     1889        "                       } else {"
Rem     1890        "                           symGuide.onclick = printSymbolValue;"
Rem     1891        "                           symGuide.className = ""othersymbol"";"
Rem     1892        "                           symGuide.title = ""Print symbol value"";"
Rem     1893        "                       }"
Rem     1894        "                   }"
Rem     1895        "                   break;"
Rem     1896        "               }"
Rem     1897        "           }"
Rem     1898        "           symText.nodeValue = sName;"
Rem     1899        "           prevNewcode = newcode.value;"
Rem     1900        "       }"
Rem     1901        "   } catch (e) { symText.nodeValue = e.message + "", "" + e.lineNumber; }"
Rem     1902        }
Rem     1903
Rem     1904        function newcodeKeyup(evt) {
Rem     1905        "   updateCodeGuides();"
Rem     1906        "   return true;"
Rem     1907        }
Rem     1908
Rem     1909        function newcodeKeypress(evt) {
Rem     1910        "   evt = evt ? evt : window.event;"
Rem     1911        "   if (consPrefs.evaluateOnReturn && (evt.keyCode == 13) && ! evt.shiftKey) {"
Rem     1912        "       evt.preventDefault();"
Rem     1913        "       evalExpr();"
Rem     1914        "       return false;"
Rem     1915        "   }"
Rem     1916        "   return true;"
Rem     1917        }
Rem     1918
Rem     1919        function prefCheckboxClick(evt) {
Rem     1920        "   consPrefs[this.id] = this.checked;"
Rem     1921        "   if (this.id == ""closeWindowWarningEnabled"") {"
Rem     1922        "       window.onbeforeunload = consPrefs.closeWindowWarningEnabled ? closeWindowMsg : null;"
Rem     1923        "   }"
Rem     1924        }
Rem     1925
Rem     1926        function prefInputChange(evt) {
Rem     1927        "   eval(this.id.replace(/\-/g, ""."") + ""='"" + this.value + ""'"");"
Rem     1928        }
Rem     1929
Rem     1930        function showHidePrefs(visibleOrHidden) {
Rem     1931        "   try {"
Rem     1932        "       if (visibleOrHidden == ""visible"") {"
Rem     1933        "           var checkboxArr = document.querySelectorAll(""div#prefs input[type='checkbox']"");"
Rem     1934        "           for (var i=0; i<checkboxArr.length; i++) {"
Rem     1935        "               var cb = checkboxArr[i];"
Rem     1936        "               cb.checked = consPrefs[cb.id];"
Rem     1937        "               cb.onclick = prefCheckboxClick;"
Rem     1938        "           }"
Rem     1939        "           var inputArr = document.querySelectorAll(""div#prefs input[type='text']"");"
Rem     1940        "           for (var i=0; i<inputArr.length; i++) {"
Rem     1941        "               var inElem = inputArr[i];"
Rem     1942        "               inElem.value = eval(inElem.id.replace(/\-/g, "".""));"
Rem     1943        "               inElem.onchange = prefInputChange;"
Rem     1944        "           }"
Rem     1945        "       } else if (consPrefs.newcodeFocusAfterEvaluation) {"
Rem     1946        "           newcode.focus();"
Rem     1947        "       }"
Rem     1948        "       document.getElementById(""prefs"").style.visibility = visibleOrHidden;"
Rem     1949        "   } catch (e) { alert(""showHidePrefs: "" + e); }"
Rem     1950        }
Rem     1951
Rem     1952        function openMainWindow() {
Rem     1953        "   window.open(""http://folk.uio.no/jkleiser/pico/emuLisp/index.html"", ""EmuLispMain"", ""resizable=yes, scrollbars=yes, location=yes"");"
Rem     1954        }
Rem     1955
Rem     1956        function closeWindowMsg(evt) {
Rem     1957        "   evt = evt ? evt : window.event;"
Rem     1958        "   var msg = ""Leaving this page will do away with your current EmuLisp data."";"
Rem     1959        "   evt.returnValue = msg;"
Rem     1960        "   return msg;"
Rem     1961        }
Rem     1962
Rem     1963        function init() {
Rem     1964        "   var small = (screen.height < 400);"
Rem     1965        "   window.name = ""EmuLispConsole"";"
Rem     1966        "   dcons = document.getElementById(""dcons"");"
Rem     1967        "   dcons.ondragover = function() { return false; }"
Rem     1968        "   dcons.ondragend = function() { return false; }"
Rem     1969        "   dcons.ondrop = handleFileDrop;"
Rem     1970        "   dcons.style.fontSize = ""15px"";"
Rem     1971        "   dcons.style.fontFamily = ""monospace"";"
Rem     1972        "   consLog = document.getElementById(""log"");"
Rem     1973        "   consLog.style.height = small ? ""200px"" : ""400px"";"
Rem     1974        "   newcode = document.getElementById(""newcode"");"
Rem     1975        "   newcode.focus();"
Rem     1976        "   if (typeof newcode.addEventListener == ""function"") {"
Rem     1977        "       newcode.addEventListener(""keypress"", newcodeKeypress, false);"
Rem     1978        "       newcode.addEventListener(""keyup"", newcodeKeyup, false);"
Rem     1979        "   }"
Rem     1980        "   initialLogScrollWidth = document.getElementById(""log"").scrollWidth;"
Rem     1981        "   updateCodeGuides();"
Rem     1982        "   hideMonitorIfCanvasNotSupported();"
Rem     1983        "   if (consPrefs.closeWindowWarningEnabled) window.onbeforeunload = closeWindowMsg;"
Rem     1984        }
Rem     1985        "   </script>"
Rem     1986        </head>
Rem     1987        <body onload="init();">
Rem     1988        <div id="head">
Rem     1989        "   <span id=""presentation""><em>EmuLisp</em> - emulating a tiny subset of PicoLisp</span>"
Rem     1990        "   <img id=""infosymbol"" src=""images/info.png"""
Rem     1991        "       title=""Open Main Page in sep. window/tab"" alt=""info"" onclick=""openMainWindow();"">"
Rem     1992        "   <input type=""button"" value=""Prefs"" onclick=""showHidePrefs('visible');"" />"
Rem     1993        </div>
Rem     1994        <div id="main">
Rem     1995        "   <div id=""dcons"">"
Rem     1996        "       <div id=""log""></div>"
Rem     1997        "       <textarea id=""newcode"" rows=""6""></textarea>"
Rem     1998        "       <span id=""version"">EmuLisp Console 28-Mar-2011</span>"
Rem     1999        "       <span id=""controls"">"
Rem     2000        "           <span id=""symGuide"">?</span>"
Rem     2001        "           <span id=""parGuide"">?</span>"
Rem     2002        "           <input type=""button"" value=""Evaluate"" onclick=""evalExpr();"" />"
Rem     2003        "       </span>"
Rem     2004        "   </div>"
Rem     2005        "   <div id=""monitor"">"
Rem     2006        "       Expression to monitor: <input id=""monitorobject"" type=""text"" value=""@"" /><br />"
Rem     2007        "       <canvas id=""monView"" width=""478"" height=""478"""
Rem     2008        "           onclick=""refreshMonitor();"" title=""Click to refresh monitor"">"
Rem     2009        "           Monitoring requires canvas support."
Rem     2010        "       </canvas><br />"
Rem     2011        "       <span style=""float: right"">"
Rem     2012        "           <input id=""clearMonView"" type=""checkbox"" checked />"
Rem     2013        "           <label for=""clearMonView"">Clear monitor view before evaluation</label>"
Rem     2014        "       </span>"
Rem     2015        "   </div>"
Rem     2016        </div>
Rem     2017        <div id="prefs">
Rem     2018        "   <p class=""paneHead""><span class=""closebox"" onclick=""showHidePrefs('hidden');"">X</span></p>"
Rem     2019        "   <p class=""pref""><input id=""codeGuidesEnabled"" type=""checkbox"" />"
Rem     2020        "       <label for=""codeGuidesEnabled"">Enable Code Guides</label></p>"
Rem     2021        "   <p class=""pref""><input id=""evaluateOnReturn"" type=""checkbox"" />"
Rem     2022        "       <label for=""evaluateOnReturn"">Evaluate on Return</label></p>"
Rem     2023        "   <p class=""pref""><input id=""newcodeClearAfterEvaluation"" type=""checkbox"" />"
Rem     2024        "       <label for=""newcodeClearAfterEvaluation"">Clear Input after Evaluation</label></p>"
Rem     2025        "   <p class=""pref""><input id=""newcodeFocusAfterEvaluation"" type=""checkbox"" />"
Rem     2026        "       <label for=""newcodeFocusAfterEvaluation"">Focus Input after Evaluation</label></p>"
Rem     2027        "   <p class=""pref""><input id=""closeWindowWarningEnabled"" type=""checkbox"" />"
Rem     2028        "       <label for=""closeWindowWarningEnabled"">Warning when Closing Window</label></p>"
Rem     2029        "   <p class=""pref""><label for=""dcons-style-fontSize"">Console Font Size:</label>"
Rem     2030        "       <input id=""dcons-style-fontSize"" type=""text"" size=""5"" /></p>"
Rem     2031        "   <p class=""pref""><label for=""dcons-style-fontFamily"">Console Font Family:</label>"
Rem     2032        "       <input id=""dcons-style-fontFamily"" type=""text"" size=""10"" /></p>"
Rem     2033        "   <p class=""pref""><label for=""consLog-style-height"">Height of Log:</label>"
Rem     2034        "       <input id=""consLog-style-height"" type=""text"" size=""5"" /></p>"
Rem     2035        </div>
Rem     2036        </body>
Rem     2037        </html>

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'Option Explicit ARY_M

                            

Public Function ARY_M_dimensioncount(inarr)
                                        

Dim dimension As Long
Dim i As Long
On Error GoTo catch
i = 1
While i < 2 ^ 30
    dimension = UBound(inarr, i)
    If UBound(inarr, i + 1) Then i = i + 1
Wend

catch:
On Error Resume Next
ARY_M_dimensioncount = i

End Function

Public Function ARY_M_getSize(inarr) As Collection
Dim dimension As Long
Dim i As Long

Set getSize = New Collection

On Error GoTo catch

i = 1
While i < 2 ^ 30
    dimension = UBound(inarr, i)
    getSize.Add LBound(inarr, i)
    getSize.Add UBound(inarr, i)
    If UBound(inarr, i + 1) Then i = i + 1
Wend

catch:
On Error Resume Next

End Function
'squeezes a 2D record, with one row, into a 1D record
Public Function ARY_M_flatRecord(inarr() As Variant) As Variant()
Dim tmp()
Dim i
ReDim tmp(LBound(inarr, 2) To UBound(inarr, 2))
For i = LBound(tmp, 1) To UBound(tmp, 1)
    tmp(i) = inarr(1, i)
Next i

ARY_M_flatRecord = tmp
End Function

Public Function ARY_M_strArray(ParamArray args()) As String()
Dim tmp() As String
Dim i As Long
ReDim tmp(1 To UBound(args, 1) + 1)
For i = 1 To UBound(tmp, 1)
    tmp(i) = CStr(args(i - 1))
Next i
ARY_M_strArray = tmp
End Function

Sub ARY_M_tst()
Dim sarr() As String
Dim sngArr() As Single
Dim lngarr() As Long
Dim dblarr() As Double

sarr = strArray("A", "B", "C", "D")
lngarr = lngArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
sngArr = sngArray(1, 0.2, 0.03, 0.004)
dblarr = dblArray(2000000, -1, -0.00000004, 0.554)

End Sub
Public Function ARY_M_unpack(invarr() As Variant) As Variant

If IsArray(invarr(LBound(invarr, 1), 1)) Then
    ARY_M_unpack = invarr(LBound(invarr, 1), 1)
Else
    ARY_M_unpack = invarr
End If

End Function

Public Function ARY_M_lngArray(ParamArray args()) As Long()
Dim tmp() As Long
Dim i As Long
ReDim tmp(1 To UBound(args, 1) + 1)
For i = 1 To UBound(tmp, 1)
    tmp(i) = CLng(args(i - 1))
Next i
ARY_M_lngArray = tmp
End Function

Public Function ARY_M_sngArray(ParamArray args()) As Single()
Dim tmp() As Single
Dim i As Long
ReDim tmp(1 To UBound(args, 1) + 1)
For i = 1 To UBound(tmp, 1)
    tmp(i) = CSng(args(i - 1))
Next i
ARY_M_sngArray = tmp
End Function
Public Function ARY_M_dblArray(ParamArray args()) As Double()
Dim tmp() As Double
Dim i As Long
ReDim tmp(1 To UBound(args, 1) + 1)
For i = 1 To UBound(tmp, 1)
    tmp(i) = CDbl(args(i - 1))
Next i
ARY_M_dblArray = tmp
End Function

Public Function ARY_M_tostrArray(invarr() As Variant) As String()
ARY_M_tostrArray = strArray(invarr)

End Function

Public Function ARY_M_lngOfList(inlist As Collection) As Long()
Dim tmp() As Long
Dim i As Long
ReDim tmp(1 To inlist.count)
For i = 1 To inlist.count
    tmp(i) = CLng(inlist(i))
Next i
ARY_M_lngOfList = tmp
End Function
Public Function ARY_M_sngOfList(inlist As Collection) As Single()
Dim tmp() As Single
Dim i As Long
ReDim tmp(1 To inlist.count)
For i = 1 To inlist.count
    tmp(i) = CSng(inlist(i))
Next i
ARY_M_sngOfList = tmp
End Function

Public Function ARY_M_dblOfList(inlist As Collection) As Double()
Dim tmp() As Double
Dim i As Long
ReDim tmp(1 To inlist.count)
For i = 1 To inlist.count
    tmp(i) = CDbl(inlist(i))
Next i
ARY_M_dblOfList = tmp
End Function
Public Function ARY_M_strOfList(inlist As Collection) As String()
Dim tmp() As String
Dim i As Long
ReDim tmp(1 To inlist.count)
For i = 1 To inlist.count
    tmp(i) = CStr(inlist(i))
Next i
ARY_M_strOfList = tmp
End Function

'CDP_C_

'Class that parses VBA code and pretty prints it with html formatting.
'Option Explicit - CDP_C_
Private reserved As Dictionary
Private separable As Dictionary

'CDP_C_
 'Moved Public Enum ParseState def to top of file - get rid of  error msg...

Private Sub CDP_C_Class_Initialize()
Set reserved = New Dictionary
Set separable = New Dictionary

addReserved "AddHandler"
addReserved "AddressOf"
addReserved "Alias"
addReserved "And"
addReserved "AndAlso"
addReserved "As"
addReserved "Boolean"
addReserved "ByRef"
addReserved "Byte"
addReserved "ByVal"
addReserved "Call"
addReserved "Case"
addReserved "catch"
addReserved "CBool"
addReserved "CByte"
addReserved "CChar"
addReserved "CDate"
addReserved "CDec"
addReserved "CDbl"
addReserved "Char"
addReserved "CInt"
addReserved "Class"
addReserved "CLng"
addReserved "CObj"
addReserved "Const"
addReserved "Continue"
addReserved "CSByte"
addReserved "CShort"
addReserved "CSng"
addReserved "CStr"
addReserved "CType"
addReserved "CUInt"
addReserved "CULng"
addReserved "CUShort"
addReserved "Date"
addReserved "Decimal"
addReserved "Declare"
addReserved "default"
addReserved "Delegate"
addReserved "Dim"
addReserved "DirectCast"
addReserved "Do"
addReserved "Double"
addReserved "Each"
addReserved "Else"
addReserved "ElseIf"
addReserved "End"
addReserved "End If"
addReserved "Enum"
addReserved "Erase"
addReserved "Error"
addReserved "Event"
addReserved "Exit"
addReserved "False"
addReserved "Finally"
addReserved "For"
addReserved "Friend"

addReserved "Function"
addSeparable "Function"

addReserved "Get"
addReserved "GetType"
addReserved "Global"
addReserved "GoSub"
addReserved "GoTo"
addReserved "Handles"
addReserved "If"
addReserved "Implements"
addReserved "Imports"
addReserved "In"
addReserved "Inherits"
addReserved "Integer"
addReserved "Interface"
addReserved "Is"
addReserved "IsNot"
addReserved "Let"
addReserved "Lib"
addReserved "Like"
addReserved "Long"
addReserved "Loop"
addReserved "Me"
addReserved "Mod"
addReserved "Module"
addReserved "MustInherit"
addReserved "MustOverride"
addReserved "MyBase"
addReserved "MyClass"
addReserved "Namespace"
addReserved "Narrowing"
addReserved "New"
addReserved "Next"
addReserved "Not"
addReserved "Nothing"
addReserved "NotInheritable"
addReserved "NotOverridable"
addReserved "Object"
addReserved "Of"
addReserved "On"
addReserved "Operator"
addReserved "Option"
addReserved "Optional"
addReserved "Or"
addReserved "OrElse"
addReserved "Overloads"
addReserved "Overridable"
addReserved "Overrides"
addReserved "ParamArray"
addReserved "Partial"
addReserved "Private"

addReserved "Property"
addSeparable "Property"

addReserved "Protected"
addReserved "Public"
addReserved "RaiseEvent"
addReserved "ReadOnly"
addReserved "ReDim"
addReserved "Rem"
addReserved "RemoveHandler"
addReserved "Resume"
addReserved "Return"
addReserved "SByte"
addReserved "Select"
addReserved "Set"
addReserved "Shadows"
addReserved "Shared"
addReserved "Short"
addReserved "Single"
addReserved "Static"
addReserved "Step"
addReserved "Stop"
addReserved "String"
addReserved "Structure"

addReserved "Sub"
addSeparable "Sub"

addReserved "SyncLock"
addReserved "Then"
addReserved "Throw"
addReserved "To"
addReserved "True"
addReserved "Try"
addReserved "TryCast"
addReserved "TypeOf"
addReserved "Variant"
addReserved "Wend"
addReserved "UInteger"
addReserved "ULong"
addReserved "UShort"
addReserved "Using"
addReserved "When"
addReserved "While"
addReserved "Widening"
addReserved "With"
addReserved "WithEvents"
addReserved "WriteOnly"
addReserved "Xor"

End Sub
Public Sub CDP_C_addReserved(res As String)
CDP_C_reserved.Add res, 0
End Sub
Public Sub CDP_C_addSeparable(res As String)
CDP_C_separable.Add res, 0
End Sub
Public Function CDP_C_isRes(wrd As String) As Boolean
CDP_C_isRes = reserved.exists(wrd)
End Function
Public Function CDP_C_isSeperable(wrd As String) As Boolean
CDP_C_isSeperable = separable.exists(wrd)
End Function

'Got a simpler way to do this...
'split will parse a line into an array, delimited by spaces.
'if the entry in the array is "" then it's a space.
'we parse a line by splitting it along spaces.
'For each word in the words, we determine if special formatting is required.
    'remarks are special.
    'keywords are special.
    'anything else is not special.

Private Function CDP_C_parseline(line As String, lnumber As Long) As String
Dim words
Dim i As Long
Dim wrd As String
Dim state As ParseState

state = code

words = Split(line, " ")
CDP_C_parseline = separate(words) & "<pre>"
CDP_C_parseline = parseline & newline(lnumber)

i = LBound(words, 1)
While state <> Comment And i <= UBound(words, 1)
    wrd = CStr(words(i))
    If isRes(wrd) Then
        state = ResWord
    ElseIf iscomment(wrd) Then
        state = Comment
    Else
        state = code
    End If
    
    CDP_C_parseline = CDP_C_parseline & parseword(wrd, state, True)
    i = i + 1
Wend

If i <= UBound(words, 1) Then
    While i <= UBound(words, 1)
        wrd = CStr(words(i))
        CDP_C_parseline = CDP_C_parseline & parseword(wrd, code, False)
        i = i + 1
    Wend
End If

If (state = Comment) Or (state = ResWord) Then parseline = parseline & "</span>"

CDP_C_parseline = parseline & "</pre>"

End Function
Private Function CDP_C_separate(words) As String

If UBound(words, 1) > 1 Then
    If checkseparation(CStr(words(0)), CStr(words(1))) Then
        CDP_C_separate = "<hr />" & vbCrLf
    Else
        CDP_C_separate = ""
    End If
End If

End Function
Private Function CDP_C_checkseparation(word1 As String, word2 As String) As Boolean
If SuborFuncorProp(word1) Then
    CDP_C_checkseparation = True
Else
    If isRes(word1) And isRes(word2) And SuborFuncorProp(word2) Then CDP_C_checkseparation = True
End If

End Function
Private Function CDP_C_SuborFuncorProp(word As String) As Boolean
CDP_C_SuborFuncorProp = (word = "Sub" Or word = "Function" Or word = "Property")
End Function
Private Function CDP_C_iscomment(word As String) As Boolean
CDP_C_iscomment = (InStr(1, word, "'") > 0)
End Function
Private Function CDP_C_newline(number As Long) As String

Dim spaces As String
Dim numstr As String

numstr = CStr(number)
If Len(numstr) > 4 Then
    Err.Raise 101, "too many lines of code"
Else
    spaces = Space(4 - Len(numstr))
    numstr = spaces & numstr
    CDP_C_newline = "<span class=""lnum"">" & numstr & ":  </span>"
End If

End Function
Private Function CDP_C_parseword(word As String, state As ParseState, Optional newcomment As Boolean) As String

Select Case state
    Case Is = ParseState.code
        CDP_C_parseword = " " & word
    Case Is = ParseState.ResWord
        CDP_C_parseword = reservedword(word)
    Case Is = ParseState.Comment
        If newcomment Then
            CDP_C_parseword = startcomment(word)
        Else
            CDP_C_parseword = " " & word
        End If
End Select
        
End Function
Private Function CDP_C_reservedword(word As String) As String
CDP_C_reservedword = "<span class=""kwrd"">" & " " & word & "</span>"
End Function
Private Function CDP_C_startcomment(Optional word As String) As String
CDP_C_startcomment = "<span class=""rem"">" & word
End Function
Private Function CDP_C_closeSpan() As String
CDP_C_closeSpan = "</span>"
End Function
'returns the parsed html of the pretty-printed code.  TimeStamped!
Public Function CDP_C_parsemodule(module As VBComponent, Optional path As String) As String
Dim lines As String
With module
    If .CodeModule.CountOfLines > 0 Then
        lines = CStr(Now()) & vbCrLf & .CodeModule.lines(1, .CodeModule.CountOfLines)
    Else
        lines = ""
    End If
End With

CDP_C_parsemodule = parsecode(lines)

End Function
'returns the parsed html of the pretty-printed code.
Public Function CDP_C_parsecode(code As String, Optional path As String) As String
Dim lines
Dim i As Long
Dim line As String

parsecode = startParse
lines = Split(code, vbCrLf)
For i = LBound(lines, 1) To UBound(lines, 1)
    line = CStr(lines(i))
    parsecode = parsecode & vbCrLf
    parsecode = parsecode & parseline(line, i)
Next i

CDP_C_parsecode = closeParse(parsecode)

End Function
Private Function CDP_C_startParse() As String
CDP_C_startParse = csshead & vbCrLf & "<div class=""csharpcode"">"
End Function
Private Function CDP_C_closeParse(parsed As String) As String
CDP_C_closeParse = parsed & vbCrLf & "</div>"
End Function
Private Function CDP_C_csshead() As String
csshead = "<head>" & vbCrLf _
        & "<style type=""text/css"">" & vbCrLf _
       & ".csharpcode, .csharpcode pre" & vbCrLf _
       & "{" & vbCrLf _
           & "font-size: small;" & vbCrLf _
           & "color: black;" & vbCrLf _
           & "font-family: Consolas, ""Courier New"", Courier, Monospace;" & vbCrLf _
           & "background-color: #ffffff;" & vbCrLf _
           & "/*white-space: pre;*/" & vbCrLf _
       & "}" & vbCrLf _
       & ".csharpcode pre { margin: 0em; }" & vbCrLf _
       & ".csharpcode .rem { color: #008000; }" & vbCrLf _
       & ".csharpcode .kwrd { color: #0000ff; }" & vbCrLf _
       & ".csharpcode .str { color: #006080; }" & vbCrLf _
       & ".csharpcode .op { color: #0000c0; }" & vbCrLf _
       & ".csharpcode .preproc { color: #cc6633; }" & vbCrLf _
       & ".csharpcode .asp { background-color: #ffff00; }" & vbCrLf _
       & ".csharpcode .html { color: #800000; }" & vbCrLf _
       & ".csharpcode .attr { color: #ff0000; }" & vbCrLf _
       & ".csharpcode .alt" & vbCrLf _
       & "{" & vbCrLf _
           & "background-color: #f4f4f4;" & vbCrLf _
           & "width: 100%;" & vbCrLf _
           & "margin: 0em;" & vbCrLf
           
csshead = csshead _
       & "}" & vbCrLf _
       & ".csharpcode .lnum { color: #606060; }" & vbCrLf _
       & "</style>" & vbCrLf _
       & "</head>"
        

End Function

 




'CDP_M_


'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'Utilities for printing code modules in nicely formatted html.
Public Type CodeCount
    LOComments As Long
    LOCode As Long
End Type

'Option Explicit
Public Sub CDP_M_ripmar()
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Dim vbp As VBProject
Set vbp = ActiveWorkbook.VBProject

For Each vbcomp In ActiveWorkbook.VBProject.VBComponents
    If InStr(1, vbcomp.name, "Tree") > 0 Then vbp.VBComponents.Remove vbcomp
Next vbcomp

        
End Sub

Public Sub CDP_M_parsetest()
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Dim parser As CodePrinter
Dim testcode As String
Dim htmls As Dictionary
Dim HTML As String
Dim path As String

path = ActiveWorkbook.path & "\html\"

Set htmls = New Dictionary
Set parser = New CodePrinter

With New FileSystemObject
    If Not .FolderExists(path) Then .CreateFolder (path)
    
    For Each vbcomp In ActiveWorkbook.VBProject.VBComponents
        If vbcomp.Type = vbext_ct_ClassModule Then
            HTML = parser.parsemodule(vbcomp)
            'htmls.add VBComp.name, html
            With .CreateTextFile(path & vbcomp.name & ".html", True)
                .Write HTML
            End With
            'Debug.Print html
        End If
    Next vbcomp
End With

testcode = "Public Sub parsetest() 'this is a simple line of code" & vbCrLf & _
           "    debug.print hello world!" & vbCrLf & _
           "End Sub"



End Sub
'parse a module into nicely formatted, printable HTML, with syntax highlighting and
'everything!  VBAIDE won't print formatted code, so this gets around all that!
Public Sub CDP_M_parsetarget(modname As String, Optional path As String)
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Dim parser As CodePrinter
Dim HTML As String

If path = vbNullString Then path = ActiveWorkbook.path & "\html\"

path = getFolder(path)
Set parser = New CodePrinter

With New FileSystemObject
    Set vbcomp = ActiveWorkbook.VBProject.VBComponents(modname)
    HTML = parser.parsemodule(vbcomp)
    With .CreateTextFile(path & vbcomp.name & ".html", True)
        .Write HTML
    End With
    Debug.Print "Dumped " & vbcomp.name & " to : " & path & vbcomp.name & ".html"

End With

End Sub

Public Function CDP_M_getCode(name As String) As String
Static module As VBComponent

'For Each VBComp In ActiveWorkbook.VBProject.VBComponents
Set module = ActiveWorkbook.VBProject.VBComponents(name)

'If module.Type = vbext_ct_ClassModule Then
    With module
        If .CodeModule.CountOfLines > 0 Then
            CDP_M_getCode = .CodeModule.lines(1, .CodeModule.CountOfLines)
        Else
            CDP_M_getCode = vbNullString
        End If
    End With
'Else
'    Err.Raise 101, , "Not a class"

'End If

End Function
Public Sub CDP_M_dumpCode(name As String, path As String, Optional ext As String)
Dim ts As TextStream
Dim vbcomp As VBComponent
path = getFolder(path)

If ext = vbNullString Then ext = ".txt"
With New FileSystemObject
    Set vbcomp = ActiveWorkbook.VBProject.VBComponents(name)
    With .CreateTextFile(path & vbcomp.name & ext, True)
        .Write getCode(name)
        .Close
    End With
    Debug.Print "Dumped " & vbcomp.name & " to : " & path & vbcomp.name & ".txt"
End With

End Sub
'Read code from a directory, load it into the
Public Sub CDP_M_readCode(name As String, path As String)

End Sub
'a simple sub to help us dump documentable code!
Public Sub CDP_M_dumpSporkandBrontoInterface()
Dim marclasses As Collection
Dim marmods As Collection
Dim sporkclasses As Collection
Dim sporkmods As Collection
Dim dir As String
Dim path As String
path = getPath() & "Source\"

Dim md As VBComponent
For Each md In ActiveWorkbook.VBProject.VBComponents
    dir = classify(md.name)
    If md.Type = vbext_ct_ClassModule Then
        parsetarget md.name, path & dir & "\Classes\"
    ElseIf md.Type = vbext_ct_StdModule Then
        parsetarget md.name, path & dir & "\Modules\"
    ElseIf md.Type = vbext_ct_MSForm Then
        parsetarget md.name, path & "Forms" & "\"
    End If
Next md
        
    
End Sub
'a simple sub to help us dump documentable code!
Public Sub CDP_M_dumpSporkandBrontoInterfaceRaw()
Dim marclasses As Collection
Dim marmods As Collection
Dim sporkclasses As Collection
Dim sporkmods As Collection
Dim dir As String
Dim path As String
path = getPath() & "Source\"

Dim md As VBComponent
For Each md In ActiveWorkbook.VBProject.VBComponents
    dir = classify(md.name)
    If md.Type = vbext_ct_ClassModule Then
        dumpCode md.name, path & dir & "\Classes\"
    ElseIf md.Type = vbext_ct_StdModule Then
        dumpCode md.name, path & dir & "\Modules\"
    ElseIf md.Type = vbext_ct_MSForm Then
        dumpCode md.name, path & "Forms" & "\"
    End If
Next md
        
    
End Sub
Private Function CDP_M_classify(nm As String) As String
If InStr(1, nm, "BrontoInterface") > 0 Then
    classify = "BrontoInterface"
ElseIf InStr(1, nm, "TimeStep") > 0 Then
    classify = "BrontoInterface"
ElseIf InStr(1, nm, "lib") > 0 Then
    classify = "SPORK"
ElseIf InStr(1, nm, "Generic") > 0 Then
    classify = "SPORK"
Else
    classify = "SPORK"
End If
End Function


Public Function CDP_M_LOCReview(indict As Dictionary, category As String, Optional errorhandling As Boolean) As Dictionary
Dim itm
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Dim modulecode As CodeCount
Dim count As CodeCount
Dim filter As String
If errorhandling Then filter = "Err.Raise"
      
Set LOCReview = New Dictionary

For Each itm In indict
    Set vbcomp = indict(itm)
    modulecode = countCode(vbcomp.CodeModule.lines(1, vbcomp.CodeModule.CountOfLines), filter)
    LOCReview.Add vbcomp.name, newdict("Name", vbcomp.name, _
                                       "CodeLines", modulecode.LOCode, _
                                       "CommentLines", modulecode.LOComments, _
                                       "Category", category)
    count.LOCode = modulecode.LOCode + count.LOCode
    count.LOComments = modulecode.LOComments + count.LOComments
Next itm

LOCReview.Add category & "Total", newdict("Name", category & "Total", _
                                       "CodeLines", count.LOCode, _
                                       "CommentLines", count.LOComments, _
                                       "Category", category)

End Function
Public Function CDP_M_getBrontoInterfaceRelated() As Collection
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Set getBrontoInterfaceRelated = New Collection

Set getBrontoInterfaceRelated = New Collection
For Each vbcomp In ActiveWorkbook.VBProject.VBComponents
    Select Case vbcomp.Type
        Case vbext_ct_ClassModule, vbext_ct_StdModule
            If isBrontoInterface(vbcomp) And vbcomp.CodeModule.CountOfLines > 0 Then
                getBrontoInterfaceRelated.Add vbcomp
            End If
    End Select
Next vbcomp
End Function
Public Function CDP_M_getGeneric() As Collection
Dim vbcomp As VBComponent
Dim codemod As CodeModule
Set getGeneric = New Collection

Set getGeneric = New Collection
For Each vbcomp In ActiveWorkbook.VBProject.VBComponents
    Select Case vbcomp.Type
        Case vbext_ct_ClassModule, vbext_ct_StdModule
            If Not (isBrontoInterface(vbcomp)) And vbcomp.CodeModule.CountOfLines > 0 Then
                getGeneric.Add vbcomp
            End If
    End Select
Next vbcomp
End Function
Public Function CDP_M_ReviewALL() As Dictionary

Dim itm
Dim rec As Dictionary

Dim BrontoInterfaces As Dictionary
Dim generics As Dictionary

Dim reviewed As Dictionary

Dim comp As VBComponent
Set BrontoInterfaces = New Dictionary
Set generics = New Dictionary

For Each comp In getBrontoInterfaceRelated()
    BrontoInterfaces.Add comp.name, comp
Next comp

For Each comp In getGeneric()
    generics.Add comp.name, comp
Next comp

Set reviewed = SetLib.union(LOCReview(BrontoInterfaces, "BrontoInterface"), LOCReview(generics, "Generic"))


Set ReviewALL = reviewed

End Function
Public Function CDP_M_ReviewErrorHandling() As Dictionary

Dim itm
Dim rec As Dictionary

Dim BrontoInterfaces As Dictionary
Dim generics As Dictionary

Dim reviewed As Dictionary

Dim comp As VBComponent
Set BrontoInterfaces = New Dictionary
Set generics = New Dictionary

For Each comp In getBrontoInterfaceRelated()
    BrontoInterfaces.Add comp.name, comp
Next comp

For Each comp In getGeneric()
    generics.Add comp.name, comp
Next comp

Set reviewed = SetLib.union(LOCReview(BrontoInterfaces, "BrontoInterface", True), LOCReview(generics, "Generic", True))


Set ReviewErrorHandling = reviewed

End Function
Public Sub CDP_M_CodeReview()
Dim res As Dictionary
Set res = ReviewALL
pprint res("BrontoInterfaceTotal")
pprint res("GenericTotal")


End Sub
Public Sub CDP_M_errorReview()
Dim errorhandlers As Dictionary
Dim itm
Dim handlercount As Long
Dim classcount As Long
Dim rec As Dictionary
Set errorhandlers = ReviewErrorHandling()
For Each itm In errorhandlers
    Set rec = errorhandlers(itm)
    If rec("CodeLines") > 0 Then
        handlercount = handlercount + 1
    End If
    classcount = classcount + 1
Next itm

Debug.Print "There are " & handlercount & " classes or modules with error handling, out of " & classcount & " classes or modules."
'quickview errorhandlers

End Sub
Public Function CDP_M_isBrontoInterface(cmp As VBComponent) As Boolean
isBrontoInterface = InStr(1, cmp.name, "TimeStep") Or InStr(1, cmp.name, "BrontoInterface")
End Function
Public Function CDP_M_countCode(codeblock As String, Optional filter As String) As CodeCount

Dim lines
Dim ln
Dim trimmed As String

lines = Split(codeblock, vbCrLf)
    With countCode
        .LOCode = 0
        .LOComments = 0
    For Each ln In lines
        trimmed = CStr(ln)
        trimmed = Trim(trimmed)
        If Mid(trimmed, 1, 1) = "'" Then
            .LOComments = .LOComments + 1
        Else
            If filter = vbNullString Then
                .LOCode = .LOCode + 1
            ElseIf InStr(1, trimmed, filter) > 0 Then
                .LOCode = .LOCode + 1
            End If
        End If
    Next ln
End With

End Function

'CLT_M Collection Lib
'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.


'Integrated 29 August 2012
'A library for operating on VBA collections, which are actually fancy doubly-linked lists.
'I borrow a lot from Lisp, and try to keep list operations (operations on collections) consistent between
'languages where possible.  FYI Collections are NOT built on cons cells (as far as I know), I think they are
'actually chunked arrays underneath.
Option Explicit
Public emptyList As Collection
Public Function CLT_M_getEmptyList() As Collection

If Not emptyList Is Nothing Then
    Set CLT_M_getEmptyList = CollectionLib.emptyList
Else
    Set CollectionLib.emptyList = New Collection
    Set CLT_M_getEmptyList = CollectionLib.emptyList
End If

End Function
'New Function added 23 Sep 2012
Public Function CLT_M_copyList(incoll As Collection) As Collection
Dim itm
Set CLT_M_copyList = New Collection
For Each itm In incoll
    CLT_M_copyList.Add itm
Next itm

End Function
'New Function added 23 Sep 2012
Public Function CLT_M_concatList(baselist As Collection, appendee As Collection) As Collection
Dim itm
Set CLT_M_concatList = copyList(baselist)
For Each itm In appendee
    CLT_M_concatList.Add itm
Next itm

End Function
Public Function CLT_M_sortColl(incoll As Collection, Optional descending As Boolean, Optional comparef As IComparator) As Collection
Set CLT_M_sortColl = sortAny(incoll, descending, comparef)
End Function
Public Function CLT_M_sortList(inlist As Collection, Optional descending As Boolean, Optional comparef As IComparator) As Collection
Set CLT_M_sortList = sortAny(inlist, descending, comparef)
End Function
'Aux function added 2 Sep 2012
Public Function CLT_M_restList(incoll As Collection) As Collection
Dim itm As Variant
Dim head As Boolean
Set CLT_M_restList = New Collection

head = True
For Each itm In incoll
    If head Then
        head = False
    Else
        CLT_M_restList.Add itm
    End If
Next itm


End Function
Public Function CLT_M_dropList(ByVal n As Long, incoll As Collection) As Collection
Dim itm As Variant
Set CLT_M_dropList = New Collection
For Each itm In incoll
    If n <= 0 Then
        dCLT_M_ropList.Add itm
    Else
        n = n - 1
    End If
Next itm

End Function

'A generic list function for creating n-tuples of values, using a list
'representation. args are zero-based.
Public Function CLT_M_ntuple(n As Long, ByVal args As Variant) As Collection
Dim i As Long
If UBound(args, 1) >= n - 1 Then
    Set CLT_M_ntuple = New Collection
    For i = LBound(args, 1) To UBound(args, 1)
        CLT_M_ntuple.Add args(i)
    Next i
Else
    Err.Raise 101, , "Need at least " & n & _
        " args for a " & n & " tuple."
End If

End Function

'New List functions added 18 July 2012
'Creates as list of 2 values, drawn from args.
Public Function CLT_M_pair(ParamArray args()) As Collection
Set CLT_M_pair = ntuple(2, args)
End Function

'New List functions added 18 July 2012
'Creates a list of 3 values, drawn from args.
Public Function CLT_M_triple(ParamArray args()) As Collection
Set CLT_M_triple = ntuple(3, args)
End Function

'New List functions added 14 July 2012
'Partition inlist into a list of n-lists.  distance can be used to set the inter-partition
'distance.  A distance of 1 produces partitions that share n-1 elements.
'A distance of n produces partitions that share no elements.
'A distance of n-1 produces partitions that share one element, useful for deriving
'adjacency lists.
Public Function CLT_M_partition(inlist As Collection, n As Long, Optional distance As Long) As Collection

Dim entry As Collection
Dim i As Long
Dim k As Long
Dim j As Long
If n <= 0 Then n = 1
Set partition = New Collection
k = n - 1
If distance = 0 Then distance = n
For i = 1 To inlist.count Step distance
    If (i + k) <= inlist.count Then
        Set entry = New Collection
        For j = i To i + k
            entry.Add inlist(j)
        Next j
        CLT_M_partition.Add entry
    End If
Next i

End Function

'New List Functions Added 16 July 2012
Public Function CLT_M_pairs(inlist As Collection) As Collection
Set CLT_M_pairs = partition(inlist, 2)
End Function
'New List Functions Added 16 july 2012
Public Function CLT_M_triples(inlist As Collection) As Collection
Set CLT_M_triples = partition(inlist, 3)
End Function
Public Function CLT_M_adjacentPairs(inlist As Collection) As Collection
Set CLT_M_adjacentPairs = partition(inlist, 2, 1)
End Function

'New List functions added 14 July 2012
'Convert a paramarray into a list of arguments
Public Function CLT_M_arglist(ByVal inval As Variant, Optional n As Long) As Collection
Dim itm
Dim entry As Collection
Dim i As Long
Dim k As Long
Dim j As Long
If n = 0 Then n = 1
Set arglist = New Collection
k = n - 1
For i = LBound(inval, 1) To UBound(inval, 1) Step n
    If n > 1 Then
        If (i + k) <= UBound(inval, 1) Then
            Set entry = New Collection
            For j = i To i + k
                entry.Add inval(j)
            Next j
            CLT_M_arglist.Add entry
        End If
    Else
        CLT_M_arglist.Add inval(i)
    End If
Next i
                       
Set entry = Nothing

End Function
'New List functions added 14 July 2012
'Convert a paramarray into a list of arguments
Public Function CLT_M_getArgs(ByVal inval As Variant) As Collection
Set CLT_M_getArgs = arglist(inval)
End Function
'New List functions added 14 July 2012
'Convert a paramarray into a list of arguments
Public Function CLT_M_getArgPairs(ByVal inval As Variant) As Collection
Set CLT_M_getArgPairs = arglist(inval, 2)
End Function

Sub CLT_M_argstest(ParamArray alist())
PAR_L_pprint getArgPairs(alist)

End Sub
'New list functions added 14 july 2012
Public Function CLT_M_fst(lst As Collection) As Variant
If lst.count > 0 Then
    If IsObject(lst(1)) Then
        Set CLT_M_fst = lst(1)
    Else
        fst = CLT_M_lst(1)
    End If
Else
    Err.Raise 101, , "List is empty!"
End If

End Function
'New list functions added 14 july 2012
Public Function CLT_M_snd(lst As Collection) As Variant
If lst.count > 1 Then
    If IsObject(lst(2)) Then
        Set CLT_M_snd = lst(2)
    Else
        CLT_M_snd = lst(2)
    End If
Else
    Err.Raise 101, , "List has no second entry!"
End If
End Function
'New List functions added 14 july 2012
Public Function CLT_M_thrd(lst As Collection) As Variant
If lst.count > 2 Then
    If IsObject(lst(3)) Then
        Set CLT_M_thrd = lst(3)
    Else
        CLT_M_thrd = lst(3)
    End If
Else
    Err.Raise 101, , "List has no third entry!"
End If

End Function
'New List functions added 30 Aug 2012
Public Function CLT_M_frth(lst As Collection) As Variant
If lst.count > 3 Then
    If IsObject(lst(4)) Then
        Set CLT_M_frth = lst(4)
    Else
        CLT_M_frth = lst(4)
    End If
Else
    Err.Raise 101, , "List has no fourth entry!"
End If

End Function


'new list functions added 14 july 2012
Public Function CLT_M_intList(upper As Long, Optional stepwidth As Long, Optional lower As Long) As Collection
Dim i As Long
If stepwidth = 0 Then stepwidth = 1
Set CLT_M_intList = New Collection
For i = lower To upper Step stepwidth
    CLT_M_intList.Add i
Next i

End Function
Public Function CLT_M_intList1(upper As Long, Optional stepwidth As Long) As Collection
Set CLT_M_intList1 = intList(upper, stepwidth, 1)
End Function
'new list functions added 14 july 2012
Public Function CLT_M_floatList(upper As Single, Optional stepwidth As Single, Optional lower As Single) As Collection
Dim i As Single
If stepwidth = 0 Then stepwidth = 1
Set CLT_M_floatList = New Collection
For i = lower To upper Step stepwidth
    CLT_M_floatList.Add i
Next i
End Function
'new list functions added 14 july 2012
Public Function CLT_M_floatList1(upper As Single, Optional stepwidth As Single) As Collection
Dim i As Single
If stepwidth = 0 Then stepwidth = 1
Set CLT_M_floatList1 = New Collection
For i = 1 To upper Step stepwidth
    CLT_M_floatList1.Add i
Next i
End Function
'new list functions added 29 Aug 2012
'Generic numerical list
Public Function CLT_M_numList(upper, Optional stepwidth, Optional lower) As Collection
Dim foundfloat As Boolean

If IsMissing(stepwidth) Then stepwidth = 0
If IsMissing(lower) Then lower = 0

If isFloat(upper) Or isFloat(stepwidth) Or isFloat(lower) Then
    Set CLT_M_numList = floatList(CSng(upper), CSng(stepwidth), CSng(lower))
Else
    Set CLT_M_numList = intList(CLng(upper), CLng(stepwidth), CLng(lower))
End If

End Function
Public Function CLT_M_isFloat(v) As Boolean

Select Case vartype(v)
    Case VbVarType.vbCurrency, VbVarType.vbDecimal, VbVarType.vbDouble, VbVarType.vbSingle
    CLT_M_isFloat = True
End Select
    

End Function
'new list functions added 14 July 2012
'zips n lists, where k is the length of the shortest list, into a single list of
'k entries, where each entry is a list of n entries, drawn from the kth element
'of each input list.
Public Function CLT_M_zip(ParamArray lists()) As Collection
Dim itm
Dim sublist As Collection
Dim i As Long
Dim min As Long
Dim found As Boolean
Dim entry As Collection

Set zip = New Collection
min = 999999
For Each itm In lists
    If itm.count < min Then
        min = itm.count
        found = True
    End If
Next itm

If found Then
    For i = 1 To min
        Set entry = New Collection
        For Each itm In lists
            entry.Add itm(i)
        Next itm
        CLT_M_zip.Add entry
    Next i
End If

End Function
'new list functions added 14 July 2012
'decomposes a list of k entries, where each entry is is composed of n sublists,
'into n sublists where each element is drawn from the nth entry
Public Function CLT_M_unzip(inlist As Collection) As Collection
Dim itm
Dim sublists As Collection
Dim i As Long, j As Long
Dim min As Long
Dim found As Boolean
Dim entry As Collection

Set sublists = New Collection
Set entry = inlist(1)
For j = 1 To entry.count
    sublists.Add New Collection
Next j

For i = 1 To inlist.count
    Set entry = inlist(i)
    If entry.count <> sublists.count Then Err.Raise 101, , _
        "Detected an odd list at " & i & ", the number of entries " & entry.count & " is not " & sublists.count
    For j = 1 To sublists.count
        sublists(j).Add entry(j)
    Next j
Next i
    
Set CLT_M_unzip = sublists
Set sublists = Nothing

End Function

Public Function CLT_M_newColl(ParamArray invals()) As Collection
Dim itm
Set CLT_M_newColl = New Collection
For Each itm In invals
    list.Add itm
Next itm

End Function
'alias for list, closer to lispy syntax....since we're using collections as lists.
Public Function CLT_M_list(ParamArray invals()) As Collection
Dim itm
Set CLT_M_list = New Collection
For Each itm In invals
    CLT_M_list.Add itm
Next itm

End Function
'effectively the same as the famous cons function in lisp, prepends itm to the head of a list,
'in this case a collection.
Public Function CLT_M_prepend(incoll As Collection, itm As Variant) As Collection
Set CLT_M_prepend = incoll
If incoll.count = 0 Then
    incoll.Add itm
Else
    incoll.Add itm, , 1
End If

End Function
'reverse the order of the collection, returns a new collection
Public Function CLT_M_reverse(incoll As Collection) As Collection
Dim itm
Set CLT_M_reverse = New Collection

For Each itm In incoll
    Set CLT_M_reverse = prepend(reverse, itm)
Next itm
End Function
'return a collection of the keys in the dictionary
Public Function CLT_M_fromSet(inset As Dictionary) As Collection
Dim k
Set fromSet = New Collection

For Each k In inset
    fromSet.Add k
Next k

End Function
'matches a string against a collection of criteria
Public Function CLT_M_matchString(txt As String, matchcriteria As Collection) As Boolean
Dim itm
matchString = False
For Each itm In matchcriteria
    If InStr(1, txt, CStr(itm)) > 0 Then
        CLT_M_matchString = True
        Exit For
    End If
Next itm
End Function
'return a collection of pairs in the dictionary
Public Function CLT_M_fromDict(indict As Dictionary) As Collection
Dim k
Set CLT_M_fromDict = New Collection

For Each k In indict
    CLT_M_fromDict.Add list(k, indict(k))
Next k

End Function

Public Function CLT_M_varrayToColl(inarr() As Variant) As Collection
Dim i
Dim dcount As Long
Set CLT_M_varrayToColl = New Collection

dcount = dimensioncount(inarr)
With CLT_M_varrayToColl
    If dcount = 1 Then
        For i = LBound(inarr, 1) To UBound(inarr, 1)
            .Add inarr(i)
        Next i
    ElseIf dcount = 2 Then 'likely a 2D record representation
        For i = LBound(inarr, 1) To UBound(inarr, 1)
            .Add inarr(i, 1)
        Next i
    Else
        Err.Raise 101, , "Don't know how to convert 3 D arrays into collections"
    End If
End With

End Function

Sub CLT_M_tst()
Dim inarr2d(1 To 1, 1 To 2)
Dim inarr1d(1 To 2)
Dim tbl(1 To 2, 1 To 2)

tbl(1, 1) = "A"
tbl(1, 2) = "B"
tbl(2, 1) = "C"
tbl(2, 2) = "D"

inarr2d(1, 1) = "A"
inarr2d(1, 2) = "B"
inarr1d(1) = "C"
inarr1d(2) = "D"


End Sub

Public Function CLT_M_asCollection(ByRef itm As Variant) As Collection
Select Case TypeName(itm)
    Case "Collection"
        Set CLT_M_asCollection = itm
    Case "Variant()"
        Dim tmp()
        tmp = itm
        Set CLT_M_asCollection = CollectionLib.varrayToColl(tmp)
    Case Else
        Err.Raise 101, , "Cannot coerce to collection"
End Select

End Function

Public Function CLT_M_listToVector(Optional elements As Collection) As Variant
Dim tmp() As Variant
Dim idx As Long
Dim itm As Variant

If elements Is Nothing Then
    ReDim tmp(0 To 0)
ElseIf elements.count = 0 Then
    ReDim tmp(0 To 0)
ElseIf elements.count > 0 Then
    ReDim tmp(0 To elements.count - 1)
    
    For Each itm In elements
        bind tmp(idx), itm
        idx = idx + 1
    Next itm
End If

CLT_M_listToVector = tmp
End Function

'CMP_M_

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

' Option Explicit 'CMP_M_

Public Function CMP_M_float32comp(lhs As Single, RHS As Single) As Comparison
If lhs < RHS Then
    CMP_M_float32comp = Comparison.lessthan
ElseIf lhs > RHS Then
    CMP_M_float32comp = Comparison.greaterthan
Else
    CMP_M_float32comp = Comparison.equal
End If
End Function
Public Function CMP_M_float64comp(lhs As Double, RHS As Double) As Comparison
Dim delta As Double
delta = lhs - RHS
If Abs(delta) < epsilon Then
    CMP_M_float64comp = Comparison.equal
ElseIf delta < 0 Then
    CMP_M_float64comp = lessthan
Else
    CMP_M_float64comp = greaterthan
End If

End Function
Public Function CMP_M_textcomp(lhs As String, RHS As String) As Comparison
If lhs < RHS Then
    CMP_M_textcomp = Comparison.lessthan
ElseIf lhs > RHS Then
    CMP_M_textcomp = Comparison.greaterthan
Else
    CMP_M_textcomp = Comparison.equal
End If
End Function
Public Function CMP_M_floatVstext(lhs As Single, RHS As String) As Comparison
If lhs < RHS Then
    CMP_M_floatVstext = Comparison.lessthan
ElseIf lhs > RHS Then
    CMP_M_floatVstext = Comparison.greaterthan
Else
    CMP_M_floatVstext = Comparison.equal
End If
End Function

Public Function CMP_M_textVsfloat(lhs As String, RHS As Single) As Comparison
If lhs < RHS Then
    CMP_M_textVsfloat = Comparison.lessthan
ElseIf lhs > RHS Then
    CMP_M_textVsfloat = Comparison.greaterthan
Else
    CMP_M_textVsfloat = Comparison.equal
End If
End Function

Public Function CMP_M_longVslong(lhs As Long, RHS As Long) As Comparison
If lhs < RHS Then
    longVslong = Comparison.lessthan
ElseIf lhs > RHS Then
    longVslong = Comparison.greaterthan
Else
    longVslong = Comparison.equal
End If
End Function
Public Function CMP_M_genericComp(ByRef lhs As Variant, RHS As Variant) As Comparison
Dim ltype As VbVarType
Dim rtype As VbVarType

ltype = vartype(lhs)
rtype = vartype(RHS)
If ltype = rtype Then
    Select Case ltype
        Case VbVarType.vbDouble
            CMP_M_genericComp = float64comp(CDbl(lhs), CDbl(RHS))
        Case VbVarType.vbObject
            Err.Raise 101, , "Cannot compare objects, yet!"
        Case Else
            If lhs < RHS Then
                genericComp = lessthan
            ElseIf lhs > RHS Then
                 CMP_M_genericComp = greaterthan
            Else
                CMP_M_genericComp = equal
            End If
    End Select
Else
    If lhs < RHS Then
        CMP_M_genericComp = lessthan
    ElseIf lhs > RHS Then
         CMP_M_genericComp = greaterthan
    Else
        CMP_M_genericComp = equal
    End If
End If

End Function
Public Function CMP_M_compareAny(ByRef lhs As Variant, RHS As Variant, Optional comptype As ComparisonType) As Comparison
Select Case comptype
    Case ComparisonType.generic
        CMP_M_compareAny = genericComp(lhs, RHS)
    Case ComparisonType.text
        CMP_M_compareAny = textcomp(CStr(lhs), CStr(RHS))
    Case ComparisonType.int32
        CMP_M_compareAny = longVslong(CLng(lhs), CLng(RHS))
    Case ComparisonType.float32
        CMP_M_compareAny = float32comp(CSng(lhs), CSng(RHS))
    Case ComparisonType.float64
        CMP_M_compareAny = float64comp(CSng(lhs), CSng(RHS))
End Select
End Function

Public Function CMP_M_invertComparer(comp As IComparator) As IComparator
Dim nc As GenericComparerNot
Set nc = New GenericComparerNot
nc.compose comp
Set CMP_M_invertComparer = nc

End Function
Public Function CMP_M_newComparer(Optional comptype As ComparisonType, Optional descending As Boolean) As IComparator
Dim c As GenericComparer

Set c = New GenericComparer
c.comptype = comptype
If descending Then
    Set CMP_M_newComparer = invertComparer(c)
Else
    Set CMP_M_newComparer = c
End If
End Function
'make a list comparer out of all the comparers in incoll
Public Function CMP_M_listComparer(incoll As Collection) As IComparator
Dim comp As IComparator
Dim lc As GenericComparerList
Set lc = New GenericComparerList
For Each comp In incoll
    lc.addComparer comp
Next comp

End Function

'compare using a list of comparers
Public Function CMP_M_compareBy(ByRef lhs As Variant, ByRef RHS As Variant, Optional complist As Collection)
Dim res As Comparison
Dim comp As IComparator
If complist Is Nothing Then
    CMP_M_compareBy = compareAny(lhs, RHS)
Else
    CMP_M_compareBy = Comparison.equal
    For Each comp In complist
        res = comp.compare(lhs, RHS)
        If res <> Comparison.equal Then Exit For
    Next comp
    CMP_M_compareBy = res
End If
End Function

Public Function CMP_M_dictComparer(indict As Dictionary) As IComparator
Dim kvpc As GenericComparerDict
Set kvpc = New GenericComparerDict
kvpc.setKvps indict
Set CMP_M_dictComparer = kvpc
Set kvpc = Nothing
End Function

'builds comparers from IFn interfaces.
Public Function CMP_M_fnComparer(f As IFn) As IComparator
Dim c As GenericComparerFn
Set c = New GenericComparerFn
Set c.sortingf = f
Set CMP_M_fnComparer = c
Set c = Nothing
End Function



' DIT_M_ Dictionary Lib

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'This is a stock library for working with dictionaries.
'I will probably start using it a lot to eliminate boilerplate code in
'in a lot of the dictionary stuff.
' Option Explicit DIT_M_
'New Dictionary Functions added 16 July 2012
'Return the result of merging multiple dictionaries.
'Merging is a left->right process, in that dictionaries earlier
'in the process have their keys superceded by dictionaries later in
'the sequence.  This is like the merge function in clojure.
'We return a new dictionary the represents the result of the
'merge.  Primitive values are copied, references to objects still
'point to the same objects though, and are subject to mutation....
'The resulting dictionary is an amalgamation of the inputs.
Public Function DIT_M_mergeDicts(ParamArray indicts()) As Dictionary
Dim keytable As Dictionary
Dim d As Dictionary
Dim i As Long
Dim ds As Collection
Dim k

Set keytable = New Dictionary
Set ds = arglist(indicts)
'collects all the keys, from left to right, with right most overriding
'the leftmost keys.  Values are indexed accoring to the dictionary they
'came from.
For i = 1 To ds.count
    Set d = ds(i)
    For Each k In listKeys(d)
        Set keytable = assoc(keytable, k, i)
    Next k
Next i
Set DIT_M_mergeDicts = New Dictionary
For Each k In keytable
    Set d = ds(keytable(k))
    mergeDicts.Add k, d(k)
Next k
Set keytable = Nothing
        
End Function
Private Sub DIT_M_mergetest()
PAR_L_pprint DIT_M_mergeDicts(newdict("A", 1, "B", 2), newdict("Tom", 30, "Spoon", 3), newdict("Tom", 31))

End Sub

'New Dictionary library adde 16 July 2012
'Fetch a collection of values, in order, associated with keys.  Keys must exist in the dictionary.
Public Function DIT_M_getKeys(keys As Collection, indict As Dictionary) As Collection
Dim k
Set DIT_M_getKeys = New Collection
For Each k In keys
    If indict.exists(k) Then
        DIT_M_getKeys.Add indict(k)
    Else
        Err.Raise 101, , "Key " & k & " does not exist in the dictionary!"
    End If
Next k

End Function

'New function added 14 july 2012
'Returns a list of the values associated to all keys in the dictionary.
'the default .items() method of the dictionary returns a variant array, which we plug into a list
'for more accesibility.
Public Function DIT_M_listVals(indict As Dictionary) As Collection
Dim itm

Set DIT_M_listVals = New Collection
For Each itm In indict.items
    DIT_M_listVals.Add itm
Next itm

End Function

'new function added 14 july 2012
'view a dictionary as a sequence of key-value pairs
'This is just a thin wrapper around list.fromDict
Public Function DIT_M_listKeyVals(indict As Dictionary) As Collection
Set DIT_M_listKeyVals = CollectionLib.fromDict(indict)
End Function


'Like Lisp/Clojure's assoc function.
Public Function DIT_M_assoc(indict As Dictionary, ByRef key As Variant, ByRef value As Variant)
If Not indict.exists(key) Then
    DIT_M_indict.Add key, value
Else
    If IsObject(value) Then
        Set DIT_M_indict.Item(key) = value
    Else
        DIT_M_indict.Item(key) = value
    End If
End If

Set assoc = indict
End Function
Public Function DIT_M_assocIn(indict As Dictionary, keys As Collection, ByRef value As Variant) As Dictionary
Dim k
Dim i As Long
Dim ptr As Dictionary
Dim newptr As Dictionary


Set ptr = indict
For i = 1 To keys.count - 1
    k = keys(i)
    If Not ptr.exists(k) Then
        Set newptr = New Dictionary
        ptr.Add k, newptr
        Set ptr = newptr
        Set newptr = Nothing
    End If
Next i
   
ptr.Add keys(keys.count), value
       
Set DIT_M_assocIn = indict

End Function


'Allows in-line creation of dictionaries.  Truncates the last argument.
Public Function DIT_M_newdict(ParamArray kvps()) As Dictionary
Dim remaining As Long
Dim key
Dim val
Dim i As Long
Set DIT_M_newdict = New Dictionary
remaining = UBound(kvps, 1) + 1
i = 0
While remaining >= 2
    DIT_M_newdict.Add kvps(i), kvps(i + 1)
    i = i + 2
    remaining = remaining - 2
Wend

End Function
'reads a collection, assigning k v to alternate elements.
Public Function DIT_M_dictOfAList(Optional assoclist As Collection) As Dictionary
Dim remaining As Long
Dim key
Dim val
Dim i As Long

Set DIT_M_dictOfAList = New Dictionary
If exists(assoclist) Then
    remaining = assoclist.count
    i = 1
    While remaining >= 2
        DIT_M_dictOfAList.Add assoclist(i), assoclist(i + 1)
        i = i + 2
        remaining = remaining - 2
    Wend
End If

End Function
'reads a collection, assigning k v to alternate elements.
Public Function DIT_M_dictOfList(Optional list As Collection) As Dictionary
Dim val
Dim i As Long

Set DIT_M_dictOfList = New Dictionary
If exists(list) Then
    i = 0
    For Each val In list
        DIT_M_dictOfList.Add i, val
        i = i + 1
    Next val
End If

End Function


Public Function DIT_M_newSet(ParamArray keys()) As Dictionary
Dim key
Set DIT_M_newSet = New Dictionary
For Each key In keys
    If Not DIT_M_newSet.exists(key) Then DIT_M_newSet.Add key, key
Next key
End Function
Public Function DIT_M_onlyKeys(keys As Collection, indict As Dictionary) As Dictionary
Dim k
Dim filter As Dictionary
If keys.count = 0 Then
    Set DIT_M_onlyKeys = indict
Else
    Set DIT_M_onlyKeys = New Dictionary
    Set filter = New Dictionary
    For Each k In keys
        If Not filter.exists(k) Then
            filter.Add k, 0
        End If
    Next k
    For Each k In filter
        If indict.exists(k) Then
            DIT_M_onlyKeys.Add k, indict(k)
        End If
    Next k
End If
End Function
Public Function DIT_M_excludeKeys(keys As Collection, indict As Dictionary) As Dictionary
Dim k
Dim filter As Dictionary
If keys.count = 0 Then
    Set DIT_M_excludeKeys = indict
Else
    Set DIT_M_excludeKeys = New Dictionary
    Set filter = New Dictionary
    For Each k In keys
        If Not filter.exists(k) Then
            filter.Add k, 0
        End If
    Next k
    For Each k In indict
        If Not filter.exists(k) Then
            DIT_M_excludeKeys.Add k, indict(k)
        End If
    Next k
End If

End Function
Public Function DIT_M_getKey(key As Variant, indict As Dictionary) As Variant
If indict.exists(key) Then
    If IsObject(indict(key)) Then
        Set DIT_M_getKey = indict(key)
    Else
        DIT_M_getKey = indict(key)
    End If
Else
    Err.Raise 101, , "Dictionary does not contain key " & CStr(key)
End If
End Function

Public Function DIT_M_addDict(indict As Dictionary, ParamArray kvps()) As Dictionary
Dim remaining As Long
Dim key
Dim val
Dim i As Long


remaining = UBound(kvps, 1) + 1
i = 0
While remaining >= 2
    indict.Add kvps(i), kvps(i + 1)
    i = i + 2
    remaining = remaining - 2
Wend

Set DIT_M_addDict = indict

End Function
Public Function DIT_M_copyDict(indict As Dictionary) As Dictionary

'Note -> using memcpy is probably much much faster, this is a naive way to do it.
Dim key
Set DIT_M_copyDict = New Dictionary
For Each key In indict
    DIT_M_copyDict.Add key, indict(key)
Next key

End Function
'usage...
Public Sub DIT_M_tst()
Dim d1 As Dictionary
Dim d2 As Dictionary
 
Set d1 = DIT_M_addDict(newdict("A", 2), "B", 3)
printDict d1
Set d2 = DIT_M_copyDict(d1)
PAR_L_printDict d2

End Sub
'zipMap is a useful function, common in functional programming, that acts like the functional zip,
'drawing from two sequences bound to keys and values.  In this context, the sequences are combined to
'create key/value entries in a new dictionary, which is returned.  Draws incrementally from both
'collections, terminating when one runs out first
Public Function DIT_M_zipMap(ks As Collection, vs As Collection) As Dictionary

Dim k
Dim DIT_M_count As Long
Set DIT_M_zipMap = New Dictionary
count = count + 1

If exists(ks) And exists(vs) Then
    While count <= ks.count And count <= vs.count
        DIT_M_zipMap.Add ks(count), vs(count)
        count = count + 1
    Wend
End If

End Function

Public Function DIT_M_asDict(ByRef itm As Variant) As Dictionary
Set DIT_M_asDict = itm
End Function


Public Function DIT_M_listKeys(indict As Dictionary) As Collection
Dim itm
Set DIT_M_listKeys = New Collection
For Each itm In indict.keys
    DIT_M_listKeys.Add itm
Next itm

End Function



Private Sub FRM_M_Form_Load() 'put in every "Table Form"
   Call LVM_M_Form_Load(Me)

End Sub


Private Sub FRM_M_Form_Close() 'put in every "Table Form"
   Call LVM_M_Form_Close(Me)

End Sub

Private Sub FRM_M_cmdSCAN_Click() 'put in every "Table Form"  'may have to tweak / name mangle with Form Name
   Call LVM_M_cmdSCAN_Click(Me)

End Sub

Private Sub FRM_M_cmdSUBMIT_Click() 'put in every "Table Form" 'may have to tweak / name mangle with Form Name
   Call LVM_M_cmdSUBMIT_Click(Me)

End Sub

'GC__C_ GenericCompararer

'sorts in ascending order by default!
'descending behavior is accomplished by composing with a not
'Option Explicit 'GC__C

'Public comptype As ComparisonType ''GC__C
'Implements IComparator - had to comment out - not quite sure how to mimic VBA Class stuff in a Module... yet...


Private Sub GC__C_Class_Initialize()
comptype = ComparisonType.generic 'set VBA default comparity
End Sub
Public Function GC__C_compare(ByRef lhs As Variant, ByRef RHS As Variant) As Comparison
GC__C_compare = compareAny(lhs, RHS, comptype)
End Function
Private Function GC__C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
GC__C_IComparator_compare = compare(lhs, RHS)
End Function

'GCD_C GenericComparerDict

'A comparer that consults a dictionary for its comparison.
'Specifically, we pass the values, mapped from keys, as the
'comparison values, rather than sorting on the keys explicitly.
'Option Explicit 'GCD_C_

Private kvps As Dictionary
Private composed As IComparator
' Implements IComparator 'will port to a non VBA class implementation

Public Sub GCD_C_setKvps(keyvals As Dictionary)
Set GCD_C_kvps = Nothing
Set GCD_C_kvps = keyvals
End Sub
Public Sub GCD_C_composeWith(newcomp As IComparator)
Set GCD_C_composed = Nothing
Set GCD_C_composed = newcomp
End Sub
Public Function GCD_C_compare(ByRef lkey As Variant, ByRef rkey As Variant) As Comparison

If kvps.exists(lkey) And kvps.exists(rkey) Then
    If composed Is Nothing Then
        GCD_C_compare = ComparisonLib.compareAny(kvps(lkey), kvps(rkey))
    Else
        GCD_C_compare = composed.compare(kvps(lkey), kvps(rkey))
    End If
Else
    Err.Raise 101, , "Keys do not exist in the Dictionary you are using for comparison!"
End If

End Function

Private Sub GCD_C_Class_Terminate()
Set GCD_C_kvps = Nothing
End Sub

'use the list of comparers to try to reach a conclusion about these guys
Private Function GCD_C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
GCD_C_IComparator_compare = compare(lhs, RHS)
End Function


'GCF_C_ GenericComparerFn

'GCF_C_ GenericComparerFn

'sorts according to an IFn of two arguments!
'Option Explicit GCF_C_


Public sortingf As IFn 'GCF_C_
' Implements IComparator


Public Function GCF_C_compare(ByRef lhs As Variant, ByRef RHS As Variant) As Comparison
Dim res As Long
res = CLng(sortingf.apply(list(lhs, RHS)))
If res < 0 Then
    GCF_C_compare = lessthan
ElseIf res > 0 Then
    GCF_C_compare = greaterthan
Else
    GCF_C_compare = equal
End If
End Function

Private Function GCF_C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
Dim res As Long
res = CLng(sortingf.apply(list(lhs, RHS)))
If res < 0 Then
    GCF_C_IComparator_compare = lessthan
ElseIf res > 0 Then
    GCF_C_IComparator_compare = greaterthan
Else
    GCF_C_IComparator_compare = equal
End If

End Function

'GCL_C_  GenericComparerList

'Option Explicit 'GCL_C_
Private comparers As Collection

'Implements IComparator 'fix later

Private Sub GCL_C_Class_Initialize()
Set GCL_C_comparers = New Collection
End Sub

Public Sub GCL_C_addComparer(incomp As IComparator)
comparers.Add incomp
End Sub
Public Function GCL_C_compare(ByRef lhs As Variant, ByRef RHS As Variant) As Comparison
Dim comp As IComparator

For Each comp In comparers
    GCL_C_compare = comp.compare(lhs, RHS)
    If GCL_C_compare <> equal Then Exit For
Next comp

End Function
'use the list of comparers to try to reach a conclusion about these guys
Private Function GCL_C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
GCL_C_IComparator_compare = compare(lhs, RHS)
End Function

'GCN_C  GenericComparerNot

'Option Explicit 'GCN_C_

Public source As IComparator
'Implements IComparator ' fix later


Public Function GCN_C_compose(comp As IComparator) As IComparator
Set source = comp
Set GCN_C_compose = Me
End Function
Public Function GCN_C_compare(ByRef lhs As Variant, ByRef RHS As Variant) As Comparison
GCN_C_compare = source.compare(RHS, lhs)
End Function

Private Function GCN_C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
GCN_C_IComparator_compare = compare(lhs, RHS)
End Function

'GCS_C_ GenericComparerSet

'Option Explicit 'GCS_C_

Private comparers As Collection

'Implements IComparator 'fix later

Private Sub GCS_C_Class_Initialize()
Set comparers = New Collection
End Sub

Public Sub GCS_C_addComparer(incomp As IComparator)
comparers.Add incomp
End Sub
'use the list of comparers to try to reach a conclusion about these guys
Private Function GCS_C_IComparator_compare(lhs As Variant, RHS As Variant) As Comparison
Dim comp As IComparator

For Each comp In comparers
    IComparator_compare = comp.compare(lhs, RHS)
    If IComparator_compare <> equal Then Exit For
Next comp

End Function

'GME_C_  GenericMapEntry

'Option Explicit 'GME_C_

Public key As Variant
Public val As Variant

'public Object nth(int i)
'{   if(i == 0)      return key();   else if(i == 1)     return val();
'    else        throw new IndexOutOfBoundsException();}
Public Function GME_C_nth(i As Long) As Variant

If i = 0 Then
    bind nth, key
ElseIf i = 1 Then
    bind GME_C_nth, val
Else
    Err.Raise 101, , "Index out of Bounds"
End If

End Function

'private IPersistentVector asVector()
'{   return LazilyPersistentVector.createOwning(key(), val());}


'public IPersistentVector assocN(int i, Object val){ return asVector().assocN(i, val);}

'public int count()
'{   return 2;}
Public Function GME_C_count() As Long
count = 2
End Function
Public Function GME_C_seq() As ISeq

End Function
'public ISeq seq()
'{   return asVector().seq();}
'public IPersistentVector cons(Object o){
'    return asVector().cons(o);}
'public IPersistentCollection empty()
'{   return null;}
'public IPersistentStack pop()
'{   return LazilyPersistentVector.createOwning(key());}
'public Object setValue(Object value)
'{   throw new UnsupportedOperationException();}


'GS__C_ GenericSort


'This WAS a generic class for sort operations, with an implementation of quicksort.  I repurposed it
'to just be an Excel wrapper (ugh) to hide the nasty excel calling language for sorting tables of
'cells.

'Option Explicit 'GS__C_
'
'Private Function partitionAscending(inarr(), left As Long, right As Long, pivot As Long, Optional twod As Boolean) As Long
'Dim pivotval
'Dim i As Long, j As Long
'If twod = False Then
'    pivotval = inarr(pivot)
'Else
'    pivotval = inarr(pivot, 1)
'End If
'i = left
'j = right
'If twod = False Then
'    While i <= j
'        While inarr(i) < pivotval
'            i = i + 1
'        Wend
'        While inarr(j) > pivotval
'            j = j - 1
'        Wend
'        If i <= j Then
'            swap inarr, i, j, twod
'            i = i + 1
'            j = j - 1
'        End If
'    Wend
'Else
'    While i <= j
'        While inarr(i, 1) < pivotval
'            i = i + 1
'        Wend
'        While inarr(j, 1) > pivotval
'            j = j - 1
'        Wend
'        If i <= j Then
'            swap inarr, i, j, twod
'            i = i + 1
'            j = j - 1
'        End If
'    Wend
'End If
'
'partitionAscending = i
'
'End Function
'Private Function partitionDescending(inarr(), left As Long, right As Long, pivot As Long, Optional twod As Boolean) As Long
'Dim pivotval
'Dim i As Long, j As Long
'If twod = False Then
'    pivotval = inarr(pivot)
'Else
'    pivotval = inarr(pivot, 1)
'End If
'i = left
'j = right
'If twod = False Then
'    While i <= j
'        While inarr(i) > pivotval
'            i = i + 1
'        Wend
'        While inarr(j) < pivotval
'            j = j - 1
'        Wend
'        If i <= j Then
'            swap inarr, i, j, twod
'            i = i + 1
'            j = j - 1
'        End If
'    Wend
'Else
'    While i <= j
'        While inarr(i, 1) > pivotval
'            i = i + 1
'        Wend
'        While inarr(j, 1) < pivotval
'            j = j - 1
'        Wend
'        If i <= j Then
'            swap inarr, i, j, twod
'            i = i + 1
'            j = j - 1
'        End If
'    Wend
'End If
'
'partitionDescending = i
'
'End Function
'
'Private Sub swap(inarr(), idx1 As Long, idx2 As Long, Optional twod As Boolean)
'Dim tmp
'Dim j As Long
'
'If idx1 <> idx2 Then
'    If twod = False Then
'        tmp = inarr(idx1)
'        inarr(idx1) = inarr(idx2)
'        inarr(idx2) = tmp
'    Else
'        For j = 1 To UBound(inarr, 2)
'            tmp = inarr(idx1, j)
'            inarr(idx1, j) = inarr(idx2, j)
'            inarr(idx2, j) = tmp
'        Next j
'    End If
'End If
'
'End Sub
'
'Private Sub qsort(inarr(), left As Long, right As Long, Optional twod As Boolean, Optional descending As Boolean)
'Dim pivot As Long
'Dim newidx As Long
'
'If right > left Then
'    pivot = (right + left) \ 2
'    If descending Then
'        newidx = partitionDescending(inarr, left, right, pivot, twod)
'    Else
'        newidx = partitionAscending(inarr, left, right, pivot, twod)
'    End If
'    If left < newidx - 1 Then qsort inarr, left, newidx - 1, twod, descending
'    If index < right Then qsort inarr, newidx, right, twod, descending
'End If
'
'End Sub
''we only sort 1d or 2d arrays...
'Public Function sort(source(), Optional column As Long, Optional descending As Boolean) As Double()
'
'Dim dcount As Long
'dcount = ArrayLib.dimensioncount(source)
'If dcount > 2 Then Err.Raise 101, , "Cannot sort in greater than 2 dimensions currently, check your input array"
'
'If dcount = 2 Then
'    If column = 0 Then column = 1
'    qsort source, LBound(rendered, 1), UBound(rendered, 1), True, descending
'sort = rendered
'End Function
'

'call the built-in sorting functions to sort a range....only sorts by a single column.
Public Sub GS__C_SortRange(inrng As Range, Optional bycolumn As Long, Optional ascending As Boolean)
Dim sorttype As Long
Dim found As Boolean
Dim col As Long
Dim clmn As Range

If ascending Then sorttype = xlAscending Else sorttype = xlDescending

If bycolumn > 0 Then
    col = bycolumn
Else
    col = 1 'sort using the first column
End If

inrng.sort inrng.Cells(1, col), sorttype

End Sub
'assumes a table with fields, ignores the headers.  Assumes first row is header row.
Public Sub GS__C_SortTableRange(inrng As Range, byfield As String, Optional ascending As Boolean)
SortRange chopHeaders(inrng), findField(inrng, byfield), ascending
End Sub

Private Function GS__C_findField(inrng As Range, field As String) As Long
Dim clmn As Range

GS__C_findField = 1
For Each clmn In inrng.Columns
    If clmn.Cells(1, 1) = field Then
        found = True
        Exit For
    Else
        GS__C_findField = findField + 1
    End If
Next clmn

If Not found Then Err.Raise 101, , "field " & field & " does not exist"
End Function

Private Function GS__C_chopHeaders(inrng As Range) As Range
Set GS__C_chopHeaders = inrng.offset(1, 0)
Set GS__C_chopHeaders = chopHeaders.resize(chopHeaders.rows.count - 1, chopHeaders.Columns.count)
End Function

Private Function GS__C_getHeaders(inrng As Range) As Range
Set GS__C_getHeaders = inrng.rows(1)
End Function


'ICL_C_  IClosure

'Option Explicit 'ICL_C_

Public Function ICL_C_apply(args As Collection) As Variant
End Function

'ICP_C IComparator


'interface for comparing 2 items.
'this is fairly typical in most languages

Option Explicit 'ICP_C_

Public Function compare(ByRef lhs As Variant, ByRef RHS As Variant) As Comparison

End Function


'IDI_C_  IDistributor

'Option Explicit 'IDI_C_

Public Function IDI_C_Distribute(n As Long) As Dictionary
End Function


'IFN_C  IFn

'Option Explicit 'IFN_C_  IFn

Public Function IFN_C_apply(args As Collection) As Variant
End Function


'IOL_M_  IOLib

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'Option Explicit 'IOL_M_ IOLib

'Tom change 6 Nov 2012
'Traverses a map in depth first order.
'To effeciently do this (and to make it easy to serialize/deserialize using JSON),
'we split our maps into 2 levels...
'Associated values that are also maps become folders with their own stuff...
'Primitive values (i.e. values that are NOT maps), are serialized as a separate
'dictionary under "entries.json".

'Keyvals that are also maps become folders, contents are the vals.
Public Sub IOL_M_mapToFolders(path As String, data As Dictionary, Optional flat As Boolean)
Dim key
Dim itm
Dim d As Dictionary
Dim entries As Dictionary

Set d = data

If flat = False Then
    Set entries = New Dictionary
    
    For Each key In d
        If Not IsObject(data(key)) Then
            'SerializationLib.pickleTo data(key), path & "\" & CStr(key) & ".json"
            entries.Add key, data(key)
        Else
            Select Case TypeName(data(key))
                Case "Dictionary"
                    mapToFolders path & "\" & CStr(key), data(key), flat
                Case Else
                    'SerializationLib.pickleTo data(key), path & "\" & CStr(key) & ".json"
                    entries.Add key, data(key)
            End Select
        End If
    Next key
    
    If entries.count > 0 Then SerializationLib.pickleTo entries, path & "\entries.json"
Else 'produce a flattened segment of entries.  Each entry is a file, even if it's only a primitive val.
    For Each key In d
        If Not IsObject(data(key)) Then
            SerializationLib.pickleTo data(key), path & "\" & CStr(key) & ".json"
        Else
            Select Case TypeName(data(key))
                Case "Dictionary"
                    mapToFolders path & "\" & CStr(key), data(key), flat
                Case Else
                    SerializationLib.pickleTo data(key), path & "\" & CStr(key) & ".json"
            End Select
        End If
    Next key
End If

Set entries = Nothing
Set d = Nothing

End Sub

'TOM change 7 Nov 2012 -> converts a directory tree into a nested map, where subfolders are
'nested maps as well.  If flat is false or not supplied, non-dictionary values are flattend into a
'subdictionary called entries.json.  If flat is true, every non-dictionary entry is expanded into an
'individual JSON file.
Public Function IOL_M_folderToMap(rootpath As String, Optional flat As Boolean) As Dictionary
Dim key
Dim itm
Dim d As Dictionary
Dim fl As String
Dim entries As Dictionary
Dim folds As Dictionary

Set entries = getEntries(rootpath, flat)
'first thing we do is snarf the entries in the root directory, if any exist...

Set folds = listFolders(rootpath)
For Each key In folds
    Set d = IOL_M_folderToMap(CStr(folds(key)), flat)
    entries.Add CStr(key), d
Next key
Set folds = Nothing

Set IOL_M_folderToMap = entries
Set entries = Nothing
Set d = Nothing

End Function

'TOM change 7 Nov 2012 -> loads the root entries from a folder-backed map.
Public Function IOL_M_getEntries(rootpath As String, Optional flat As Boolean) As Dictionary
Dim fl
Dim filepaths As Dictionary
Dim s As String
Dim ents As StringBuilder
If flat = False Then
    If fileExists(rootpath & "\entries.json") Then
        Set IOL_M_getEntries = SerializationLib.unpickleFrom(New Dictionary, rootpath & "\entries.json")
    Else
        Set IOL_M_getEntries = New Dictionary
    End If
Else

    Set ents = New StringBuilder
    ents.append "{"
    Set filepaths = listFiles(rootpath)
    If filepaths.count > 0 Then
        For Each fl In filepaths
            s = SerializationLib.readString(filepaths(fl)) 'build a keyval from the file/string
            ents.append "'" & replace(CStr(fl), ".json", vbNullString) & "':" & s & ","
        Next fl
        ents.Remove ents.length - 1, 1 'drop the last ","
        ents.append "}"
    
        Set IOL_M_getEntries = SerializationLib.JSONtoDictionary(ents.toString)
        Set ents = Nothing
    Else
        Set IOL_M_getEntries = New Dictionary
    End If
    Set filepaths = Nothing
End If
End Function
Public Function IOL_M_fileExists(path As String) As Boolean
'With New Scripting.FileSystemObject
'    fileExists = .fileExists(path)
'End With
IOL_M_fileExists = dir$(path) <> vbNullString
End Function
'Tom change 7 Nov 2012 -> added...
Public Function IOL_M_listFolders(path As String) As Dictionary
Dim fldr As Folder
Dim f As Folder
Set IOL_M_listFolders = New Dictionary
With New FileSystemObject
    If .FolderExists(path) Then
        Set fldr = .getFolder(path)
        For Each f In fldr.SubFolders
            IOL_M_listFolders.Add f.name, f.path
        Next f
    End If
End With

End Function
'Tom change 7 Nov 2012 -> added...
Public Function IOL_M_listFiles(path As String, Optional ext As String) As Dictionary
Dim fldr As Folder
Dim f As file
Set IOL_M_listFiles = New Dictionary
With New FileSystemObject
    If .FolderExists(path) Then
        Set fldr = .getFolder(path)
        If ext <> vbNullString Then
            For Each f In fldr.Files
                If InStr(1, f.name, ext) > 0 Then
                    IOL_M_listFiles.Add f.name, f.path
                End If
            Next f
        Else
            For Each f In fldr.Files
                    IOL_M_listFiles.Add f.name, f.path
            Next f
        End If
    End If
End With

End Function

'eliminate all files in the paths, paths can include directories.  only files in directories will be
'recursively removed, with the directories left unharmed.
Public Function IOL_M_wipeFiles(ParamArray paths()) As Boolean
Dim path As String
Dim p
Dim dir As Folder
Dim fl As file
Dim fldr As Folder
Dim success As Boolean

With New FileSystemObject
    For Each p In paths
        path = CStr(p)
        If .fileExists(path) Then
            .DeleteFile path
        ElseIf .FolderExists(path) Then
            Set dir = .getFolder(path)
            For Each fl In dir.Files
                fl.Delete
            Next fl
            For Each fldr In dir.SubFolders
                success = IOL_M_wipeFiles(fldr.path)
            Next fldr
        End If
    Next p
End With
        
IOL_M_wipeFiles = success
End Function
'eliminate the entire directory structure, including files.
Public Sub IOL_M_wipeAll(ParamArray paths())
Dim path As String
Dim p
Dim dir As Folder
Dim fl As file
Dim fldr As Folder

With New FileSystemObject
    For Each p In paths
        path = CStr(p)
        If .fileExists(path) Then
            .DeleteFile path
        ElseIf .FolderExists(path) Then
            .DeleteFolder path
        End If
    Next p
End With
        
End Sub

Public Sub IOL_M_writeFiles(kvps As Dictionary)

End Sub
Public Function IOL_M_getPath() As String
getPath = ActiveWorkbook.path & "\"
End Function
Public Function IOL_M_createFolders(path As String) As String
Dim tmp
Dim i
Dim current As String
tmp = Split(path, "\")
current = tmp(0)

With New FileSystemObject
    For i = 1 To UBound(tmp, 1) - 1
        current = current & "\" & CStr(tmp(i))
        If Not .FolderExists(current) Then
            Call .CreateFolder(current)
        End If
    Next i
    'Tom change 6 Nov 2012...
    If Not hasExtension(CStr(tmp(i))) Then
        current = current & "\" & CStr(tmp(i))
        If Not .FolderExists(current) Then
            Call .CreateFolder(current)
        End If
    End If
End With
IOL_M_createFolders = path

End Function
Public Function IOL_M_hasExtension(path As String) As Boolean
IOL_M_hasExtension = InStr(1, path, ".")
End Function
Public Function IOL_M_getFolder(path As String) As String

With New FileSystemObject
    If Not .FolderExists(path) Then getFolder = createFolders(path)
End With

IOL_M_getFolder = path
End Function

Public Function IOL_M_emptyFolder(path As String) As String
With New FileSystemObject
    If Not .FolderExists(path) Then
        createFolders (path)
    Else
        wipeFiles (path)
    End If
End With
IOL_M_emptyFolder = path
End Function

Public Function IOL_M_newFolder(path As String) As String
With New FileSystemObject
    If Not .FolderExists(path) Then
        .CreateFolder path
    Else
        .DeleteFolder path
        .CreateFolder path
    End If
End With
IOL_M_newFolder = path

End Function


'ISQ_C_  ISeq

'An interface for operating on sequences.  Unfortunately, we don't have laziness or other nice things in
'vba, but we can build some things that help when manipulating sequences of things.
'This is a hackish implementation of Clojure's ISeq, or .Net's IEnumerable.

'Option Explicit 'ISQ_C_  ISeq

Public Property Get ISQ_C_fst() As Variant
End Property

Public Property Get ISQ_C_nxt() As ISeq
End Property

Public Function ISQ_C_more() As ISeq
End Function

Public Function ISQ_C_cons(ByRef o As Variant) As ISeq
End Function

Public Function ISQ_C_count() As Long
End Function

Public Function ISQ_C_seq() As ISeq
End Function


'ISZ_C_ ISerializable

'A simple interface, for use in defining objects that can serialize to and from string-based formats.
'I haven't really used toFile or fromFile yet, but there might be binary serialization formats at
'some point, where this would be useful, or custom serialization dependent on file type.
'For now, 99% of the serialization is handle by the pickle and unpickle functions in the
'Serialization module.  This interface is tied heavily to that module.
'Option Explicit 'ISZ_C_ ISerializable
'instantiate a serializable object from a string
Public Sub ISZ_C_FromString(code As String)
End Sub
'convert a serializable object to its string representation
Public Function ISZ_C_asString() As String
End Function
'write a serialized object to a resource path....usually a file.
Public Sub ISZ_C_toFile(path As String)
End Sub
'read a serialized object from a resource path...usually a file.
Public Sub ISZ_C_fromFile(path As String)
End Sub
'added this for our complex classes.  everything can be built from a dictionary.
Public Sub ISZ_C_fromDictionary(indict As Dictionary)
End Sub


'ITA_C  IteratorArray

'Option Explicit 'ITA_C_ IteratorArray


Public idx As Long
Public source As Collection

'Implements IFn

Public Sub ITA_C_reset()
idx = 0
End Sub
Public Function ITA_C_getNext() As Variant
If idx + 1 <= source.count Then
    idx = idx + 1
    bind ITA_C_getNext, source(idx)
Else
    Set ITA_C_getNext = Nothing
End If

End Function

Private Sub ITA_C_Class_Terminate()
Set source = Nothing
End Sub

Private Function ITA_C_IFn_apply(args As Collection) As Variant
bind IFn_apply, getNext()
End Function


'ITC_C  IteratorColl

Option Explicit 'ITC_C_  IteratorColl

Public idx As Long
Public source As Collection

'Implements IFn

Public Sub ITC_C_reset()
idx = 0
End Sub
Public Function ITC_C_getNext() As Variant
If idx + 1 <= source.count Then
    idx = idx + 1
    bind ITC_C_getNext, source(idx)
Else
    Set ITC_C_getNext = Nothing
End If

End Function

Private Sub ITC_C_Class_Terminate()
Set source = Nothing
End Sub

Private Function ITC_C_IFn_apply(args As Collection) As Variant
bind ITC_C_IFn_apply, ITC_C_getNext()
End Function


'ITN_C  IteratorConc

'An iterator for seqs that builds concatenations.  It concatenates two sequences, producing
'a stream of cons cells that exhausts the first sequence, then the second.
'Option Explicit 'ITN_C_  IteratorConc

Private myseq As ISeq
Private moreseqs As ISeq

'Implements IFn

Public Sub ITN_C_create(sequences As ISeq)
Set myseq = SeqLib.lazyseq(seq(sequences.fst))
Set moreseqs = SeqLib.lazyseq(sequences.more)

End Sub
'returns cons cells
'This guy iterates over any seq.
Public Function ITN_C_getNext() As Variant 'return a lazy list.

If exists(myseq) Then
    bind ITN_C_getNext, myseq.fst
    Set myseq = myseq.more
    If Not exists(myseq) Then
        Set myseq = moreseqs.fst  'advance to the next sequence.
        Set moreseqs = moreseqs.more 'pop the next sequence off...
    End If
End If

End Function


Private Function ITN_C_IFn_apply(args As Collection) As Variant
bind ITN_C_IFn_apply, ITY_C_getNext()
End Function


'ITT_C  IteratorConstant
'An iterator that produces the same value, or repeatedly evaluates an expression.
'Never ends...
Option Explicit 'ITT_C_  IteratorConstant
Private myval As Variant
Private myfunc As IFn
Private isfunc As Boolean
'Implements IFn
Public Sub ITT_C_repeatVal(ByRef inval As Variant)
bind myval, inval
isfunc = False
End Sub
Public Sub ITT_C_repeatedlyFunc(ByRef infunc As IFn)
Set myfunc = infunc
isfunc = True
End Sub
'returns cons cells
'This guy iterates over any seq.
Public Function ITT_C_getNext() As Variant 'return a lazy list.

If isfunc = False Then
    bind ITT_C_getNext, myval
Else
    bind ITT_C_getNext, myfunc.apply(CollectionLib.getEmptyList())
End If

End Function

Private Function ITT_C_IFn_apply(args As Collection) As Variant
If isfunc = False Then
    bind ITT_C_IFn_apply, myval
Else
    bind ITT_C_IFn_apply, myfunc.apply(CollectionLib.getEmptyList())
End If
End Function


'ITY_C_ IteratorDict

'Option Explicit ''ITY_C_ IteratorDict

Public idx As Long
Public source As Dictionary

'Implements IFn

Public Sub ITY_C_reset()
idx = 0
End Sub
Public Function ITY_C_getNext() As Variant
If idx + 1 <= source.count Then
    idx = idx + 1
    bind ITY_C_getNext, source(idx)
Else
    Set ITY_C_getNext = Nothing
End If

End Function

Private Sub ITY_C_Class_Terminate()
Set source = Nothing
End Sub

Private Function ITY_C_IFn_apply(args As Collection) As Variant
bind ITY_C_IFn_apply, ITY_C_getNext()
End Function

'ITZ_C  IteratorSeq_Z

'An iterator for seqs that lazily generates cons cells, that is, consumers of the sequence
'receive values on-demand.
Option Explicit 'ITZ_C_  IteratorSeq_Z

Private myseq As ISeq
Private remaining As Long
Private drop As Long
Private filter As IFn
Private takewhile As Boolean
Private mapFn As IFn

'Implements IFn

Public Sub ITZ_C_create(s As ISeq, Optional todrop As Long, Optional totake As Long, _
                        Optional fltr As IFn, Optional tw As Boolean, Optional mapf As IFn)
Set myseq = s
drop = todrop

Set filter = fltr
If totake > 0 Then
    remaining = totake
Else
    remaining = -99 'exhaust list
End If

takewhile = tw

Set mapFn = mapf

End Sub
'returns cons cells
'This guy iterates over any seq.
Public Function ITZ_C_getNext() As Variant 'return a lazy list.
Dim link As ISeq

If drop > 0 Then
    Do
        If exists(myseq) And drop > 0 Then
            Set myseq = myseq.more
            drop = drop - 1
        Else
            drop = 0
            Exit Do
        End If
    Loop
End If

If remaining > 0 Then
    If exists(myseq) Then
        If exists(filter) Then
            Do
                If exists(myseq) Then
                    If filter.apply(list(myseq.fst)) = False Then
                        If takewhile Then
                            Set myseq = Nothing
                            remaining = 0
                            Exit Do
                        Else
                            Set myseq = myseq.more
                        End If
                    Else
                        Exit Do
                    End If
                Else
                    Exit Do
                End If
            Loop
        End If
        If exists(myseq) Then
            bind ITZ_C_getNext, myseq.fst
            Set myseq = myseq.more
            remaining = remaining - 1
        End If
    Else
        remaining = 0
    End If
ElseIf remaining = -99 Then
    If exists(myseq) Then
        If exists(filter) Then
            Do
                If exists(myseq) Then
                    If filter.apply(list(myseq.fst)) = False Then
                        If takewhile Then
                            Set myseq = Nothing
                            remaining = 0
                            Exit Do
                        Else
                            Set myseq = myseq.more
                        End If
                    Else
                        Exit Do
                    End If
                Else
                    Exit Do
                End If
            Loop
            If exists(myseq) Then
                bind getNext, myseq.fst
                Set myseq = myseq.more
            End If
        Else
            bind ITZ_C_getNext, myseq.fst 'realizes a val, passes the generator
            Set myseq = myseq.more
        End If
    Else
        remaining = 0
    End If
Else
    Set myseq = Nothing 'let the seq get garbage collected.
End If

End Function

Private Function ITZ_C_IFn_apply(args As Collection) As Variant
Dim res As Variant
bind res, ITZ_C_getNext()
If Not (mapFn Is Nothing) Then
    If Not nil(res) Then
        bind ITZ_C_IFn_apply, mapFn.apply(list(res))
    Else
        bind ITZ_C_IFn_apply, res
    End If
Else
    bind ITZ_C_IFn_apply, res
End If

End Function

'JSP_C_  JSONParser

'Tom note -> This is an external lib.  Not my favorite coding conventions...might port it.
'I moved the original code from a VB6 module into a class, and adapted some of the sinew.  Notably,
'this class is fairly well wrapped behind a generic serialization module, called, Serialization.
'However, you can just as easily use it by itself.  It depends on the StringBuilder class for
'fast string building (really fast actually).

' VBJSON is a VB6 adaptation of the VBA JSON project at http://code.google.com/p/vba-json/
' Some bugs fixed, speed improvements added for VB6 by Michael Glaser (vbjson@ediy.co.nz)
' BSD Licensed

'Option Explicit ''JSP_C_  JSONParser



Private Const INVALID_JSON      As Long = 1
Private Const INVALID_OBJECT    As Long = 2
Private Const INVALID_ARRAY     As Long = 3
Private Const INVALID_BOOLEAN   As Long = 4
Private Const INVALID_NULL      As Long = 5
Private Const INVALID_KEY       As Long = 6
Private Const INVALID_RPC_CALL  As Long = 7

Private psErrors As String

Public Function JSP_C_GetParserErrors() As String
   GetParserErrors = psErrors
End Function

Public Function JSP_C_ClearParserErrors() As String
   psErrors = ""
End Function


'
'   parse string and create JSON object
'
Public Function JSP_C_parse(ByRef str As String) As Object

   Dim index As Long
   index = 1
   psErrors = ""
   On Error Resume Next
   Call skipChar(str, index)
   Select Case Mid(str, index, 1)
      Case "{"
         Set JSP_C_parse = parseObject(str, index)
      Case "["
         Set JSP_C_parse = parseArray(str, index)
      Case Else
         psErrors = "Invalid JSON"
   End Select


End Function

 '
 '   parse collection of key/value
 '
Private Function JSP_C_parseObject(ByRef str As String, ByRef index As Long) As Dictionary

   Set parseObject = New Dictionary
   Dim sKey As String
   
   ' "{"
   Call JSP_C_skipChar(str, index)
   If Mid(str, index, 1) <> "{" Then
      psErrors = psErrors & "Invalid Object at position " & index & " : " & Mid(str, index) & vbCrLf
      Exit Function
   End If
   
   index = index + 1

   Do
      Call skipChar(str, index)
      If "}" = Mid(str, index, 1) Then
         index = index + 1
         Exit Do
      ElseIf "," = Mid(str, index, 1) Then
         index = index + 1
         Call JSP_C_skipChar(str, index)
      End If

      
      ' add key/value pair
      sKey = parseKey(str, index)
      On Error Resume Next
      
      JSP_C_parseObject.Add sKey, parseValue(str, index)
      If Err.number <> 0 Then
         psErrors = psErrors & Err.Description & ": " & sKey & vbCrLf
         Exit Do
      End If
   Loop
eh:

End Function

'
'   parse list
'
Private Function JSP_C_parseArray(ByRef str As String, ByRef index As Long) As Collection

   Set JSP_C_parseArray = New Collection

   ' "["
   Call skipChar(str, index)
   If Mid(str, index, 1) <> "[" Then
      psErrors = psErrors & "Invalid Array at position " & index & " : " + Mid(str, index, 20) & vbCrLf
      Exit Function
   End If
   
   index = index + 1

   Do

      Call skipChar(str, index)
      If "]" = Mid(str, index, 1) Then
         index = index + 1
         Exit Do
      ElseIf "," = Mid(str, index, 1) Then
         index = index + 1
         Call JSP_C_skipChar(str, index)
      End If

      ' add value
      On Error Resume Next
      JSP_C_parseArray.Add parseValue(str, index)
      If Err.number <> 0 Then
         psErrors = psErrors & Err.Description & ": " & Mid(str, index, 20) & vbCrLf
         Exit Do
      End If
   Loop

End Function

'
'   parse string / number / object / array / true / false / null
'
Private Function JSP_C_parseValue(ByRef str As String, ByRef index As Long)

   Call skipChar(str, index)

   Select Case Mid(str, index, 1)
      Case "{"
         Set JSP_C_parseValue = parseObject(str, index)
      Case "["
         Set JSP_C_parseValue = parseArray(str, index)
      Case """", "'"
         JSP_C_parseValue = parseString(str, index)
      Case "t", "f"
         JSP_C_parseValue = parseBoolean(str, index)
      Case "n"
         JSP_C_parseValue = parseNull(str, index)
      Case Else
         JSP_C_parseValue = parseNumber(str, index)
   End Select

End Function

'
'   parse string
'
Private Function JSP_C_parseString(ByRef str As String, ByRef index As Long) As String

   Dim quote   As String
   Dim Char    As String
   Dim code    As String

   Dim sb As New StringBuilder

   Call skipChar(str, index)
   quote = Mid(str, index, 1)
   index = index + 1
   
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      Select Case (Char)
         Case "\"
            index = index + 1
            Char = Mid(str, index, 1)
            Select Case (Char)
               Case """", "\", "/", "'"
                  sb.append Char
                  index = index + 1
               Case "b"
                  sb.append vbBack
                  index = index + 1
               Case "f"
                  sb.append vbFormFeed
                  index = index + 1
               Case "n"
                  sb.append vbLf
                  index = index + 1
               Case "r"
                  sb.append vbCr
                  index = index + 1
               Case "t"
                  sb.append vbTab
                  index = index + 1
               Case "u"
                  index = index + 1
                  code = Mid(str, index, 4)
                  sb.append ChrW(val("&h" + code))
                  index = index + 4
            End Select
         Case quote
            index = index + 1
            
            JSP_C_parseString = sb.toString
            Set sb = Nothing
            
            Exit Function
            
         Case Else
            sb.append Char
            index = index + 1
      End Select
   Loop
   
   JSP_C_parseString = sb.toString
   Set sb = Nothing
   
End Function

'
'   parse number
'
Private Function JSP_C_parseNumber(ByRef str As String, ByRef index As Long)

   Dim value   As String
   Dim Char    As String

   Call skipChar(str, index)
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      If InStr("+-0123456789.eE", Char) Then
         value = value & Char
         index = index + 1
      Else
         If InStr(value, ".") Or InStr(value, "e") Or InStr(value, "E") Then
            JSP_C_parseNumber = CDbl(value)
         Else
            JSP_C_parseNumber = CLng(value)
         End If
         Exit Function
      End If
   Loop
End Function

'
'   parse true / false
'
Private Function JSP_C_parseBoolean(ByRef str As String, ByRef index As Long) As Boolean

   Call skipChar(str, index)
   If Mid(str, index, 4) = "true" Then
      JSP_C_parseBoolean = True
      index = index + 4
   ElseIf Mid(str, index, 5) = "false" Then
      JSP_C_parseBoolean = False
      index = index + 5
   Else
      psErrors = psErrors & "Invalid Boolean at position " & index & " : " & Mid(str, index) & vbCrLf
   End If

End Function

'
'   parse null
'
Private Function JSP_C_parseNull(ByRef str As String, ByRef index As Long)

   Call skipChar(str, index)
   If Mid(str, index, 4) = "null" Then
      JSP_C_parseNull = Null
      index = index + 4
   Else
      psErrors = psErrors & "Invalid null value at position " & index & " : " & Mid(str, index) & vbCrLf
   End If

End Function

Private Function JSP_C_parseKey(ByRef str As String, ByRef index As Long) As String

   Dim dquote  As Boolean
   Dim squote  As Boolean
   Dim Char    As String

   Call skipChar(str, index)
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      Select Case (Char)
         Case """"
            dquote = Not dquote
            index = index + 1
            If Not dquote Then
               Call skipChar(str, index)
               If Mid(str, index, 1) <> ":" Then
                  psErrors = psErrors & "Invalid Key at position " & index & " : " & parseKey & vbCrLf
                  Exit Do
               End If
            End If
         Case "'"
            squote = Not squote
            index = index + 1
            If Not squote Then
               Call skipChar(str, index)
               If Mid(str, index, 1) <> ":" Then
                  psErrors = psErrors & "Invalid Key at position " & index & " : " & parseKey & vbCrLf
                  Exit Do
               End If
            End If
         Case ":"
            index = index + 1
            If Not dquote And Not squote Then
               Exit Do
            Else
               JSP_C_parseKey = parseKey & Char
            End If
         Case Else
            If InStr(vbCrLf & vbCr & vbLf & vbTab & " ", Char) Then
            Else
               JSP_C_parseKey = parseKey & Char
            End If
            index = index + 1
      End Select
   Loop

End Function

'
'   skip special character
'
Private Sub JSP_C_skipChar(ByRef str As String, ByRef index As Long)
   Dim bComment As Boolean
   Dim bStartComment As Boolean
   Dim bLongComment As Boolean
   Do While index > 0 And index <= Len(str)
      Select Case Mid(str, index, 1)
      Case vbCr, vbLf
         If Not bLongComment Then
            bStartComment = False
            bComment = False
         End If
         
      Case vbTab, " ", "(", ")"
         
      Case "/"
         If Not bLongComment Then
            If bStartComment Then
               bStartComment = False
               bComment = True
            Else
               bStartComment = True
               bComment = False
               bLongComment = False
            End If
         Else
            If bStartComment Then
               bLongComment = False
               bStartComment = False
               bComment = False
            End If
         End If
         
      Case "*"
         If bStartComment Then
            bStartComment = False
            bComment = True
            bLongComment = True
         Else
            bStartComment = True
         End If
         
      Case Else
         If Not bComment Then
            Exit Do
         End If
      End Select
      
      index = index + 1
   Loop

End Sub

Public Function JSP_C_toString(ByRef obj As Variant) As String
   Dim sb As New StringBuilder
   Select Case vartype(obj)
      Case vbNull
         sb.append "null"
      Case vbDate
         sb.append """" & CStr(obj) & """"
      Case vbString
         sb.append """" & Encode(obj) & """"
      Case vbObject
         
         Dim bFI As Boolean
         Dim i As Long
         Dim tname As String
         
         tname = TypeName(obj)
         
         bFI = True
         Select Case tname
            Case "Dictionary"
                sb.append "{"
                Dim keys
                keys = obj.keys
                For i = 0 To obj.count - 1
                   If bFI Then bFI = False Else sb.append ","
                   Dim key
                   key = keys(i)
                   sb.append """" & key & """:" & toString(obj.Item(key))
                Next i
                sb.append "}"
             Case "Collection"
                sb.append "["
                Dim value
                For Each value In obj
                   If bFI Then bFI = False Else sb.append ","
                   sb.append toString(value)
                Next value
                sb.append "]"
            'TOM Change 6 Sep 2012
            Case "ISeq", "SeqConsCell", "SeqConsLazy"
                    sb.append "["
                    Dim nd As ISeq
                    Set nd = obj
                    While exists(nd)
                        sb.append toString(nd.fst)
                        Set nd = nd.more
                        If bFI Then bFI = False Else sb.append ","
                    Wend
                    sb.append "]"
            'Tom change 7 Nov 2012
            Case Else
                sb.append trySerialize(obj)
        End Select
      Case vbBoolean
         If obj Then sb.append "true" Else sb.append "false"
      Case vbVariant, vbArray, vbArray + vbVariant
         Dim sEB
         sb.append multiArray(obj, 1, "", sEB)
      Case Else
         sb.append replace(obj, ",", ".")
   End Select

   JSP_C_toString = sb.toString
   Set sb = Nothing
   
End Function

Private Function JSP_C_Encode(str) As String

   Dim sb As New StringBuilder
   Dim i As Long
   Dim j As Long
   Dim aL1 As Variant
   Dim aL2 As Variant
   Dim c As String
   Dim p As Boolean

   aL1 = Array(&H22, &H5C, &H2F, &H8, &HC, &HA, &HD, &H9)
   aL2 = Array(&H22, &H5C, &H2F, &H62, &H66, &H6E, &H72, &H74)
   For i = 1 To Len(str)
      p = True
      c = Mid(str, i, 1)
      For j = 0 To 7
         If c = Chr(aL1(j)) Then
            sb.append "\" & Chr(aL2(j))
            p = False
            Exit For
         End If
      Next

      If p Then
         Dim a
         a = AscW(c)
         If a > 31 And a < 127 Then
            sb.append c
         ElseIf a > -1 Or a < 65535 Then
            sb.append "\u" & String(4 - Len(Hex(a)), "0") & Hex(a)
         End If
      End If
   Next
   
   JSP_C_Encode = sb.toString
   Set sb = Nothing
   
End Function

Private Function JSP_C_multiArray(aBD, iBC, sPS, ByRef SPT)   ' Array BoDy, Integer BaseCount, String PoSition
   
   Dim iDU As Long
   Dim iDL As Long
   Dim i As Long
   
   On Error Resume Next
   iDL = LBound(aBD, iBC)
   iDU = UBound(aBD, iBC)

   Dim sb As New StringBuilder

   Dim sPB1, sPB2  ' String PointBuffer1, String PointBuffer2
   If Err.number = 9 Then
      sPB1 = SPT & sPS
      For i = 1 To Len(sPB1)
         If i <> 1 Then sPB2 = sPB2 & ","
         sPB2 = sPB2 & Mid(sPB1, i, 1)
      Next
      '        multiArray = multiArray & toString(Eval("aBD(" & sPB2 & ")"))
      sb.append toString(aBD(sPB2))
   Else
      SPT = SPT & sPS
      sb.append "["
      For i = iDL To iDU
         sb.append multiArray(aBD, iBC + 1, i, SPT)
         If i < iDU Then sb.append ","
      Next
      sb.append "]"
      SPT = left(SPT, iBC - 2)
   End If
   Err.Clear
   multiArray = sb.toString
   
   Set sb = Nothing
End Function

' Miscellaneous JSON functions

Public Function JSP_C_StringToJSON(st As String) As String
   
   Const FIELD_SEP = "~"
   Const RECORD_SEP = "|"

   Dim sFlds As String
   Dim sRecs As New StringBuilder
   Dim lRecCnt As Long
   Dim lFld As Long
   Dim fld As Variant
   Dim rows As Variant

   lRecCnt = 0
   If st = "" Then
      StringToJSON = "null"
   Else
      rows = Split(st, RECORD_SEP)
      For lRecCnt = LBound(rows) To UBound(rows)
         sFlds = ""
         fld = Split(rows(lRecCnt), FIELD_SEP)
         For lFld = LBound(fld) To UBound(fld) Step 2
            sFlds = (sFlds & IIf(sFlds <> "", ",", "") & """" & fld(lFld) & """:""" & toUnicode(fld(lFld + 1) & "") & """")
         Next 'fld
         sRecs.append IIf((Trim(sRecs.toString) <> ""), "," & vbCrLf, "") & "{" & sFlds & "}"
      Next 'rec
      JSP_C_StringToJSON = ("( {""Records"": [" & vbCrLf & sRecs.toString & vbCrLf & "], " & """RecordCount"":""" & lRecCnt & """ } )")
   End If
End Function

'NOTE: as of 2007, I believe ADODB is screwed up.  Disabled for now. - TOM

'Public Function RStoJSON(rs As ADODB.Recordset) As String
'   On Error GoTo errHandler
'   Dim sFlds As String
'   Dim sRecs As New cStringBuilder
'   Dim lRecCnt As Long
'   Dim fld As ADODB.field
'
'   lRecCnt = 0
'   If rs.state = adStateClosed Then
'      RStoJSON = "null"
'   Else
'      If rs.EOF Or rs.BOF Then
'         RStoJSON = "null"
'      Else
'         Do While Not rs.EOF And Not rs.BOF
'            lRecCnt = lRecCnt + 1
'            sFlds = ""
'            For Each fld In rs.fields
'               sFlds = (sFlds & IIf(sFlds <> "", ",", "") & """" & fld.name & """:""" & toUnicode(fld.Value & "") & """")
'            Next 'fld
'            sRecs.Append IIf((Trim(sRecs.toString) <> ""), "," & vbCrLf, "") & "{" & sFlds & "}"
'            rs.moveNext
'         Loop
'         RStoJSON = ("( {""Records"": [" & vbCrLf & sRecs.toString & vbCrLf & "], " & """RecordCount"":""" & lRecCnt & """ } )")
'      End If
'   End If
'
'   Exit Function
'errHandler:
'
'End Function

'Public Function JsonRpcCall(url As String, methName As String, args(), Optional user As String, Optional pwd As String) As Object
'    Dim r As Object
'    Dim cli As Object
'    Dim pText As String
'    Static reqId As Integer
'
'    reqId = reqId + 1
'
'    Set r = CreateObject("Scripting.Dictionary")
'    r("jsonrpc") = "2.0"
'    r("method") = methName
'    r("params") = args
'    r("id") = reqId
'
'    pText = toString(r)
'
'    Set cli = CreateObject("MSXML2.XMLHTTP.6.0")
'   ' Set cli = New MSXML2.XMLHTTP60
'    If Len(user) > 0 Then   ' If Not IsMissing(user) Then
'        cli.Open "POST", url, False, user, pwd
'    Else
'        cli.Open "POST", url, False
'    End If
'    cli.setRequestHeader "Content-Type", "application/json"
'    cli.Send pText
'
'    If cli.Status <> 200 Then
'        Err.Raise vbObjectError + INVALID_RPC_CALL + cli.Status, , cli.statusText
'    End If
'
'    Set r = parse(cli.responseText)
'    Set cli = Nothing
'
'    If r("id") <> reqId Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response id"
'
'    If r.Exists("error") Or Not r.Exists("result") Then
'        Err.Raise vbObjectError + INVALID_RPC_CALL, , "Json-Rpc Response error: " & r("error")("message")
'    End If
'
'    If Not r.Exists("result") Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response, missing result"
'
'    Set JsonRpcCall = r("result")
'End Function




Public Function JSP_C_toUnicode(str As String) As String

   Dim x As Long
   Dim uStr As New StringBuilder
   Dim uChrCode As Integer

   For x = 1 To Len(str)
      uChrCode = Asc(Mid(str, x, 1))
      Select Case uChrCode
         Case 8:   ' backspace
            uStr.append "\b"
         Case 9: ' tab
            uStr.append "\t"
         Case 10:  ' line feed
            uStr.append "\n"
         Case 12:  ' formfeed
            uStr.append "\f"
         Case 13: ' carriage return
            uStr.append "\r"
         Case 34: ' quote
            uStr.append "\"""
         Case 39:  ' apostrophe
            uStr.append "\'"
         Case 92: ' backslash
            uStr.append "\\"
         Case 123, 125:  ' "{" and "}"
            uStr.append ("\u" & right("0000" & Hex(uChrCode), 4))
         Case Is < 32, Is > 127: ' non-ascii characters
            uStr.append ("\u" & right("0000" & Hex(uChrCode), 4))
         Case Else
            uStr.append Chr$(uChrCode)
      End Select
   Next
   JSP_C_ toUnicode = uStr.toString
   Exit Function

End Function

Private Sub JSP_C_Class_Initialize()
   psErrors = ""
End Sub


'JSS_C_ JSONScript

'Borrowed from VB-JSON at:
'http://www.ediy.co.nz/vbjson-json-parser-library-in-vb6-xidc55680.html
' VBJSON is a VB6 adaptation of the VBA JSON project at http://code.google.com/p/vba-json/
' Some bugs fixed, speed improvements added for VB6 by Michael Glaser (vbjson@ediy.co.nz)
' BSD Licensed

'I don't really use this class as of yet, since most of my JSON needs are met via serialization stuff.

'Option Explicit 'JSS_C_ JSONScript

Dim dictVars As New Dictionary
Dim plNestCount As Long


Public Function JSS_C_EVAL(JSON As JSONParser, sJSON As String) As String
   Dim sb As New StringBuilder
   Dim o As Object
   Dim c As Object
   Dim i As Long
   
   Set o = JSON.parse(sJSON)
   If (JSON.GetParserErrors = "") And Not (o Is Nothing) Then
      For i = 1 To o.count
         Select Case vartype(o.Item(i))
         Case vbNull
            sb.append "null"
         Case vbDate
            sb.append CStr(o.Item(i))
         Case vbString
            sb.append CStr(o.Item(i))
         Case Else
            Set c = o.Item(i)
            sb.append ExecCommand(c)
         End Select
      Next
   Else
      MsgBox JSON.GetParserErrors, vbExclamation, "Parser Error"
   End If
   JSS_C_EVAL = sb.toString
End Function

Public Function JSS_C_ExecCommand(ByRef obj As Variant) As String
   Dim sb As New StringBuilder
   
   If plNestCount > 40 Then
      ExecCommand = "ERROR: Nesting level exceeded."
   Else
      plNestCount = plNestCount + 1
      
      Select Case vartype(obj)
         Case vbNull
            sb.append "null"
         Case vbDate
            sb.append CStr(obj)
         Case vbString
            sb.append CStr(obj)
         Case vbObject
            
            Dim i As Long
            Dim j As Long
            Dim this As Object
            Dim key
            Dim paramKeys
            
            If TypeName(obj) = "Dictionary" Then
               Dim sOut As String
               Dim sRet As String
   
               Dim keys
               keys = obj.keys
               For i = 0 To obj.count - 1
                  sRet = ""
             
                  key = keys(i)
                  If vartype(obj.Item(key)) = vbString Then
                     sRet = obj.Item(key)
                  Else
                     Set this = obj.Item(key)
                  End If
                  
                  ' command implementation
                  Select Case LCase(key)
                  Case "alert":
                     MsgBox ExecCommand(this.Item("message")), vbInformation, ExecCommand(this.Item("title"))
                     
                  Case "input":
                     sb.append InputBox(ExecCommand(this.Item("prompt")), ExecCommand(this.Item("title")), ExecCommand(this.Item("default")))
                     
                  Case "switch"
                     sOut = ExecCommand(this.Item("default"))
                     sRet = LCase(ExecCommand(this.Item("case")))
                     For j = 0 To this.Item("items").count - 1
                        If LCase(this.Item("items").Item(j + 1).Item("case")) = sRet Then
                           sOut = ExecCommand(this.Item("items").Item(j + 1).Item("return"))
                           Exit For
                        End If
                     Next
                     sb.append sOut
                  
                  Case "set":
                     If dictVars.exists(this.Item("name")) Then
                        dictVars.Item(this.Item("name")) = ExecCommand(this.Item("value"))
                     Else
                        dictVars.Add this.Item("name"), ExecCommand(this.Item("value"))
                     End If
                     
                  Case "get":
                     sRet = ExecCommand(dictVars(CStr(this.Item("name"))))
                     If sRet = "" Then
                        sRet = ExecCommand(this.Item("default"))
                     End If
                     
                     sb.append sRet
                     
                  Case "if"
                     Dim val1 As String
                     Dim val2 As String
                     Dim bRes As Boolean
                     val1 = ExecCommand(this.Item("value1"))
                     val2 = ExecCommand(this.Item("value2"))
                     
                     bRes = False
                     Select Case LCase(this.Item("type"))
                     Case "eq" ' =
                        If LCase(val1) = LCase(val2) Then
                           bRes = True
                        End If
                        
                     Case "gt" ' >
                        If val1 > val2 Then
                           bRes = True
                        End If
                     
                     Case "lt" ' <
                        If val1 < val2 Then
                           bRes = True
                        End If
                     
                     Case "gte" ' >=
                        If val1 >= val2 Then
                           bRes = True
                        End If
                     
                     Case "lte" ' <=
                        If val1 <= val2 Then
                           bRes = True
                        End If
                     
                     End Select
                     
                     If bRes Then
                        sb.append ExecCommand(this.Item("true"))
                     Else
                        sb.append ExecCommand(this.Item("false"))
                     End If
                     
                  Case "return"
                     sb.append obj.Item(key)
                  
                     
                  Case Else
                     If TypeName(this) = "Dictionary" Then
                        paramKeys = this.keys
                        For j = 0 To this.count - 1
                           If j > 0 Then
                              sRet = sRet & ","
                           End If
                           sRet = sRet & CStr(this.Item(paramKeys(j)))
                        Next
                     End If
                     
                     
                     sb.append "<%" & UCase(key) & "(" & sRet & ")%>"
                     
                  End Select
               Next i
               
            ElseIf TypeName(obj) = "Collection" Then
   
               Dim value
               For Each value In obj
                  sb.append ExecCommand(value)
               Next value
               
            End If
            Set this = Nothing
   
         Case vbBoolean
            If obj Then sb.append "true" Else sb.append "false"
         
         Case vbVariant, vbArray, vbArray + vbVariant
         
         Case Else
            sb.append replace(obj, ",", ".")
      End Select
      plNestCount = plNestCount - 1
   End If
   
   JSS_C_ExecCommand = sb.toString
   Set sb = Nothing
   
End Function


'LEC_M  LibEnumsAndConstants


'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'Integrated 29 Aug 2012
'Option Explicit 'LEC_M  LibEnumsAndConstants

Public Const inf As Single = 999999999
Public Const infinite As Single = inf
Public Const infLong As Long = 999999999
Public Const infnegative As Single = -999999999


Public Function LEC_M_parseInf(inval) As Single
Select Case CStr(inval)
    Case "inf", "inf+"
        LEC_M_parseInf = LibEnumsAndConstants.inf
    Case "infnegative", "inf-"
        LEC_M_parseInf = LibEnumsAndConstants.infnegative
    Case Else
        LEC_M_parseInf = CSng(inval)
End Select
        

End Function

'LIC_C_  LispClosure

'Option Explicit 'LIC_C_  LispClosure

'
'public class Closure extends Procedure {
'
'    Object parms;
'    Object body;
'    Environment env;
'
'    /** Make a closure from a parameter list, body, and environment. **/
'    public Closure (Object parms, Object body, Environment env) {
'        this.parms = parms;
'    this.env = env;
'    this.body = (body instanceof Pair && rest(body) == null)
'        Print first(body)
'        : cons("begin", body);
'    }
'
'    /** Apply a closure to a list of arguments.  **/
'    public Object apply(Scheme interpreter, Object args) {
'    return interpreter.eval(body, new Environment(parms, args, env));
'    }
'}

Public name As String

Public params As Collection
Public body As Variant
Public env As Dictionary
'Implements IFn

Public Function LIC_C_apply(args As Collection) As Variant
bind apply, Lisp.EVAL(body, makeEnvironment(params, args, env))
End Function

Private Sub LIC_C_Class_Initialize()
name = "Anonymous Function"
End Sub


Private Function LIC_C_IFn_apply(args As Collection) As Variant
bind IFn_apply, apply(args)
End Function

'LIE_M  LispExcelInterop

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

Option Explicit 'LIE_M_  LispExcelInterop

'Allow excel formulas to be s-expressions
Function LIE_M_lispFunc(ByRef expr As String, Optional inval As Variant, Optional outval As Variant) As Variant
On Error GoTo clean
Dim args As Collection
If IsMissing(inval) Then
    Set args = list()
Else
    Set args = list(checkRange(inval))
End If
bind LIE_M_lispFunc, apply(EVAL(READ(expr)), args)
Set args = Nothing
Exit Function
clean:
resetLisp
End Function
'Allow results from s-expressions to be serialized...
Sub LIE_M_printRange(inval As Variant)

End Sub

'provide hashed bindings for lisp forms in excel
Function LIE_M_lispVar(ByRef varname As String, ByRef expr As String) As String
With Lisp.getGlobalLispEnv
    If .exists(varname) Then
            .Remove varname
    End If
    .Add varname, EVAL(READ(expr))
End With

LIE_M_lispVar = varname
End Function

'bind a range to a table in the global lisp environment
Function LIE_M_lispTable(inrng As Range) As String

End Function

'LIP_M  LispPrimitive

Option Explicit 'LIP_M  LispPrimitive
    
Public minArgs As Long
Public maxArgs As Long
Public idNumber As Long
Public name As String

Public Enum lispPrimitives
   lEQ = 0
   lLT = 1
   lGT = 2
   lGE = 3
   lLE = 4
   lABS = 5
   lEOMAL_L_OBJECT = 6
   lEQQ = 7
   lEQUALQ = 8
   lFORCE = 9
   lCAR = 10
   lFLOOR = 11
   lCeiling = 12
   lCons = 13
   lDIVIDE = 14
   lLENGTH = 15
   lLIST = 16
   lLISTQ = 17
   lAPPLY = 18
   lMAX = 19
   lMIN = 20
   lMINUS = 21
   lNEWLINE = 22
   lNOT = 23
   lNULLQ = 24
   lNUMBERQ = 25
   lPAIRQ = 26
   lPLUS = 27
   lPROCEDUREQ = 28
   lREAD = 29
   lCDR = 30
   lROUND = 31
   lSECOND = 32
   lSYMBOLQ = 33
   lTIMES = 34
   lTRUNCATE = 35
   lWRITE = 36
   lAPPEND = 37
   lBOOLEANQ = 38
   lSQRT = 39
   lEXPT = 40
   lreverse = 41
   lASSOC = 42
   lASSQ = 43
   lASSV = 44
   lMEMBER = 45
   lMEMQ = 46
   lMEMV = 47
   lEQVQ = 48
   lLISTREF = 49
   lLISTTAIL = 50
   lSTRINQ = 51
   lMAKESTRING = 52
   lSTRING = 53
   lSTRINGLENGTH = 54
   lSTRINGREF = 55
   lSTRINGSET = 56
   lSUBSTRING = 57
   lSTRINGAPPEND = 58
   lSTRINGTOLIST = 59
   lLISTTOSTRING = 60
   lSYMBOLTOSTRING = 61
   lSTRINGTOSYMBOL = 62
   lEXP = 63
   lLOG = 64
   lSIN = 65
   lCOS = 66
   lTAN = 67
   lACOS = 68
   lASIN = 69
   lATAN = 70
   lNUMBERTOSTRING = 71
   lSTRINGTONUMBER = 72
   lCHARQ = 73
   lCHARALPHABETICQ = 74
   lCHARNUMERICQ = 75
   lCHARWHITESPACEQ = 76
   lCHARUPPERCASEQ = 77
   lCHARLOWERCASEQ = 78
   lCHARTOINTEGER = 79
   lINTEGERTOCHAR = 80
   lCHARUPCASE = 81
   lCHARDOWNCASE = 82
   lSTRINGQ = 83
   lVECTORQ = 84
   lMAKEVECTOR = 85
   lVECTOR = 86
   lVECTORLENGTH = 87
   lVECTORREF = 88
   lVECTORSET = 89
   lLISTTOVECTOR = 90
   lMAP = 91
   lFOREACH = 92
   lCALLCC = 93
   lVECTORTOLIST = 94
   lLOAD = 95
   lDISPLAY = 96
   lINPUTPORTQ = 98
   lCURRENTINPUTPORT = 99
   lOPENINPUTFILE = 100
   lCLOSEINPUTPORT = 101
   lOUTPUTPORTQ = 103
   lCURRENTOUTPUTPORT = 104
   lOPENOUTPUTFILE = 105
   lCLOSEOUTPUTPORT = 106
   lREADCHAR = 107
   lPEEKCHAR = 108
   lEVAL = 109
   lQUOTIENT = 110
   lREMAINDER = 111
   lMODULO = 112
   lTHIRD = 113
   lEOFOBJECTQ = 114
   lGCD = 115
   lLCM = 116
   lCXR = 117
   lODDQ = 118
   lEVENQ = 119
   lZEROQ = 120
   lPOSITIVEQ = 121
   lNEGATIVEQ = 122
   lCHARCMP = 123 '/* to 127 */
   lCHARCICMP = 128 '/* to 132 */,
   lSTRINGCMP = 133 '/* to 137 */
   lSTRINGCICMP = 138 '/* to 142 */,
   lEXACTQ = 143
   lINEXACTQ = 144
   lINTEGERQ = 145
   lCALLWITHINPUTFILE = 146
   lCALLWITHOUTPUTFILE = 147
   lNEW = -1
   lCLASS = -2
   lMETHOD = -3
   lEXIT = -4
   lSETCAR = -5
   lSETCDR = -6
   lTIMECALL = -11
   lMACROEXPAND = -12
   lERROR = -13
   lLISTSTART = -14
   'tom stuff
   lREDUCE = -15
   lHASHSET = -16
   lHASHMAP = -17
   lTAKE = -18
   lTAKEWHILE = -19
   lITERATE = -20
   lDROP = -21
   lFIRST = -22
   lREST = -23
   lNEXT = -24
   lLAZYCONS = -25
   lSEQ = -26
   lLAZYSEQ = -27
   lREPEAT = -277
   lREPEATEDLY = -288
   lREADJSON = -28
   lWRITEJSON = -29
   lFILTER = -30
   lCONCAT = -31
   lLAST = -32
   lBUTLAST = -33
   lNTH = -34
   lINC = -35
   lDEC = -36
   lconj = -37
   lRAND = -38
   lRANDINT = -39
   lRANDBETWEEN = -40
   lKEYS = -41
   lVALS = -42
   lGET = -43  'polymorphic function for getting elements from a collection
   lLOADFILE = -44
   lrange = -45
   lsortby = -47
   lsort = -48
End Enum
'Implements IFn

   
'  //////////////// Extensions ////////////////
'
'    static final int NEW = -1, CLASS = -2, METHOD = -3, EXIT = -4,
'      SETCAR = -5, SETCDR = -6, TIMECALL = -11, MACROEXPAND = -12,
'      ERROR = -13, LISTSTAR = -14
'    ;

'/** LIP_M_apply a primitive to a list of arguments. **/
Public Function LIP_M_apply(args As Collection) As Variant
'  //First make sure there are the right number of arguments.
Dim nargs As Long

nargs = args.count
If (nargs < minArgs) Then
    Err.Raise "too few args, " + nargs + ", for " + name + ": " + printstr(args)
ElseIf (nargs > maxArgs) Then
    Err.Raise "too many args, " + nargs + ", for " + name + ": " + printstr(args)
End If

Dim x As Variant
Dim y As Variant

If args.count > 0 Then
        bind x, args(1)
    If args.count > 1 Then
        bind y, args(2)
    End If
End If

Select Case idNumber
    
    '  ////////////////  SECTION 6.1 BOOLEANS
    Case lNOT
        LIP_M_apply = truth(x = False)
    Case lBOOLEANQ
        LIP_M_apply = truth(x = True Or x = False)
    '  ////////////////  SECTION 6.2 EQUIVALENCE PREDICATES
    Case lEQVQ
        'LIP_M_apply = truth(eqv(x, y))
    Case lEQQ
        LIP_M_apply = truth(x = y)
    Case lEQUALQ
        'LIP_M_apply = truth(equal(x, y))
        '
    '////////////////  SECTION 6.3 LISTS AND PAIRS
    Case lPAIRQ
        LIP_M_apply = asCollection(x).count = 2
    Case lLISTQ
        LIP_M_apply = isa(x, "Collection")
'    case CXR:           for (int i = name.length()-2; i >= 1; i--)
'                          x = (name.charAt(i) == 'a') ? first(x) : rest(x);
'                        return x;
'    case CONS:      return cons(x, y);
    Case lCAR
        bind LIP_M_apply, x
    Case lCDR
        'LIP_M_apply = rest(x)
'    case SETCAR:        return setFirst(x, y);
'    case SETCDR:        return setRest(x, y);
    Case lSECOND
        bind LIP_M_apply, SeqLib.nth(1, seq(x))
    Case lTHIRD:
        bind LIP_M_apply, SeqLib.nth(2, seq(x))
    Case lNULLQ
        LIP_M_apply = truth(IsNull(x))
    Case lLIST
        Set LIP_M_apply = args
    Case lLENGTH
        LIP_M_apply = length(x)
    Case lAPPEND
        'args == null) ? null : append(args);
        
    Case lreverse
        Set LIP_M_apply = SeqLib.seqReverse(args)

'    case LISTTAIL:  for (int k = (int)num(y); k>0; k--) x = rest(x);
'                        return x;
'    case LISTREF:   for (int k = (int)num(y); k>0; k--) x = rest(x);
'                        return first(x);
'    case MEMQ:          return memberAssoc(x, y, 'm', 'q');
'    case MEMV:          return memberAssoc(x, y, 'm', 'v');
'    case MEMBER:        return memberAssoc(x, y, 'm', ' ');
'    case ASSQ:          return memberAssoc(x, y, 'a', 'q');
'    case ASSV:          return memberAssoc(x, y, 'a', 'v');
'    case ASSOC:         return memberAssoc(x, y, 'a', ' ');

'      ////////////////  SECTION 6.4 SYMBOLS
    Case lSYMBOLQ
        LIP_M_apply = isa(x, "String")
    Case lSYMBOLTOSTRING
        LIP_M_apply = CStr(x) 'sym(x).toCharArray();
    Case lSTRINGTOSYMBOL
        'return new String(str(x)).intern();
'      ////////////////  SECTION 6.5 NUMBERS
    Case lNUMBERQ
        LIP_M_apply = IsNumeric(x)
    Case lODDQ
        LIP_M_apply = Not (Abs(x Mod 2) = 0)
    Case lEVENQ
        LIP_M_apply = Abs(x Mod 2) = 0
    Case lZEROQ
        LIP_M_apply = x = 0
    Case lPOSITIVEQ
        LIP_M_apply = x > 0
    Case lNEGATIVEQ
        LIP_M_apply = x < 0
'    case INTEGERQ:      return truth(isExact(x));
'    case INEXACTQ:      return truth(!isExact(x));
    Case lLT
        LIP_M_apply = x < y
    Case lGT
        LIP_M_apply = x > y
    Case lEQ
        LIP_M_apply = x = y
    Case lLE
        LIP_M_apply = x <= y
    Case lGE
        LIP_M_apply = x >= y
    Case lMAX
        LIP_M_apply = numcompute(args, "X", CSng(x))
    Case lMIN
        LIP_M_apply = numcompute(args, "N", CSng(x))
    Case lPLUS
        LIP_M_apply = numcompute(args, "+", 0#)
    Case lMINUS:
        LIP_M_apply = numcompute(args, "-", 0)
    Case lTIMES
        LIP_M_apply = numcompute(args, "*", 1#)
    Case lDIVIDE
        LIP_M_apply = numcompute(args, "/", 0)
'    case QUOTIENT:      double d = num(x)/num(y);
'                        return num(d > 0 ? Math.floor(d) : Math.ceil(d));
'    case REMAINDER:     return num((long)num(x) % (long)num(y));
'    case MODULO:        long xi = (long)num(x), yi = (long)num(y), m = xi % yi;
'                        return num((xi*yi > 0 || m == 0) ? m : m + yi);
    Case lABS
        LIP_M_apply = Abs(x)
    Case lFLOOR
        'LIP_M_apply = Floor(x)
'    case CEILING:   return num(Math.ceil(num(x)));
'    case TRUNCATE:  d = num(x);
'                        return num((d < 0.0) ? Math.ceil(d) : Math.floor(d));
'    case ROUND:     return num(Math.round(num(x)));
    Case lEXP
        LIP_M_apply = exp(CDbl(x))
    Case lLOG
        LIP_M_apply = log(CDbl(x))
    Case lSIN
        LIP_M_apply = Sin(CDbl(x))
    Case lCOS
        LIP_M_apply = Cos(CDbl(x))
    Case lTAN
        LIP_M_apply = Tan(CDbl(x))
'    case ASIN:          return num(Math.asin(num(x)));
'    case ACOS:          return num(Math.acos(num(x)));
'    case ATAN:          return num(Math.atan(num(x)));
    Case lSQRT
        LIP_M_apply = x ^ 0.5
    Case lEXPT
        LIP_M_apply = x ^ y
'    case NUMBERTOSTRING:return numberToString(x, y);
'    case STRINGTONUMBER:return stringToNumber(x, y);
'    case GCD:           return (args == null) ? ZERO : gcd(args);
'    case LCM:           return (args == null) ? ONE  : lcm(args);


'      ////////////////  SECTION 6.9 CONTROL FEATURES
'    case EVAL:          return interp.eval(x);
'    case FORCE:         return (!(x instanceof Procedure)) ? x
'              : proc(x).LIP_M_apply(interp, null);
    Case lMACROEXPAND
'        bind LIP_M_apply, Macro.macroExpand(interp, x)
    Case lPROCEDUREQ
        LIP_M_apply = truth(TypeName(x) = "IFn")
    Case lLIP_M_apply
        bind LIP_M_apply, Lisp.LIP_M_apply(asFunc(x), restList(args))
    Case lMAP
        bind LIP_M_apply, Lisp.map(asFunc(x), seq(y))
    Case lREDUCE
        If args.count = 3 Then
            bind LIP_M_apply, Lisp.reduce(asFunc(x), y, args(3))
        ElseIf args.count = 2 Then
            bind LIP_M_apply, Lisp.reduce(asFunc(x), , asCollection(y))
        Else
            Err.Raise 101, , "Invalid number of args to reduce!"
        End If
'    case FOREACH:       return map(proc(x), rest(args), interp, null);
'    case CALLCC:        RuntimeException cc = new RuntimeException();
'                        Continuation proc = new Continuation(cc);
'                    try { return proc(x).LIP_M_apply(interp, list(proc)); }
'            catch (RuntimeException e) {
'                if (e == cc) return proc.value; else throw e;
    Case lVECTOR
        bind LIP_M_apply, listToVector(args)
    Case lHASHSET
        bind LIP_M_apply, SetLib.setOfList(args)
    Case lHASHMAP
        bind LIP_M_apply, DictionaryLib.dictOfAList(args)
    Case lREADJSON
        Dim jstring As String
        jstring = CStr(x)
        Select Case firstchar(jstring)
            Case "{"
                bind LIP_M_apply, SerializationLib.JSONtoDictionary(jstring)
            Case "["
                bind LIP_M_apply, SerializationLib.JSONtoCollection(jstring)
            Case Else
                bind LIP_M_apply, SerializationLib.JSONtoPrimitive(jstring)
        End Select
    Case lWRITEJSON
        bind LIP_M_apply, SerializationLib.jParse(x)
    'Sequence operations.
    Case lTAKE
        bind LIP_M_apply, SeqLib.take(CLng(x), seq(y))
    Case lTAKEWHILE
        bind LIP_M_apply, SeqLib.takewhile(asFunc(x), seq(y))
    Case lITERATE
        bind LIP_M_apply, SeqLib.iterate(asFunc(x), y)
    Case lDROP
        bind LIP_M_apply, SeqLib.drop(CLng(x), seq(y))
    Case lFIRST
        bind LIP_M_apply, SeqLib.first(seq(x))
    Case lREST
        bind LIP_M_apply, SeqLib.rest(seq(x))
    Case lNEXT
        bind LIP_M_apply, SeqLib.seqNext(seq(x))
    Case lLAZYCONS
        bind LIP_M_apply, SeqLib.lazyCons(x, asFunc(y))
    Case lSEQ
        bind LIP_M_apply, SeqLib.seq(x)
    Case lFILTER
        bind LIP_M_apply, SeqLib.filter(asFunc(x), seq(y))
    Case lCONCAT
        bind LIP_M_apply, SeqLib.concat(args)
    Case lLAST
        bind LIP_M_apply, SeqLib.last(seq(x))
    Case lBUTLAST = -33
        bind LIP_M_apply, SeqLib.butLast(seq(x))
    Case lNTH
        bind LIP_M_apply, SeqLib.nth(CLng(x), seq(y))
    Case lINC
        bind LIP_M_apply, x + 1
    Case lDEC
        bind LIP_M_apply, x - 1
    Case lconj
        bind LIP_M_apply, SeqLib.conj(seq(x), y)
    Case lRAND
        If nargs = 0 Then
            bind LIP_M_apply, Rnd()
        Else
            bind LIP_M_apply, Rnd() * x
        End If
    Case lRANDINT
        bind LIP_M_apply, CLng(Rnd() * x)
    Case lRANDBETWEEN
        bind LIP_M_apply, CLng(Rnd() * (y - x)) + x
    Case lREPEAT
        bind LIP_M_apply, SeqLib.repeat(x)
    Case lREPEATEDLY
        bind LIP_M_apply, SeqLib.repeatedly(asFunc(x))
    Case lLOADFILE
        bind LIP_M_apply, Lisp.readFile(CStr(x))
    Case lrange
        bind LIP_M_apply, SeqLib.seqRange(CLng(x))
'    Case lREVERSE
'        bind LIP_M_apply, SeqLib.seqReverse
    Case lsortby
        bind LIP_M_apply, SeqLib.seqSortBy(asFunc(x), seq(y))
    Case lsort
        If nil(y) Then
            bind LIP_M_apply, SeqLib.seqSort(seq(x))
        Else
            bind LIP_M_apply, SeqLib.seqSort(seq(x), truth(y))
        End If
    Case lconj
        bind LIP_M_apply, SeqLib.conj(seq(x), y)
End Select
End Function
Private Function LIP_M_numcompare(args As Collection, dir As String)
End Function
Private Function LIP_M_numcompute(args As Collection, op As String, initial As Single) As Single
Dim i As Long

LIP_M_numcompute = initial
Select Case op
    Case "X"
        For i = 1 To args.count
            If LIP_M_numcompute < args(i) Then LIP_M_numcompute = args(i)
        Next i
    Case "N"
        For i = 1 To args.count
            If LIP_M_numcompute > args(i) Then LIP_M_numcompute = args(i)
        Next i
    Case "+"
        For i = 1 To args.count
            LIP_M_numcompute = LIP_M_numcompute + args(i)
        Next i
    Case "-"
        numcompute = fst(args)
        For i = 2 To args.count
            LIP_M_numcompute = LIP_M_numcompute - args(i)
        Next i
    Case "*"
        For i = 1 To args.count
            LIP_M_numcompute = LIP_M_numcompute * args(i)
        Next i
    Case "/"
        numcompute = args(1)
        For i = 2 To args.count
            LIP_M_numcompute = LIP_M_numcompute / args(i)
        Next i
End Select
            
End Function

Private Function LIP_M_length(x As Variant) As Long
If isa(x, "Collection") Or isa(x, "Dictionary") Then
    LIP_M_length = x.count
ElseIf vartype(x) = vbString Then
    LIP_M_length = Len(x)
Else
    Err.Raise 101, , "Not implemented"
End If
End Function

'

'
'      ////////////////  SECTION 6.6 CHARACTERS
'    case CHARQ:           return truth(x instanceof Character);
'    case CHARALPHABETICQ: return truth(Character.isLetter(chr(x)));
'    case CHARNUMERICQ:    return truth(Character.isDigit(chr(x)));
'    case CHARWHITESPACEQ: return truth(Character.isWhitespace(chr(x)));
'    case CHARUPPERCASEQ:  return truth(Character.isUpperCase(chr(x)));
'    case CHARLOWERCASEQ:  return truth(Character.isLowerCase(chr(x)));
'    case CHARTOINTEGER:   return new Double((double)chr(x));
'    case INTEGERTOCHAR:   return chr((char)(int)num(x));
'    case CHARUPCASE:      return chr(Character.toUpperCase(chr(x)));
'    case CHARDOWNCASE:    return chr(Character.toLowerCase(chr(x)));
'    case CHARCMP+EQ:      return truth(charCompare(x, y, false) == 0);
'    case CHARCMP+LT:      return truth(charCompare(x, y, false) <  0);
'    case CHARCMP+GT:      return truth(charCompare(x, y, false) >  0);
'    case CHARCMP+GE:      return truth(charCompare(x, y, false) >= 0);
'    case CHARCMP+LE:      return truth(charCompare(x, y, false) <= 0);
'    case CHARCICMP+EQ:    return truth(charCompare(x, y, true)  == 0);
'    case CHARCICMP+LT:    return truth(charCompare(x, y, true)  <  0);
'    case CHARCICMP+GT:    return truth(charCompare(x, y, true)  >  0);
'    case CHARCICMP+GE:    return truth(charCompare(x, y, true)  >= 0);
'    case CHARCICMP+LE:    return truth(charCompare(x, y, true)  <= 0);
'
'    case ERROR:         return error(stringify(args));
'
'      ////////////////  SECTION 6.7 STRINGS
'    case STRINGQ:       return truth(x instanceof char[]);
'    case MAKESTRING:char[] str = new char[(int)num(x)];
'      if (y != null) {
'    char c = chr(y);
'    for (int i = str.length-1; i >= 0; i--) str[i] = c;
'      }
'      return str;
'    case STRING:        return listToString(args);
'    case STRINGLENGTH:  return num(str(x).length);
'    case STRINGREF:     return chr(str(x)[(int)num(y)]);
'    case STRINGSET:     Object z = third(args); str(x)[(int)num(y)] = chr(z);
'                        return z;
'    case SUBSTRING:     int start = (int)num(y), end = (int)num(third(args));
'                        return new String(str(x), start, end-start).toCharArray();
'    case STRINGAPPEND:  return stringAppend(args);
'    case STRINGTOLIST:  Pair result = null;
'                        char[] str2 = str(x);
'            for (int i = str2.length-1; i >= 0; i--)
'              result = cons(chr(str2[i]), result);
'            return result;
'    case LISTTOSTRING:  return listToString(x);
'    case STRINGCMP+EQ:  return truth(stringCompare(x, y, false) == 0);
'    case STRINGCMP+LT:  return truth(stringCompare(x, y, false) <  0);
'    case STRINGCMP+GT:  return truth(stringCompare(x, y, false) >  0);
'    case STRINGCMP+GE:  return truth(stringCompare(x, y, false) >= 0);
'    case STRINGCMP+LE:  return truth(stringCompare(x, y, false) <= 0);
'    case STRINGCICMP+EQ:return truth(stringCompare(x, y, true)  == 0);
'    case STRINGCICMP+LT:return truth(stringCompare(x, y, true)  <  0);
'    case STRINGCICMP+GT:return truth(stringCompare(x, y, true)  >  0);
'    case STRINGCICMP+GE:return truth(stringCompare(x, y, true)  >= 0);
'    case STRINGCICMP+LE:return truth(stringCompare(x, y, true)  <= 0);
'
'      ////////////////  SECTION 6.8 VECTORS
'    case VECTORQ:   return truth(x instanceof Object[]);
'    case MAKEVECTOR:    Object[] vec = new Object[(int)num(x)];
'                        if (y != null) {
'              for (int i = 0; i < vec.length; i++) vec[i] = y;
'            }
'            return vec;
'    case VECTOR:        return listToVector(args);
'    case VECTORLENGTH:  return num(vec(x).length);
'    case VECTORREF: return vec(x)[(int)num(y)];
'    case VECTORSET:     return vec(x)[(int)num(y)] = third(args);
'    case VECTORTOLIST:  return vectorToList(x);
'    case LISTTOVECTOR:  return listToVector(x);
'
'      ////////////////  SECTION 6.9 CONTROL FEATURES
'    case EVAL:          return interp.eval(x);
'    case FORCE:         return (!(x instanceof Procedure)) ? x
'              : proc(x).apply(interp, null);
'    case MACROEXPAND:   return Macro.macroExpand(interp, x);
'    case PROCEDUREQ:    return truth(x instanceof Procedure);
'    case APPLY:     return proc(x).apply(interp, listStar(rest(args)));
'    case MAP:           return map(proc(x), rest(args), interp, list(null));
'    case FOREACH:       return map(proc(x), rest(args), interp, null);
'    case CALLCC:        RuntimeException cc = new RuntimeException();
'                        Continuation proc = new Continuation(cc);
'                    try { return proc(x).apply(interp, list(proc)); }
'            catch (RuntimeException e) {
'                if (e == cc) return proc.value; else throw e;
'            }
'
'      ////////////////  SECTION 6.10 INPUT AND OUPUT
'    case EOFOBJECTQ:         return truth(x == InputPort.EOF);
'    case INPUTPORTQ:         return truth(x instanceof InputPort);
'    case CURRENTINPUTPORT:   return interp.input;
'    case OPENINPUTFILE:      return openInputFile(x);
'    case CLOSEINPUTPORT:     return inPort(x, interp).close();
'    case OUTPUTPORTQ:        return truth(x instanceof PrintWriter);
'    case CURRENTOUTPUTPORT:  return interp.output;
'    case OPENOUTPUTFILE:     return openOutputFile(x);
'    case CALLWITHOUTPUTFILE: PrintWriter p = null;
'                             try { p = openOutputFile(x);
'                                   z = proc(y).apply(interp, list(p));
'                             } finally { if (p != null) p.close(); }
'                             return z;
'    case CALLWITHINPUTFILE:  InputPort p2 = null;
'                             try { p2 = openInputFile(x);
'                                   z = proc(y).apply(interp, list(p2));
'                             } finally { if (p2 != null) p2.close(); }
'                             return z;
'    case CLOSEOUTPUTPORT:    outPort(x, interp).close(); return TRUE;
'    case READCHAR:      return inPort(x, interp).readChar();
'    case PEEKCHAR:      return inPort(x, interp).peekChar();
'    case LOAD:          return interp.load(x);
'    case READ:      return inPort(x, interp).read();
'    case EOMAL_L_OBJECT:    return truth(InputPort.isEOF(x));
'    case WRITE:     return write(x, outPort(y, interp), true);
'    case DISPLAY:       return write(x, outPort(y, interp), false);
'    case NEWLINE:   outPort(x, interp).println();
'                        outPort(x, interp).flush(); return TRUE;
'
'      ////////////////  EXTENSIONS
'    case CLASS:         try { return Class.forName(stringify(x, false)); }
'                        catch (ClassNotFoundException e) { return FALSE; }
'    case NEW:           try { return JavaMethod.toClass(x).newInstance(); }
'                        catch (ClassCastException e)     { ; }
'                        catch (NoSuchMethodError e)      { ; }
'                        catch (InstantiationException e) { ; }
'                        catch (ClassNotFoundException e) { ; }
'                        catch (IllegalAccessException e) { ; }
'                        return FALSE;
'    case METHOD:        return new JavaMethod(stringify(x, false), y,
'                          rest(rest(args)));
'    case EXIT:          System.exit((x == null) ? 0 : (int)num(x));
'    case LISTSTAR:      return listStar(args);
'    case TIMECALL:      Runtime runtime = Runtime.getRuntime();
'                        runtime.gc();
'                        long startTime = System.currentTimeMillis();
'            long startMem = runtime.freeMemory();
'            Object ans = FALSE;
'            int nTimes = (y == null ? 1 : (int)num(y));
'            for (int i = 0; i < nTimes; i++) {
'              ans = proc(x).apply(interp, null);
'            }
'                        long time = System.currentTimeMillis() - startTime;
'            long mem = startMem - runtime.freeMemory();
'            return cons(ans, list(list(num(time), "msec"),
'                          list(num(mem), "bytes")));
'    default:            return error("internal error: unknown primitive: "
'                     + this + " applied to " + args);
'    }
'    }
'
'  public static char[] stringAppend(Object args) {
'    StringBuffer result = new StringBuffer();
'    for(; args instanceof Pair; args = rest(args)) {
'      result.append(stringify(first(args), false));
'    }
'    return result.toString().toCharArray();
'  }
'
'  public static Object memberAssoc(Object obj, Object list, char m, char eq) {
'    while (list instanceof Pair) {
'      Object target = (m == 'm') ? first(list) : first(first(list));
'      boolean found;
'      switch (eq) {
'      case 'q': found = (target == obj); break;
'      case 'v': found = eqv(target, obj); break;
'      case ' ': found = equal(target, obj); break;
'      default: warn("Bad option to memberAssoc:" + eq); return FALSE;
'      }
'      if (found) return (m == 'm') ? list : first(list);
'      list = rest(list);
'    }
'    return FALSE;
'  }
'
'  public static Object numCompare(Object args, char op) {
'    while (rest(args) instanceof Pair) {
'      double x = num(first(args)); args = rest(args);
'      double y = num(first(args));
'      switch (op) {
'      case '>': if (!(x >  y)) return FALSE; break;
'      case '<': if (!(x <  y)) return FALSE; break;
'      case '=': if (!(x == y)) return FALSE; break;
'      case 'L': if (!(x <= y)) return FALSE; break;
'      case 'G': if (!(x >= y)) return FALSE; break;
'      default: error("internal error: unrecognized op: " + op); break;
'      }
'    }
'    return TRUE;
'  }
'
'  public static Object numCompute(Object args, char op, double result) {
'    if (args == null) {
'      switch (op) {
'      case '-': return num(0 - result);
'      case '/': return num(1 / result);
'      default:  return num(result);
'      }
'    } else {
'      while (args instanceof Pair) {
'    double x = num(first(args)); args = rest(args);
'    switch (op) {
'    case 'X': if (x > result) result = x; break;
'    case 'N': if (x < result) result = x; break;
'    case '+': result += x; break;
'    case '-': result -= x; break;
'    case '*': result *= x; break;
'    case '/': result /= x; break;
'    default: error("internal error: unrecognized op: " + op); break;
'    }
'      }
'      return num(result);
'    }
'  }
'
'  /** Return the sign of the argument: +1, -1, or 0. **/
'  static int sign(int x) { return (x > 0) ? +1 : (x < 0) ? -1 : 0; }
'
'  /** Return <0 if x is alphabetically first, >0 if y is first,
'   * 0 if same.  Case insensitive iff ci is true.  Error if not both chars. **/
'  public static int charCompare(Object x, Object y, boolean ci) {
'    char xc = chr(x), yc = chr(y);
'    if (ci) { xc = Character.toLowerCase(xc); yc = Character.toLowerCase(yc); }
'    return xc - yc;
'  }
'
'  /** Return <0 if x is alphabetically first, >0 if y is first,
'   * 0 if same.  Case insensitive iff ci is true.  Error if not strings. **/
'  public static int stringCompare(Object x, Object y, boolean ci) {
'    if (x instanceof char[] && y instanceof char[]) {
'      char[] xc = (char[])x, yc = (char[])y;
'      for (int i = 0; i < xc.length; i++) {
'    int diff = (!ci) ? xc[i] - yc[i]
'      : Character.toUpperCase(xc[i]) - Character.toUpperCase(yc[i]);
'    if (diff != 0) return diff;
'      }
'      return xc.length - yc.length;
'    } else {
'      error("expected two strings, got: " + stringify(list(x, y)));
'      return 0;
'    }
'  }
'
'  static Object numberToString(Object x, Object y) {
'    int base = (y instanceof Number) ? (int)num(y) : 10;
'    if (base != 10 || num(x) == Math.round(num(x))) {
'      // An integer
'      return Long.toString((long)num(x), base).toCharArray();
'    } else {
'      // A floating point number
'      return x.toString().toCharArray();
'    }
'  }
'
'  static Object stringToNumber(Object x, Object y) {
'    int base = (y instanceof Number) ? (int)num(y) : 10;
'    try {
'      return (base == 10)
'    ? Double.valueOf(stringify(x, false))
'    : num(Long.parseLong(stringify(x, false), base));
'    } catch (NumberFormatException e) { return FALSE; }
'  }
'
'  static Object gcd(Object args) {
'    long gcd = 0;
'    while (args instanceof Pair) {
'      gcd = gcd2(Math.abs((long)num(first(args))), gcd);
'      args = rest(args);
'    }
'    return num(gcd);
'  }
'
'  static long gcd2(long a, long b) {
'    if (b == 0) return a;
'    else return gcd2(b, a % b);
'  }
'
'  static Object lcm(Object args) {
'    long L = 1, g = 1;
'    while (args instanceof Pair) {
'      long n = Math.abs((long)num(first(args)));
'      g = gcd2(n, L);
'      L = (g == 0) ? g : (n / g) * L;
'      args = rest(args);
'    }
'    return num(L);
'  }
'
'  static boolean isExact(Object x) {
'    if (!(x instanceof Double)) return false;
'    double d = num(x);
'    return (d == Math.round(d) && Math.abs(d) < 102962884861573423.0);
'  }
'
'  static PrintWriter openOutputFile(Object filename) {
'    try {
'      return new PrintWriter(new FileWriter(stringify(filename, false)));
'    } catch (FileNotFoundException e) {
'      return (PrintWriter)error("No such file: " + stringify(filename));
'    } catch (IOException e) {
'      return (PrintWriter)error("IOException: " + e);
'    }
'  }
'
'  static InputPort openInputFile(Object filename) {
'    try {
'      return new InputPort(new FileInputStream(stringify(filename, false)));
'    } catch (FileNotFoundException e) {
'      return (InputPort)error("No such file: " + stringify(filename));
'    } catch (IOException e) {
'      return (InputPort)error("IOException: " + e);
'    }
'  }
'
'  static boolean isList(Object x) {
'    Object slow = x, fast = x;
'    for(;;) {
'      if (fast == null) return true;
'      if (slow == rest(fast) || !(fast instanceof Pair)
'      || !(slow instanceof Pair)) return false;
'      slow = rest(slow);
'      fast = rest(fast);
'      if (fast == null) return true;
'      if (!(fast instanceof Pair)) return false;
'      fast = rest(fast);
'    }
'  }
'
'  static Object append(Object args) {
'    if (rest(args) == null) return first(args);
'    else return append2(first(args), append(rest(args)));
'  }
'
'  static Object append2(Object x, Object y) {
'    if (x instanceof Pair) return cons(first(x), append2(rest(x), y));
'    else return y;
'  }
'
'  /** Map proc over a list of lists of args, in the given interpreter.
'   * If result is non-null, accumulate the results of each call there
'   * and return that at the end.  Otherwise, just return null. **/
'  static Pair map(Procedure proc, Object args, Scheme interp, Pair result) {
'    Pair accum = result;
'    if (rest(args) == null) {
'      args = first(args);
'      while (args instanceof Pair) {
'    Object x = proc.apply(interp, list(first(args)));
'    if (accum != null) accum = (Pair) (accum.rest = list(x));
'    args = rest(args);
'      }
'    } else {
'      Procedure car = proc(interp.eval("car")), cdr = proc(interp.eval("cdr"));
'      while  (first(args) instanceof Pair) {
'    Object x = proc.apply(interp, map(car, list(args), interp, list(null)));
'    if (accum != null) accum = (Pair) (accum.rest = list(x));
'    args = map(cdr, list(args), interp, list(null));
'      }
'    }
'    return (Pair)rest(result);
'  }
'
'}


'/** Map proc over a list of lists of args, in the given interpreter.
' * If result is non-null, accumulate the results of each call there
' * and return that at the end.  Otherwise, just return null. **/



Private Function LIP_M_IFn_apply(args As Collection) As Variant
bind LIP_M_IFn_apply, LIP_M_apply(args)
End Function



'LI__M_ Lisp

'Option Explicit 'LI__M_

Public Function LI__M_getGlobalLispEnv() As Dictionary
If globalenv Is Nothing Then
    Set globalenv = installPrimitives(makeEnvironment)
    Set globalenv = installLibraries(globalenv)
End If
Set LI__M_getGlobalLispEnv = globalenv
End Function

Public Function LI__M_makePrimitive(id As Long, minArgs As Long, Optional maxArgs As Long) As LispPrimitive
Set LI__M_makePrimitive = New LispPrimitive

If maxArgs = 0 Then maxArgs = minArgs
With LI__M_makePrimitive
    .idNumber = id
    .minArgs = minArgs
    .maxArgs = maxArgs
End With

End Function
'define something in the - likely global - environment
Public Sub LI__C_addLib(expr As String, Optional env As Dictionary)
If env Is Nothing Then Set env = getGlobalLispEnv
Call EVAL(expr, env)
End Sub
'equivalent to Norvig's python class.
Public Function LI__M_makeEnvironment(Optional params As Collection, Optional args As Collection, _
                                    Optional outerenv As Dictionary) As Dictionary
                                     'should be the main one used project wide, other instances prefixed with x/y/z
Set LI__M_makeEnvironment = DictionaryLib.zipMap(params, args)
If exists(outerenv) Then LI__M_makeEnvironment.Add outer, outerenv

End Function

Public Function LI__M_withLisp(Optional params As Collection, Optional args As Collection) As Dictionary
Set withLisp = makeEnvironment(params, args, LI__M_getGlobalLispEnv)
End Function

'similar to norvig's Find, looks for inner most environment to allow lexical scoping.
Public Function LI__M_findOuter(env As Dictionary, ByRef var As String) As Dictionary
Dim e As Dictionary

Set e = env
Do
    If e.exists(var) Then
        Set findOuter = e
        Exit Do
    ElseIf e.exists(outer) Then
        Set e = e(outer)
    Else
        Exit Do
    End If
Loop

End Function

'need to figure how to wrap this...

'def add_globals(env):
'    "Add some Scheme standard procedures to an environment."
'    import math, operator as op
'    env.update(vars(math)) # sin, sqrt, ...
'    env.update(
'     {'+':op.add, '-':op.sub, '*':op.mul, '/':op.div, 'not':op.not_,
'      '>':op.gt, '<':op.lt, '>=':op.ge, '<=':op.le, '=':op.eq,
'      'equal?':op.eq, 'eq?':op.is_, 'length':len, 'cons':lambda x,y:[x]+y,
'      'car':lambda x:x[0],'cdr':lambda x:x[1:], 'append':op.add,
'      'list':lambda *x:list(x), 'list?': lambda x:isa(x,list),
'      'null?':lambda x:x==[], 'symbol?':lambda x: isa(x, Symbol)})
'    return env
'
'global_env = add_globals(env())
'
'isa = isinstance


Public Function LI__M_isa(var, ByRef nm As String) As Boolean
LI__M_isa = TypeName(var) = nm
End Function

'from JScheme
' //////////////// Evaluation
'
'  /** Evaluate an object, x, in an environment. **/
'  public Object eval(Object x, Environment env) {
'    // The purpose of the while loop is to allow tail recursion.
'    // The idea is that in a tail recursive position, we do "x = ..."
'    // and loop, rather than doing "return eval(...)".
'    while (true) {
'      if (x instanceof String) {         // VARIABLE
'    return env.lookup((String)x);
'      } else if (!(x instanceof Pair)) { // CONSTANT
'    return x;
'      } else {
'    Object fn = first(x);
'    Object args = rest(x);
'    if (fn == "quote") {             // QUOTE
'      return first(args);
'    } else if (fn == "begin") {      // BEGIN
'      for (; rest(args) != null; args = rest(args)) {
'        eval(first(args), env);
'      }
'      x = first(args);
'    } else if (fn == "define") {     // DEFINE
'      if (first(args) instanceof Pair)
'        return env.define(first(first(args)),
'         eval(cons("lambda", cons(rest(first(args)), rest(args))), env));
'      else return env.define(first(args), eval(second(args), env));
'    } else if (fn == "set!") {       // SET!
'      return env.set(first(args), eval(second(args), env));
'    } else if (fn == "if") {         // IF
'      x = (truth(eval(first(args), env))) ? second(args) : third(args);
'    } else if (fn == "cond") {       // COND
'      x = reduceCond(args, env);
'    } else if (fn == "lambda") {     // LAMBDA
'      return new Closure(first(args), rest(args), env);
'    } else if (fn == "macro") {      // MACRO
'      return new Macro(first(args), rest(args), env);
'    } else {                         // PROCEDURE CALL:
'      fn = eval(fn, env);
'      if (fn instanceof Macro) {          // (MACRO CALL)
'        x = ((Macro)fn).expand(this, (Pair)x, args);
'      } else if (fn instanceof Closure) { // (CLOSURE CALL)
'        Closure f = (Closure)fn;
'        x = f.body;
'        env = new Environment(f.parms, evalList(args, env), f.env);
'      } else {                            // (OTHER PROCEDURE CALL)
'        return Procedure.proc(fn).apply(this, evalList(args, env));
'      }
'    }
'      }
'    }
'  }

'################ eval
'
'def eval(x, env = global_env):
'    "Evaluate an expression in an environment."
'    if isa(x, Symbol):             # variable reference
'        return env.find(x)[x]
'    elif not isa(x, list):         # constant literal
'        return x
'    elif x[0] == 'quote':          # (quote exp)
'        (_, exp) = x
'        return exp
'    elif x[0] == 'if':             # (if test conseq alt)
'        (_, test, conseq, alt) = x
'        return eval((conseq if eval(test, env) else alt), env)
'    elif x[0] == 'set!':           # (set! var exp)
'        (_, var, exp) = x
'        env.find(var)[var] = eval(exp, env)
'    elif x[0] == 'define':         # (define var exp)
'        (_, var, exp) = x
'        env [Var] = eval(Exp, env)
'    elif x[0] == 'lambda':         # (lambda (var*) exp)
'        (_, vars, exp) = x
'        return lambda *args: eval(exp, Env(vars, args, env))
'    elif x[0] == 'begin':          # (begin exp*)
'        for exp in x[1:]:
'            val = eval(Exp, env)
'        return val
'    else:                          # (proc exp*)
'        exps = [eval(exp, env) for exp in x]
'        proc = exps.pop(0)
'        return proc(*exps)
Function LI__M_truth(inval As Variant) As Boolean
Select Case vartype(inval)
    Case VbVarType.vbBoolean, VbVarType.vbByte, VbVarType.vbInteger
        truth = CBool(inval)
    Case VbVarType.vbString
        If Mid(CStr(inval), 1, 1) = ":" Then
            LI__M_truth = True
        Else
            LI__M_truth = CBool(inval)
        End If
    Case Else
        LI__M_truth = exists(inval)
End Select

End Function

Function LI__M_isRange(inval As Variant) As Boolean
isRange = TypeName(inval) = "Range"
End Function

Function LI__M_asRange(inval As Variant) As Range
Set asRange = inval
End Function

Function LI__M_rangeValue(inval As Range) As Variant
Dim tmp() As Variant

If inval.Cells.count = 1 Then
    bind LI__M_rangeValue, inval.value
Else
    tmp = inval
    bind LI__M_rangeValue, CollectionLib.varrayToColl(tmp)
End If

End Function
Function LI__M_checkRange(inval As Variant) As Variant

If isRange(inval) Then
    bind LI__M_checkRange, rangeValue(asRange(inval))
Else
    bind LI__M_checkRange, inval
End If

End Function
Sub LI__M_resetLisp()
Set globalenv = Nothing
Set LI__M_primitiveFuncs = Nothing
End Sub



'Side-effecting way to bind vars
Sub LI__M_bind(invar As Variant, ByRef inval As Variant)

If IsObject(inval) Then
    Set invar = inval
Else
    invar = inval
End If

End Sub
Sub LI__M_clearbind(ByRef invar As Variant)
If IsObject(invar) Then
    Set invar = Nothing
Else
    invar = Empty
End If
End Sub
Function LI__M_lisperror(expr As Variant, msg As String) As Collection
Set lisperror = list("error", msg)
End Function
Function LI__M_unboundError(v As String) As String
unboundError = "No value defined for var " & v
End Function

Function LI__M_eval(expr As Variant, Optional env As Dictionary) As Variant  ''Core Norvig MCE
Dim var As String
Dim vars As Collection
Dim outerd As Dictionary
Dim x As Variant

If env Is Nothing Then Set env = getGlobalLispEnv()

If isa(expr, "String") Then 'string literal, indicates a variable ref
    var = CStr(expr)
    If isLiteral(var) Then
        If Mid(var, 1, 1) = ":" Then
            bind LI__M_eval, Mid(var, 1, Len(var))  'drops the outer set of " from the string
        Else
            bind LI__M_eval, Mid(var, 2, Len(var) - 2) 'drops the outer set of " from the string
        End If
    ElseIf isBool(CStr(expr)) Then
        bind LI__M_eval, CBool(expr)
    Else
        Set outerd = findOuter(env, var)
        If outerd Is Nothing Then
            'failed to find a var
            'signal an error condition in evaluation
            'bind eval, lisperror(expr, unboundError(var))
            Err.Raise 101, , unboundError(var)
        Else
            bind LI__M_eval, outerd(var)
            Set outerd = Nothing
        End If
    End If
ElseIf Not isa(expr, "Collection") Then 'not a list, must be a constant/primitive
    LI__M_eval = expr
Else
    Dim explist As Collection
    Set explist = expr
    If Not isa(explist(1), "Collection") Then
        Select Case explist(1)
            Case "quote" 'quoted expression
                If isLiteral(CStr(explist(2))) Then
                    bind LI__M_eval, expr
                Else
                    bind LI__M_eval, explist(2)
                End If
            Case "if"
                If truth(LI__M_eval(explist(2), env)) Then
                    bind LI__M_eval, EVAL(explist(3), env)
                Else
                    bind LI__M_eval, EVAL(explist(4), env)
                End If
            Case "set!"
                var = CStr(explist(2))
                '(_, var, exp) = x
                'env.find(var)[var] = eval(exp, env)
                Dim val As Variant
                With findOuter(env, var)
                     bind val, EVAL(explist(3), env)
                    .Remove var
                    .Add var, val
                End With
                clearbind val
            Case "let", "let*"
                bind LI__M_eval, LI__M_eval(letStar(explist), env)
            Case "define", "def"
                If Not isa(explist(2), "Collection") Then
                    var = CStr(explist(2))
                    env.Add var, LI__M_eval(explist(3), env)
    
                    LI__M_eval = var
                Else 'implicit function definition
                    Set vars = explist(2) 'expand the (name par1 par2)
                    var = vars(1)
                    If env.exists(var) Then env.Remove (var) 'this might be buggy.
                    env.Add var, makeClosure(restList(explist(2)), explist(3), env)
                    LI__M_eval = var
                End If
            '    elif x[0] == 'define':         # (define var exp)
            '        (_, var, exp) = x
            '        env [Var] = eval(Exp, env)
            Case "defn" '(defn name [args] body)
                var = explist(2)
                Set vars = explist(3) 'expand the
                If env.exists(var) Then env.Remove (var) 'this might be buggy.
                env.Add var, makeClosure(vars, explist(4), env)
                LI__M_eval = var
            Case "lambda", "fn" 'this doesn't work, since we don't have lambdas...using jscheme example
            '    } else if (fn == "lambda") {     // LAMBDA
            '      return new Closure(first(args), rest(args), env);
                Set LI__M_eval = makeClosure(explist(2), explist(3), env)
            Case "begin", "do", "progn"
            '    elif x[0] == 'begin':          # (begin exp*)
            '        for exp in x[1:]:
            '            val = eval(Exp, env)
            '        return val
                Dim v As Variant
                Dim j As Long
                
                For j = 2 To explist.count
                    bind v, LI__M_eval(explist(j), env)
                Next j
                
                bind LI__M_eval, v
                clearbind v
            Case "error"
                Err.Raise 101, , explist(2)
            Case Else
                bind LI__M_eval, applyfn(explist, env)
        End Select
    Else
    '    } else {                         // PROCEDURE CALL:
    '      fn = eval(fn, env);
''               Dim fn As LispClosure
''               Dim i As Long
        bind LI__M_eval, applyfn(explist, env)
       
    '      if (fn instanceof Macro) {          // (MACRO CALL)
    '        x = ((Macro)fn).expand(this, (Pair)x, args);
    '      } else if (fn instanceof Closure) { // (CLOSURE CALL)
    '        Closure f = (Closure)fn;
    '        x = f.body;
    '        env = new Environment(f.parms, evalList(args, env), f.env);
    '      } else {                            // (OTHER PROCEDURE CALL)
    '        return Procedure.proc(fn).apply(this, evalList(args, env));
    '      }
    '    }
    '    else:                          # (proc exp*)
    '        exps = [eval(exp, env) for exp in x]
    '        proc = exps.pop(0)
    '        return proc(*exps)
        
    End If
End If
    
End Function
Function LI__M_isBool(ByRef s As String) As Boolean
Select Case UCase(s)
    Case "TRUE", "FALSE"
        isBool = True
    Case Else
        isBool = False
End Select
End Function
Function LI__M_isLiteral(ByRef s As String) As Boolean
Select Case firstchar(s)
    Case ":"
        isLiteral = True
    Case Chr(34)
        isLiteral = True
    Case Else
        isLiteral = False
End Select
End Function
Function LI__M_applyfn(explist As Collection, env As Dictionary) As Variant

Dim fn As IFn
Dim lc As LispClosure
Dim xs As Collection
Set xs = New Collection

Dim i As Long
Set fn = EVAL(explist(1), env)
For i = 2 To explist.count
    xs.Add EVAL(explist(i), env)
Next i

bind applyfn, fn.apply(xs) 'res(1)
Set xs = Nothing
End Function
'destructures the explist, assumed to be the form
'(let
'   ((b1 v1) (b2 v2) (b3 v3))
'   body)
Function LI__M_getbinds(explist As Collection) As Collection
Dim body As Variant
Dim binds As Collection
Set binds = explist(2)
End Function
Function LI__M_getVarsVals(binds As Collection) As Collection
Dim itm As Collection
Dim vars As Collection
Dim vals As Collection

Set vars = New Collection
Set vals = New Collection

For Each itm In binds
    vars.Add itm(1)
    vals.Add itm(2)
Next itm
     
Set getVarsVals = list(vars, vals)

Set vars = Nothing
Set vals = Nothing

End Function
'assumes input : (let ((a 1) (b 2)) (+ a b))
Function LI__M_letStar(explist As Collection)
Dim varvals As Collection
Set varvals = getVarsVals(explist(2))
Set letStar = nestedlet(varvals(1), varvals(2), explist(3))
End Function
'syntactic transform
'(let ( ((a 1)
'        (b 2))
'  (+ a b))
'becomes
'((lambda (a)
'   (+ a b)) 1 2)
Function LI__M_deflet(parameters As Collection, args As Collection, body As Variant) As Collection
Dim itm As Variant
If args.count <> parameters.count Then Err.Raise 101, , "let requires an even number of binding forms"

Set deflet = list(list("lambda", parameters, body))
For Each itm In args
    deflet.Add itm
Next itm

End Function
Function LI__M_nestedlet(parameters As Collection, args As Collection, body As Variant) As Collection
Dim itm As Variant
Dim i As Long
Dim outerlist As Collection
Dim nextlist As Collection
If args.count <> parameters.count Then Err.Raise 101, , "let requires an even number of binding forms"

Set nestedlet = New Collection

Set nestedlet = list(list("lambda", list(parameters(parameters.count)), body), args(args.count))
For i = args.count - 1 To 1 Step -1
    Set outerlist = list(list("lambda", list(parameters(i)), nestedlet), args(i))
    Set nestedlet = outerlist
Next i

Set outerlist = Nothing
End Function

Public Function LI__M_evalList(args As Collection, env As Dictionary) As Variant

End Function
Public Function LI__M_makeClosure(params As Collection, body As Variant, env As Dictionary) As LispClosure
Set makeClosure = New LispClosure
With makeClosure
    Set .params = params
    If IsObject(body) Then
        Set .body = body
    Else
        .body = body
    End If
        
    Set .env = env
End With

End Function
Public Function LI__M_read(ByRef s As String) As Variant
bind LI__M_read, readfrom(tokenize(s))
End Function
'define anonymous function
Public Function LI__M_makefn(ByRef expr As String, Optional env As Dictionary) As LispClosure
Set makefn = LI__M_eval(READ(expr), env)
End Function

'################ parse, read, and user interaction
'
'def Read(s):
'    "Read a Scheme expression from a string."
'    return read_from(tokenize(s))
'
'parse = Read
'
'def tokenize(s):
'    "Convert a string into a list of tokens."
'    return s.replace('(',' ( ').replace(')',' ) ').split()
'
Function LI__M_tokenize(ByRef s As String) As Variant

Dim tmp
Dim tok As String
Dim itm
tok = replace(s, "(", " ( ")
tok = replace(tok, ")", " ) ")
tok = replace(tok, "[", " [ ")
tok = replace(tok, "]", " ] ")
tok = replace(tok, "{", " { ")
tok = replace(tok, "}", " } ")
tok = replace(tok, ",", " , ")

tmp = Split(tok)
'If UBound(tmp, 1) = 0 Then
'    tokenize = tmp(0)
'Else
    Set tokenize = New Collection
    For Each itm In tmp
        tokenize.Add itm
    Next itm
'End If

End Function

'def read_from(tokens):
'    "Read an expression from a sequence of tokens."
'    if len(tokens) == 0:
'        raise SyntaxError('unexpected EOF while reading')
'    token = tokens.pop(0)
'    if '(' == token:
'        l = []
'        while tokens[0] != ')':
'            l.append (read_from(tokens))
'        tokens.pop(0) # pop off ')'
'        return L
'    elif ')' == token:
'        raise SyntaxError('unexpected )')
'    Else:
'        return atom(token)

Function LI__M_readfrom(tokens As Collection, Optional ByRef delimiter As String) As Variant
Dim token As String
Dim l As Collection

If tokens.count = 0 Then _
    Err.Raise 101, "EOF While reading lisp expression!"

While whitespace(tokens(1)) And tokens.count > 0
    tokens.Remove 1
Wend
If tokens.count = 0 Then _
    Err.Raise 101, "EOF While reading lisp expression!"

token = tokens(1)

If isSequenceStart(token) Then
    delimiter = token
    Set l = New Collection
    tokens.Remove 1
    token = tokens(1)
    If delimiter <> "(" And token <> "hash-set" Then _
        l.Add getSeqType(delimiter) 'prepends a constructor [vec, hash-map, hash-set]
        'we exclude list from here, since lists are treated as quoted lists
    
    While Not isSequenceStop(token, delimiter)
        If isSequenceStart(token) Or specialToken(token) Then
            l.Add readfrom(tokens)
        ElseIf Not (whitespace(token)) Then
            l.Add readfrom(tokens)
        End If
        tokens.Remove 1
        If tokens.count = 0 Then
            Err.Raise 101, , " missing " & getClosingDelim(delimiter)
        Else
            token = tokens(1)
        End If
    Wend
    Set readfrom = l
    delimiter = vbNullString
ElseIf isSequenceStop(token) Then
    Err.Raise 101, , "Unexpected " & token
Else
    Select Case firstchar(token)
        Case "#" 'reader macro invokation.
            If token = "#JSON" Then
                Set readfrom = readfrom(readJSON(tokens))
            Else
                Select Case tokens(1)
                    Case "(" '#( -> indicates anonymous function)
                        Set readfrom = list("error", "#(...) Anonymous function reader macro not implemented")
                    Case """"  '#"" -> indicates a regexp
                        Set readfrom = list("error", "#""..."" Regexp literal reader macro not implemented")
                    Case "{" '#{} -> indicates a set
                        tokens.Remove 1
                        Set tokens = prepend(tokens, "hash-set")
                        Set tokens = prepend(tokens, "{")
                        Set readfrom = readfrom(tokens)
                End Select
            End If
        Case "'"
            If tokens.count = 1 Then
                    Set tokens = prepend(tokens, restString(token))
                    Set readfrom = list("quote", readfrom(tokens))
            Else
                tokens.Remove 1
                If tokens(1) = "(" Then
                    tokens.Remove 1
                    Set tokens = prepend(tokens, "list")
                    Set tokens = prepend(tokens, "(")
                    Set readfrom = readfrom(tokens)
                Else
                    Set tokens = prepend(tokens, restString(token))
                    Set readfrom = list("quote", readfrom(tokens))
                End If
            End If
'        Case Chr(34) ' "
'            'tokens.Remove 1
'            Set tokens = prepend(tokens, ")")
'            Set tokens = prepend(tokens, "quote")
'            Set tokens = prepend(tokens, "(")
'            Set readfrom = readfrom(tokens)
        Case ":"
            'tokens.Remove 1
'            Set tokens = prepend(tokens, ")")
'            Set tokens = prepend(tokens, "quote")
'            Set tokens = prepend(tokens, token)
'            Set tokens = prepend(tokens, "(")
'            Set readfrom = readfrom(tokens)
            readfrom = token
        Case "`"
            tokens.Remove 1
            Set readfrom = list("quasiquote", readfrom(tokens))
        Case ","
            tokens.Remove 1
            If isQuasiSplice(token) Then
                Set readfrom = list("unquote-splicing", readfrom(tokens))
            Else
                Set readfrom = list("unquote", restString(token))
            End If
        Case Else
            readfrom = atom(token)
    End Select
End If
    
'public Object read() {
'  try {
'    Object token = nextToken();
'    if (token == "(")
'  return readTail(false);
'    else if (token == ")")
'  { warn("Extra ) ignored."); return read(); }
'    else if (token == ".")
'  { warn("Extra . ignored."); return read(); }
'    else if (token == "'")
'  return list("quote", read());
'    else if (token == "`")
'  return list("quasiquote", read());
'    else if (token == ",")
'  return list("unquote", read());
'    else if (token == ",@")
'  return list("unquote-splicing", read());
'    Else
'  return token;
'  } catch (IOException e) {
'    warn("On input, exception: " + e);
'    return EOF;
'  }
'}
       
End Function
'Converts a JSON string literal into an evaluation
'Mutates tokens in the process by consuming elements from the head.
'Returns '((string->json "somestring"), tokens)
Function LI__M_readJSON(tokens As Collection) As Collection
Dim itm
Dim sb As StringBuilder
Set sb = New StringBuilder

sb.append Chr(34)

If tokens(1) = "#JSON" Then
    tokens.Remove 1
    While tokens(1) <> ""
        sb.append CStr(tokens(1))
        tokens.Remove 1
    Wend
End If
    
sb.append Chr(34)
    
'readJSON = sb.toString
Set readJSON = tokens
Set readJSON = prepend(tokens, ")")
Set readJSON = prepend(tokens, sb.toString)
Set readJSON = prepend(tokens, "read-JSON")
Set readJSON = prepend(tokens, "(")
Set sb = Nothing
    
End Function
Function LI__M_getClosingDelim(ByRef delim As String) As String
Select Case delim
    Case "("
        getClosingDelim = ")"
    Case "["
        getClosingDelim = "]"
    Case "{"
        getClosingDelim = "}"
    Case Else
        Err.Raise 101, , "unknown delimiter " & delim
End Select

End Function
Function LI__M_getSeqType(ByRef tok As String) As String
Select Case tok
    Case "("
        getSeqType = "list"
    Case "["
        getSeqType = "vector"
    Case "{"
        getSeqType = "hash-map"
    Case Else
        Err.Raise 101, , "Unknown sequence type " & tok
End Select

End Function
Function LI__M_isSequenceStart(ByRef tok As String) As Boolean
Select Case tok
    Case "(", "[", "{"
        isSequenceStart = True
    Case Else
        isSequenceStart = False
End Select
    
End Function
Function LI__M_isSequenceStop(ByRef tok As String, Optional ByRef tokstart As String) As Boolean
If tokstart = vbNullString Then
    Select Case tok
        Case ")", "]", "}"
            isSequenceStop = True
        Case Else
            isSequenceStop = False
    End Select
Else
    Select Case tokstart
        Case "("
            isSequenceStop = tok = ")"
        Case "["
            isSequenceStop = tok = "]"
        Case "{"
            isSequenceStop = tok = "}"
        Case Else
            Err.Raise 101, , "Unkown sequence delimiter " & tokstart
    End Select
End If

End Function

Function LI__M_specialToken(ByRef tok As String) As Boolean
Rem '911 see line 311 for  special chars for Picolisp - I don't think ":", "~@" are special...

Select Case tok
    Case "'", ":", "`", "~", "~@"
        specialToken = True
End Select

End Function
Function LI__M_firstchar(ByRef tok As String) As String
firstchar = Mid(tok, 1, 1)
End Function
Function LI__M_nthString(n As Long, ByRef tok As String) As String
nthString = Mid(tok, n, 1)
End Function
Function LI__M_restString(ByRef tok As String) As String
restString = Mid(tok, 2)
End Function
Function LI__M_isQuasiSplice(ByRef tok As String) As Boolean
isQuasiSplice = Mid(tok, 1, 2) = "~@"
End Function
Function LI__M_isKeyword(ByRef tok As String) As Boolean
isKeyword = Mid(tok, 1, 1) = ":"
End Function

Function LI__M_whitespace(ByRef tok As String) As Boolean
Select Case tok
    Case "", vbCrLf, vbTab, " ", ",", Chr(10), Chr(13)
        whitespace = True
    Case Else
        whitespace = False
End Select
End Function

'def atom(token):
'    "Numbers become numbers; every other token is a symbol."
'    try: return int(token)
'    except ValueError:
'        try: return float(token)
'        except ValueError:
'            return Symbol(token)
'
Function LI__M_atom(ByRef token As String, Optional stringlit As Boolean) As Variant
If stringlit Then
    atom = replace(token, Chr(34), "")
ElseIf val(token) <> 0 Then
    atom = CDbl(val(token))
Else
    Select Case token
        Case "0", "0.0", "0.00"
            atom = CDbl(val(token))
        Case Else
            atom = token
    End Select
End If
    
End Function
'def to_string(Exp):
'    "Convert a Python object back into a Lisp-readable string."
'    Return '('+' '.join(map(to_string, exp))+')' if isa(exp, list) else str(exp)
'
'def repl(prompt='lis.py> '):
'    "A prompt-read-eval-print loop."
'    While True:
'        val = eval(parse(raw_input(prompt)))
'        if val is not None: print to_string(val)

Public Function LI__M_defPrim(env As Dictionary, ByRef name As String, id As Long, minArgs As Long, Optional maxArgs As Long) As Dictionary
Dim p As LispPrimitive
Set p = New LispPrimitive

p.name = name
p.idNumber = id
p.minArgs = minArgs
If maxArgs > 0 Then
    p.maxArgs = maxArgs
Else
    p.maxArgs = minArgs
End If
    
env.Add name, p
Set defPrim = env
End Function
'TOM added 9 Nov 2012 -> allows us to use IFns, as defined in Lisp, from anywhere in vba.
'Maintains a function library.
Public Function LI__M_getFunc(name As String) As LispPrimitive
With getPrimitiveFunctions()
    If .exists(name) Then
        Set getFunc = .Item(name)
    Else
        Err.Raise 101, "Function " & name & " is not a known primitive function!"
    End If
End With

End Function
Public Function LI__M_getPrimitiveFunctions() As Dictionary
If LI__M_primitiveFuncs Is Nothing Then _
    Set LI__M_primitiveFuncs = lispPrimitiveFunctions()
Set getPrimitiveFunctions = LI__M_primitiveFuncs
End Function
'TOM added 9 Nov 2012 -> adds a library of lisp functions, each is a useable IFn that takes a
'collection of args...so they can also be called from other VBA programs...
Public Function LI__M_lispPrimitiveFunctions() As Dictionary
Dim defs As Collection
Dim itm
Dim fs As Collection
Dim prim As LispPrimitive

Dim n As Long
n = 999999999

Set defs = New Collection

For Each itm In list(list("+", lispPrimitives.lPLUS, 0, n), _
    list("map", lMAP, 1, n), list("list", lLIST, 0, n), _
    list("*", lTIMES, 0, n), _
    list("-", lMINUS, 1, n), _
    list("/", lDIVIDE, 1, n), _
    list("<", lLT, 2, n), _
    list("<=", lLE, 2, n), _
    list("=", lEQ, 2, n), _
    list(">", lGT, 2, n), _
    list(">=", lGE, 2, n), _
    list("abs", lABS, 1), _
    list("apply", lAPPLY, 2, n), _
    list("eval", lEVAL, 1, 2), _
    list("sin", lSIN, 1), _
    list("cos", lCOS, 1), _
    list("tan", lTAN, 1), _
    list("sqrt", lSQRT, 1), _
    list("modulo", lMODULO, 2), _
    list("length", lLENGTH, 1), _
    list("count", lLENGTH, 1), _
    list("vector", lVECTOR, 0, n), _
    list("hash-map", lHASHMAP, 0, n))
    defs.Add itm
Next itm

    
For Each itm In list(list("hash-set", lHASHSET, 0, n), _
    list("even?", lEVENQ, 1, 1), _
    list("odd?", lODDQ, 1, 1), _
    list("number?", lNUMBERQ, 1, 1), _
    list("zero?", lZEROQ, 1, 1), _
    list("negative?", lNEGATIVEQ, 1, 1), _
    list("reduce", lREDUCE, 2, n), _
    list("read-JSON", lREADJSON, 1, 1), _
    list("write-JSON", lWRITEJSON, 1, 1))
    defs.Add itm
Next itm

'Sequence functions....
For Each itm In list(list("take", lTAKE, 2), _
    list("take-while", lTAKEWHILE, 2), _
    list("iterate", lITERATE, 2), _
    list("drop", lDROP, 2), _
    list("first", lFIRST, 1), _
    list("rest", lREST, 1), _
    list("next", lNEXT, 1), _
    list("lazy-cons", lLAZYCONS, 2), _
    list("seq", lSEQ, 2), _
    list("filter", lFILTER, 2), _
    list("concat", lCONCAT, 2), _
    list("last", lLAST, 2), _
    list("but-last", lBUTLAST, 2), _
    list("nth", lNTH, 2), _
    list("inc", lINC, 1), _
    list("dec", lDEC, 1), _
    list("repeat", lREPEAT, 1), _
    list("repeatedly", lREPEATEDLY, 1), _
    list("second", lSECOND, 1))
    
defs.Add itm
Next itm

'Sequence functions....
For Each itm In list(list("rand", lRAND, 0, 1), _
    list("rand-int", lRANDINT, 1), _
    list("rand-between", lRANDBETWEEN, 2), _
    list("load-file", lLOADFILE, 1), _
    list("range", lrange, 1), _
    list("reverse", lreverse, 1), _
    list("sort-by", lsortby, 2), _
    list("sort", lsort, 1, 2), _
    list("conj", lconj, 2))
defs.Add itm
Next itm


Dim coll As Collection
Set lispPrimitiveFunctions = New Dictionary
For Each coll In defs
    If coll.count > 3 Then
        Set prim = makePrimitive(CLng(coll(2)), CLng(coll(3)), CLng(coll(4)))
    Else
        Set prim = makePrimitive(CLng(coll(2)), CLng(coll(3)))
    End If
    lispPrimitiveFunctions.Add coll(1), prim
Next coll
    
End Function
Public Function LI__M_asFunc(x As Variant) As IFn
Set asFunc = x
End Function


Public Function LI__M_installPrimitives(env As Dictionary) As Dictionary

Set installPrimitives = DictionaryLib.mergeDicts(env, getPrimitiveFunctions())
env.Add "pi", lispPI
env.Add "e", lispE

End Function
'Installs additional libraries, where libarires lisp expressions contained in libs.
Public Function LI__M_installLibraries(env As Dictionary, Optional libs As Collection) As Dictionary
Dim expr
Set installLibraries = env

If exists(libs) Then
    For Each expr In libs
        EVAL expr, env
    Next expr
End If

End Function

'A quick test of the Lisp (more scheme) interpreter in VBA......I Don't know if this is an accomplishment
'or an attrocity, but it's kept me interested!  This is running from within Excel, in the VBA IDE.
Sub LI__M_tst()
Dim env As Dictionary
Set env = installPrimitives(makeEnvironment)

pprint READ("(+ 2 3)")
pprint EVAL(READ("(+ 2 3)"), env)
pprint EVAL(READ("(map (lambda (x) (+ 1 x)) (list 1 2 3))"), env)
pprint EVAL(READ( _
    "(begin (define pi 3.14) " & _
           "(define area (lambda (r) (* r r pi)))" & _
           "(map area (list 1 2 3 4)))"), env)

pprint READ("2")

End Sub

Sub LI__M_tstbind()
Dim x As Variant
Dim y As Variant


Set y = list(1, 2, 3)
bind x, y

End Sub
'define lambda's inline in VBA
Function LI__M_lambda(params As Collection, body As String, Optional env As Dictionary) As IFn

If env Is Nothing Then Set env = LI__M_getGlobalLispEnv
Set lambda = makeClosure(params, READ(body), env)

End Function

'FROM SICP, separating execution from analysis.
Function LI__C_analyze(expr As Variant) As Variant
Select Case expType(expr)
    Case expressionTypes.selfEvaluatingQ
        'bind analyze, list("lambda", list("env"), expr)
    Case expressionTypes.quotedQ
        'not implemented....
        'Dim txt As String
        'txt = textOfQuotation(expr)
        'bind analyze, lambda(list("env"), txt)
    Case expressionTypes.variableQ
        'bind analyze, lambda(list("env"), "(lookup-variable-value " & expr & " env)")
    Case expressionTypes.assignmentQ
    Case expressionTypes.definitionQ
    Case expressionTypes.ifQ
    Case expressionTypes.lambdaQ
    Case expressionTypes.beginQ
    Case expressionTypes.condQ
    Case expressionTypes.applicationQ
    Case expressionTypes.unknown
End Select
    
End Function
Function LI__M_textOfQuotation(expr As Collection) As String
textOfQuotation = printstr(restList(expr))
End Function
Function LI__M_expType(expr As Variant) As expressionTypes
End Function

Function LI__M_apply(fn As IFn, args As Collection) As Variant
bind apply, fn.apply(args)  ''Core Norvig MCE - notice apply uses an Interface to make it polymorphic...

End Function


'Calling anonymous functions from VBA
Sub LI__M_lambdatest()
Dim i As Long
Dim add2  As IFn

Set add2 = lambda(list("x"), "(* 2 x)")

pprint map(add2, floatList(33.5, 4.4, -2))
pprint reduce(lambda(list("acc", "x"), "(+ acc x)"), 0#, floatList(10))

End Sub

'For each element in the sequence Args, apply f to the element, accumulating a
'collection of results.  Returns a 1:1 mapping of function applications.
Public Function LI__M_map(f As IFn, ByRef args As Variant) As Variant
Dim acc As Collection
Dim key
Dim c As Collection
Dim d As Dictionary
Dim s As ISeq
Dim i As Long
Set acc = New Collection

Select Case TypeName(args)
    Case "Collection"
        Set c = asCollection(args)
        For i = 1 To args.count
            acc.Add f.apply(list(args(i)))
        Next i
    Case "Dictionary"
        Set d = asDict(args)
        For Each key In d
            bind acc, f.apply(list(acc, list(key, d(key))))
        Next key
    Case Else
        If isSeq(args) Then
            Set s = args
            Set map = SeqLib.seqMap(f, s)
            Set s = Nothing
            Exit Function
        Else
            Err.Raise 101, , "Do not know how to reduce " & TypeName(args)
        End If
End Select


Set map = acc
End Function

'Takes a function f, whose first arg is an accumulator, and second arg is an item to
'be reduced.
'For each element in the sequence Args, apply f to the acc and the element, accumulating
'results in acc.
Public Function LI__M_reduce(f As IFn, Optional initialval As Variant, Optional ByRef args) As Variant
Dim i As Long
Dim offset As Long
Dim key
Dim d As Dictionary
Dim c As Collection
Dim s As ISeq

Dim acc As Variant

If args Is Nothing Then
    Err.Raise 101, , "No arguements provided for reduction.  Context is undefined"
ElseIf IsMissing(initialval) Then
    bind initialval, args(1)
    offset = 1
End If

bind acc, initialval

Select Case TypeName(args)
    Case "Collection"
        Set c = asCollection(args)
        For i = 1 + offset To c.count
            bind acc, f.apply(list(acc, c(i)))
        Next i
    Case "Dictionary"
        Set d = asDict(args)
        For Each key In d
            bind acc, f.apply(list(acc, list(key, d(key))))
        Next key
    Case Else
        If isSeq(args) Then
            Set s = args
            If Not nil(s.fst) Then
                bind acc, f.apply(list(acc, s.fst))
                While exists(s.more)
                    Set s = s.more
                    bind acc, f.apply(list(acc, s.fst))
                Wend
            End If
            Set s = Nothing
        Else
            Err.Raise 101, , "Do not know how to reduce " & TypeName(args)
        End If
End Select
            
            
bind reduce, acc
clearbind acc
End Function

'Simulates a simple read-evaluate-print composition, without Looping.
'Facilitates evaluating lisp Expressions from the immediate window.
Public Sub LI__M_rep(ByRef expression As String, Optional env As Dictionary)
pprint EVAL(READ(expression), env)
'resetLisp
End Sub
Function LI__M_reval(ByRef expression As String, Optional env As Dictionary) As Variant
bind reval, EVAL(READ(expression))
End Function
'Fetch a varname from bindings in the lisp Environment.  Obeys lexical scoping rules
'using findOuter.  Typically used to lookup global vars from the lisp environment.
Function LI__M_resolve(ByRef varname As String, Optional env As Dictionary) As Variant
If env Is Nothing Then Set env = LI__M_getGlobalLispEnv
bind resolve, findOuter(env, varname)
End Function


'Reads a file...depending on the extension (i.e. if it's JSON), it'll automatically
'interpret it as a JSON-like file, otherwise uses the Lisp evaluator (with clojure syntax
'extensions for datastructures) to evaluate the data...
Public Function LI__M_readFile(path As String) As Variant
Dim fl As String
Dim frm
If InStr(1, UCase(path), ".JSON") = 0 Then 'normal read...
    fl = SerializationLib.readString(path)
    fl = "(" & fl & ")"
    For Each frm In READ(fl)
        EVAL frm
    Next frm
Else
    fl = "#JSON" & SerializationLib.readString(path)
    bind LI__M_readFile, reval(fl)
End If

End Function

Rem LII_C LispInterpreter - was a class, now each fuction refers to a global -
Rem - Public
'A Wrapped Lisp environment that can read and evaluate expressions.
Rem Option Explicit
Rem Public localenv As Dictionary
Rem note above removes encapsulation, so the code is NOT re-entrant as this point
Rem FOS initial design goal is global instance across the current Excel instace - forms, cells, etc.

Public Function LII_C_READ(s As String) As Variant
bind LII_C_READ, LI__M_read(s)
End Function

Public Function LII_C_EVAL(exp As Variant, Optional env As Dictionary) As Variant
Dim res As Collection

If env Is Nothing Then Set env = localenv
bind LII_C_EVAL, LI__M_eval(exp, env)

End Function

Public Sub LII_C_Class_Initialize()
Set localenv = LI__M_getGlobalLispEnv
End Sub



Function LI__M_z_Debug_Print(Local_Info, THX)
Rem 'could be made into a gosub when the conversion to "single function implementation" is done..'
Rem speed and less code changes between versions (VBA, RFO, Small) would be the biggest target improvement areas
Rem META: It's possible to write a LISP script to do this... like Kramer's Coffe Table books on cofee tables, which is a table)

Debug.Print Local_Info + ": " + THX

LI__M_z_Debug_Print = THX

End Function


Public Sub LVM_M_Form_Load(frmForm As Variant)

gLVM_Debug = True

  If gLVM_Debug = True Then 'Debug Print via global
   Debug.Print frmForm.tag, "LVM_Form_Load  ", Now()
  End If
  
End Sub
Public Sub LVM_M_Form_Close(frmForm As Variant)
gLVM_Debug = True
  If gLVM_Debug = True Then  'Debug Print via global
   Debug.Print frmForm.tag, "LVM_Form_Close", Now()
   
  End If
  
End Sub

Public Sub LVM_M_cmdSCAN_Click(frmForm As Variant)
  If gLVM_Debug = True Then 'Debug Print via global
   Debug.Print frmForm.tag, "LVM_cmdSCAN_Click", Now()
  End If
  

  

End Sub

Public Sub LVM_M_cmdSUBMIT_Click(frmForm As Variant)


  If gLVM_Debug = True Then 'Debug Print via global
   Debug.Print frmForm.tag, "LVM_M_cmdSUBMIT_Click", Now()
  End If

LVM_M_Navigate frmForm


End Sub

Public Sub LVM_M_Navigate(frmForm As Variant)
Dim strForm_Dest As String
Dim strPROC_RESULT As String

'Dim tmpRecordset As Variant
'Dim tmpFields As Variant

  'just does navigation rules - for SUBMIT
  ' -- CANCEL should "roll back" any transactions '911
  
  ' maybe use transactions (OpenGate, etc.) for SUBMIT and CANCEL functionality
 ' SUBMIT is COMMIT
  ' CANCEL is ROLL_BACK '911 - this is important in "bound control implementations"
    
  ' Check Global Rules like Parachute expire / repack etc. here.
     ' - see ~42 'Rules' Column in Excel SUPER_Table
     ' - see FRD / SSDS / Use Case / GAT / Support Guide for other other rules
   'put 9 Navigation Rules here... from 42 "de-duped" rules
  
'Default behaviour - i.e. "super inherited" - is to close the form
  
'' Below 4 R012  rules are same as default --> do nothing different,
'R012__000M 011m__Pack IF FAIL -PACK THEN Go to MAIN
'R012__000M 027m__Inspect-Initial IF FAIL -PACK THEN Go to MAIN
'R012__000M 028m__Inspect-Final IF FAIL -PACK THEN Go to MAIN
'R012__000M 029m__Inspect-Quality-Routine IF FAIL -PACK THEN Go to MAIN


'' Below 4 R014  rules are handle a Parachute non-standard workflow
    '' - start error handling - via the m02Q - Fail_Component
      ' , missing rule to follow on to m02R - Fail Reason
      
       'we should add that after 9 Nav rules are debugged - do xRef via "86 Figs"
        'All screens should have a navigation by either menu or worklfow
           'probably mostly this routine
              '- ideal for future SporkLisp as rule engine / workflow engine LVM kernal

'R014__000M 011m__Pack IF FAIL-MAINTENANCE THEN Go to m02Q
'R014__000M 027m__Inspect-Initial IF FAIL-MAINTENANCE THEN Go to m02Q
'R014__000M 028m__Inspect-Final IF FAIL-MAINTENANCE THEN Go to m02Q
'R014__000M 029m__Inspect-Quality-Routine IF FAIL-MAINTENANCE THEN Go to m02Q

'*********************************************************************************
'*********************************************************************************
'*********************************************************************************

'S001 - Sexp for rule implementation - refactor in SporkLisp '811
  'see implementation below

'*********************************************************************************
'*********************************************************************************
'*********************************************************************************

'R019__000M 020m__Inspect-Main-Screen IF FINAL THEN Go to m028 - 028m - Inspect Final
  'not needed as part of menu system - not implemented

'R022__000M 020m__Inspect-Main-Screen IF INITIAL THEN Go to m027
  'not needed as part of menu system - not implemented
  
'below R028 Rules are default behaviour like R012, so not implemented
'R028__028m  IF PASS THEN Go to M03B

'below R029 Rules are default behaviour like R012, so not implemented
'R029__029m  IF PASS THEN Go to MAIN
'R029__029m 027m__Inspect-Initial IF PASS THEN Go to MAIN
'R029__029m 029m__Inspect-Quality-Routine IF PASS THEN Go to MAIN
  
 
'below R031 rule implemented in menu, so not implemented
'R031__02Qm 020m__Inspect-Main-Screen IF ROUTINE-QUALITY THEN Go to m029


'below rules is conceptually workflow related to R014, but from a Bin perspective???
'R035__03Bm 02Qm__Fail-Component IF SUBMIT THEN Go to M02R - Fail Reason

  'Sexp for rule implementation  - added to S001 -- refactor in SporkLisp

'below R028 Rules are default behaviour like R012, so not implemented
'R036__14_Next_Screen 02Rm__Fail-Reason IF SUBMIT THEN Go to MAIN
'R036__14_Next_Screen 03Bm__Bin-Associate IF SUBMIT THEN Go to MAIN

'' End of 9 Rules - implemented as 1 Sexp :-)
 
 
'Sexp - S002
'02Qm__Fail-Component SUBMIT   02Rm    IF SUBMIT THEN Go to M02R       REASON1, SUBMIT EPC__MODEL__TYPE__MFRDATE__INSVCDATE__DTG_X_SVC Y-X_M02QDP__IP_1-0_EPC__MODEL__TYPE__MFRDATE__INSVCDATE__DTG_X_SVC__REASON1

 
'Sexp - S003
'028m__Inspect-Final  SUBMIT  __SUBMIT==PASS      03BM    IF PASS THEN Go to M03B


'*********************************************************************************
'*********************************************************************************
'*********************************************************************************

'Sexp code see http://en.wikipedia.org/wiki/S-expression


'init vars
strForm_Dest = "020m__Inspect-Main-Screen"   'open a stock "MAIN" page :-0)
strPROC_RESULT = ""

'S001 - Sexp for rule implementation - refactor in SporkLisp

'If (InStr(frmForm.Tag, "011m027m028m029m03Bm") > 0) And (frmForm.Status = "FAIL-MAINTENANCE") Then 'added R035 to Sexp
 ' below is above broken out for debugging...
 
    If (InStr(" 011m 027m 028m 029m 03Bm ", frmForm.tag) > 0) Then  '811 '911 convert this S001 to Spork Sexp... return string vs LISP List...
 
        If Not (IsNull(frmForm.PROC_RESULT)) Then
            strPROC_RESULT = frmForm.PROC_RESULT
        Else
            strPROC_RESULT = "oops" 'explicitly set for better comprehension / debugging - i.e. fix the bad data in SQL
        End If
        
          
        If (strPROC_RESULT = "Fail to Maintanence") Then 'added R035 to Sexp
            'maybe use control collection / array - i.e. "Controls"
            ' probably need to add other FAIL case - FAIL-PACK ?? -> :-) '911
             
            strForm_Dest = "02Qm__Fail-Component"
           
             
        End If ' If (InStr(" 011m 027m 028m 029m 03Bm ", frmForm.Tag) > 0) Then
    End If

'S002 - Sexp for rule implementation - refactor in SporkLisp
'Sexp2
'02Qm__Fail-Component SUBMIT   02Rm    IF SUBMIT THEN Go to M02R       REASON1, SUBMIT EPC__MODEL__TYPE__MFRDATE__INSVCDATE__DTG_X_SVC Y-X_M02QDP__IP_1-0_EPC__MODEL__TYPE__MFRDATE__INSVCDATE__DTG_X_SVC__REASON1

 'If (InStr(frmForm.Tag, "02Qm") > 0) Then 'added
 ' below is above broken out for debugging...

    If (InStr(" 02Qm ", frmForm.tag) > 0) Then  '811 '911 convert this Spork Sexp... return string vs LISP List...
               
        strForm_Dest = "02Rm__Fail-Reason"
            
    End If ' If (InStr(" 02Qm ", frmForm.Tag) > 0) Then
    
    
'S003 - Sexp for rule implementation - refactor in SporkLisp
'Sexp3
'028m__Inspect-Final  SUBMIT  __SUBMIT==PASS      03BM    IF PASS THEN Go to M03B - 03Bm__Bin-Associate


'If (InStr(frmForm.Tag, "011m027m028m029m03Bm") > 0) And (frmForm.Status = "PASS") Then 'added R035 to Sexp
 ' below is above broken out for debugging...

    If (InStr(" 028m ", frmForm.tag) > 0) Then  '811 '911 convert this S001 to Spork Sexp... return string vs LISP List...
 
        If Not (IsNull(frmForm.PROC_RESULT)) Then
            strPROC_RESULT = frmForm.PROC_RESULT
        Else
            strPROC_RESULT = "oops" 'explicitly set for better comprehension / debugging - i.e. fix the bad data in SQL
        End If ' If Not (IsNull(frmForm.PROC_RESULT)) Then
      
          
        If (strPROC_RESULT = "PASS") Then 'added R035 to Sexp
            'maybe use control collection / array - i.e. "Controls"
            ' probably need to add other FAIL case - FAIL-PACK ?? -> :-) '911
             
            strForm_Dest = "03Bm__Bin-Associate"
             
        End If 'If (strPROC_RESULT = "PASS") Then 'added R035 to Sexp
        
    End If ' If (InStr(" 028m ", frmForm.Tag) > 0) Then



'*********************************************************************************
'*********************************************************************************
'*********************************************************************************

'Dispatch of Dest Form

    LVM_M_Log ("strPROC_RESULT: " & strPROC_RESULT & " !")

    LVM_M_Log (frmForm.tag & " LVM_cmdSUBMIT_Click - goto Form " & strForm_Dest & " TimeStamp " & Now())
     
    LVM_M_fExecuteCommand "Open Subform", strForm_Dest, 1 'SOCKET each call to OpenGate via LVM Interface code...

End Sub

Public Sub LVM_M_fExecuteCommand(Optional strMenuCommand As Variant, Optional strCommandDetail As Variant, Optional iButton As Integer)

        'fRunCommand();  Documented in Function fExecuteCommand
                        '(Optional strMenuCommand As Variant, Optional strCommandDetail As Variant, _
                        '  Optional iButton As Integer)
                        'tbleRoleMenu
   
    'fRunCommand - find "senders" or "callers" of this - seems to be the best :-)
    'Logging - Start fExecuteCommand(Open Subform, frmDefaultStart_wfb, 1). Role = 9 from fExecuteCommmand

    Dim strForm_Dest As String

    strForm_Dest = strCommandDetail ' set as I think OG changes variable...
   
   
   LVM_M_Log ("LVM_fExecuteCommand " & strMenuCommand & " " & strCommandDetail & " strForm_Dest " & strForm_Dest)
   


  'fExecuteCommand strMenuCommand, strCommandDetail, iButton '911
    fExecuteCommand strMenuCommand, strCommandDetail, iButton '911
       'ideal to get to work eventually - may have to hard code deep into OpenGate for form mgt to work for now...
         ' **** Could possibly look into the Workflow code to see how they did it, if that's even applicable to this use case...
  
  ' reaching deeper into OpenGate than I want...
  '' need to forcibly open Dest_Form via the strCommandDetail variable directly
  
'Code trace of fExecuteCommand in OpenGate:
  'PASS CONTROL TO THE fRunCommand HANDLER (3.6.2 rewrite)
  '210   fRunCommand strMenuCommand, strCommandDetail, iButton, False


      ' sChangeSubform iButton, strCommandDetail, blnSubButton


  
    LVM_Log "sChangeSubform 1 " & strForm_Dest & " False"

    sChangeSubform 1, strForm_Dest, False 'best guess on how to force expected behavoir
  
  
End Sub

Public Sub LVM_M_Log(strMessage As String, Optional frmForm As Variant)

  If gLVM_Debug = True Then 'Debug Print via global
     Debug.Print strMessage
   
  End If
  
  ' hook into OpenGate Logging
   fLogEvent strMessage, auiDebug, False, "_LVM", auiInformation, False

End Sub


Public Function LVM_M_ColorIndex(CellColor As Range) ' from crazy hair Indian Excel Guru side - rhymes with Voodoo
ColorIndex = CellColor.Interior.ColorIndex
End Function

'MAL_L  Make A Lisp - from Github - prefix for the diagram...
Rem - https://github.com/kanaka/mal/blob/master/process/guide.md

'Option Explicit 'MAL_L_  Make A Lisp - from Github - prefix for the diagram...

Function MAL_M_1_READ(THX)

Rem line 311 ++ in js is a Regular Expression  "coathook" of legal characters
Rem line 311 - Internal Symbol names

Rem // Internal symbol names can consist of any printable (non-whitespace) character,
Rem // except for the following meta characters:        " ' ( ) , [ ] ` ~ { }
Rem // It is possible, though, to include these special characters into symbol names
Rem // by escaping them with a backslash '\'.

Rem - can read more on JS Prototypes - Ghost / Jekyl Blog guy?

Rem for now just rapid port the various BASIC implementations

Rem below line is just for debugging - can comment out
Rem THX = LI__M_Debug_Print("LI__M_READ: ", THX)

Rem mimic SporkLisp call tree for tokeninzing / parsing

Rem MAL_M_11_ReadLine  'also do tokeninze
Rem MAL_M_12_Read_Str - 'outputs AST


MAL_M_1_READ = THX

End Function

'################ parse, read, and user interaction
'
'def Read(s):
'    "Read a Scheme expression from a string."
'    return read_from(tokenize(s))
'
'parse = Read
'
'def tokenize(s):
'    "Convert a string into a list of tokens."
'    return s.replace('(',' ( ').replace(')',' ) ').split()
'
Function MAL_M_111_Tokenize(ByRef s As String) As Variant

Dim tmp
Dim tok As String
Dim itm
tok = replace(s, "(", " ( ")
tok = replace(tok, ")", " ) ")
tok = replace(tok, "[", " [ ")
tok = replace(tok, "]", " ] ")
tok = replace(tok, "{", " { ")
tok = replace(tok, "}", " } ")
tok = replace(tok, ",", " , ")
tok = replace(tok, "'", " ' ")
tok = replace(tok, "~", " ~ ")

Rem '911 may have to add some items from line 311 here - i.e. other char
Rem Line ~311 // except for the following meta characters:        " ' ( ) , [ ] ` ~ { }

tmp = Split(tok)
'If UBound(tmp, 1) = 0 Then
'    tokenize = tmp(0)
'Else
    Set LI__M_R_Tokenize = New Collection
    For Each itm In tmp
        LI__M_R_Tokenize.Add itm
    Next itm
'End If

End Function
Function MAL_M_2_EVAL(THX)

MAL_M_2_EVAL = THX
 
Rem MAL_M_21_Eval_AST

Rem MAL_M_211_Symbol
Rem MAL_M_211_List
Rem MAL_M_211_Number

Rem MAL_M_22_Apply

Rem *Create Env*
Rem MAL_M_221_Let
Rem MAL_M_222_Apply_Quoted
Rem MAL_M_223_Try_Catch


Rem MAL_M_224_Do
Rem MAL_M_225_If
Rem MAL_M_226_QuasiQuote

Rem *Update Env*
Rem MAL_M_227_Def
Rem MAL_M_228_DefMacro
 
Rem MAL_M_229_Quote
Rem MAL_M_22A_MacroExpand - really fexpr

Rem Core - has box of items - see pix


Rem Env - links to symbol lookup - part of 3 part MCE "circle-cycle"
 

 
Rem below line is just for debugging - can comment out
Rem THX = LI__M_Debug_Print("LI__M_EVAL: ", THX)

End Function

Function MAL_M_3_PRINT(THX)

MAL_M_3_PRINT = THX

Rem MAL_M_31_Pr_Str - converts AST
Rem MAL_M_32_PrintLine - goes to STDIO, etc.

Rem below line is just for debugging - can comment out
Rem THX = LI__M_Debug_Print("LI__M_PRINT: ", THX)

End Function


Function FOS(THX)
Rem Mimic MAL (Make a Lisp) and emuLisp (PicoLisp) with variable / function names
Rem no objects will be used (for the core language), just associative arrays (Dictionaries, Bundles), text, and numbers
Rem Collections (VBA) and  Lists  (RFO) will  be used in addition to the associative arrays..

Rem for FFI, things like ADO, ODBC, etc. will use native memory memory management in the BASIC code
Rem use cross compatible systax to RFO BASIC / SmallBasic - least amount of changes, and localize those
Rem Note: instead of text file input / output, lines in Excel are used
Rem    ... stair step cell formulas allow dragdown test harness  (blank extra cells to clean up from drag down)

Rem PLS = LI__M_REP(THX)

Rem Function LI__M_REP(THX) 'only included for xRef from MAL - Make a Lisp

THX = MAL_M_1_READ(THX)
THX = MAL_M_2_EVAL(THX)
THX = MAL_M_3_PRINT(THX)

FOS = THX

Rem below line is just for debugging - can comment out
THX = LI__M_z_Debug_Print("LI__M_PRINT: ", THX)

End Function

'qwer xyzzy - strings to find this place in the file....

'VRC_M VersionControlLib

'------SPORK library, by Tom Spoon 6 June 2013-----------------------
'------Licensed under the Eclipse Public License - v 1.0-------------
'See the License module, or License.txt for more information.

'Some primitive version control stuff.  Meant to facilitate use of spork with git.
'Typical workflow is to spit source files out to git for an initial commit.
'As changes are made, blast out the source again, and let git sort the differences.
'Git commits are - currently - handled manually by responsible adults.

' Note: below code doesn't work in many "locked down" environments - DET 2016_03_15_0000

'Option Explicit 'VRC_M_ VersionControlLib

Public Sub VRC_M_dumpAllCode(Optional path As String, Optional ext As String)
Dim vbc As VBComponent
If path = vbNullString Then path = ActiveWorkbook.path & "\"
For Each vbc In ActiveWorkbook.VBProject.VBComponents
    CDP_M_dumpCode vbc.name, path, ext
Next vbc
End Sub
'tries to refresh code modules with serialized code.
Public Sub VRC_M_readAllCode(Optional path As String, Optional ext As String)
Dim modules As Dictionary
Dim vbc As VBComponent
Dim sourcepath As String

If path = vbNullString Then path = ActiveWorkbook.path & "\"

If ext = vbNullString Then ext = ".txt"
For Each vbc In ActiveWorkbook.VBProject.VBComponents
    sourcepath = path & vbc.name & ext

    
Next vbc

End Sub

Rem FOS_M_ Fork of Spork

Rem LII_C   LispInterpreter


Rem Public interpreter As Dictionary LispInterpreter

Public expr As Variant

Private Sub FOS_M_InputBox_BeforeUpdate(ByVal Cancel As MSForms.ReturnBoolean)
If InputBox.value <> vbNullString Then
    bind expr, LII_C_EVAL(LII_C_READ(InputBox.value))
    PrintBox.value = printstr(expr)
Else
    PrintBox.value = vbNullString
End If
End Sub

Private Sub FOS_M_PrintBox_AfterUpdate()
InputBox.SetFocus
End Sub


Private Sub FOS_M_UserForm_Initialize()
Rem Set interpreter = New LispInterpreter
 LII_C_Class_Initialize

InputBox.EnterKeyBehavior = True
End Sub




'Option Compare Database


'dim globals from old zzzLVM module - now part of UTL_L for Utilities

Public gsCurrOSDBPath As String

Public gsCurrOSDBPath_PLS As String
Public gsCurrOSDBPth_THX As String
Public gsCurrOSDBPath_ARK As String
Public gsCurrOSDBPath_DAT As String

Public gsCurrOSDBPath_PLS_DirList As String
Public gsCurrOSDBPath_THX_DirList As String
Public gsCurrOSDBPath_ARK_DiraList As String
Public gsCurrOSDBPath_DAT_DirList As String

Public gsCurrDirFile, gsCurrFile, gsB, gsE, gsD, gsF, gsC, gsA As String
Public gLVM_Debug As Boolean

Rem - Legacy comment - works for VBA and RFO

Sub UTL_L_ExportMods() 'may not work depending on machine "Trust Center" permissions
    Dim i As Integer
    With ActiveWorkbook.VBProject.VBComponents
        For i = 1 To .count
            Range("A1").offset(i - 1, 0).value = .Item(i).Type  'don't replace Range here as it's a VBA value :-0)
            Range("A1").offset(i - 1, 1).value = .Item(i).name 'don't replace Range here as it's a VBA value :-0)
            .Item(i).Export "C:\Temp\" & .Item(i).name & ".bas"
        Next i
    End With
End Sub
Sub UTL_L_ImportMods()
Dim x
    With ActiveWorkbook.VBProject.VBComponents
        For i = 0 To WorksheetFunction.CountA(Range("A:A")) - 1  'don't replace Range here as it's a VBA value :-0)
            .Import "C:\Temp\" & Range("B1").offset(i, 0).text & ".bas"  'don't replace Range here as it's a VBA value :-0)
        Next i
    End With
End Sub

' For further supporting comments, requirements traceability, IA / PEO / Army compliance items please see notes, etc. refered to in source code: (i.e. Excel SUPER TABLE and Technical PowerPoint briefs)


Public Function LVM_M_Timer(currForm As Variant) As Variant

Call LVM_M_ToDo 'Daily Tasks - 3 Folders style


gsCurrDirFile = dir(gsCurrOSDBPath_PLS_DirList) 'Looking for a PLS with TAT format

Debug.Print Now(), gsCurrOSDBPath_PLS_DirList, gsCurrDirFile

'Do While gsCurrDirFile <> ""  'comment out for single file test run - also comment outLoop below
' PLS_Process
Debug.Print gsCurrDirFile
Debug.Print Now()
'Read File into Table - see example from test form

'Add PLS to BEDFCA and Move the file to ARK


  'MsgBox (Len(FileToOneString("C:\plsthx\1234567890.txt")))
 gsCurrFile = gsCurrOSDBPath_PLS + gsCurrDirFile
 
 
 Debug.Print gsCurrDirFile
 
 gsB = left$(gsCurrDirFile, 23) ' Get Time
 Debug.Print "B:", gsB
 
 gsE = Mid$(gsCurrDirFile, 25, 4)
 Debug.Print "E:", gsE
 
 gsD = Mid$(gsCurrDirFile, 30, 2)
 Debug.Print "D:", gsD
 
 gsF = Mid$(gsCurrDirFile, 33, 15)
 Debug.Print "F:", gsF
 
 gsC = Mid$(gsCurrDirFile, 49, 10)
 Debug.Print "C:", gsC
 
 gsA = Mid$(gsCurrDirFile, 60, 29)
 Debug.Print "A:", gsA

 'Me.Recordset.B = Left$(gsCurrFile, 24) ' Get Time
 'Debug.Print Len(FileToOneString(gsCurrFile)) - immediately add to .Memo Field
 
  
  'fill out 6 core fields
    '
    'Fire DNA rule engine - includes parsing of all ini values :- ) see test form

' PLS_Process_Eng
gsCurrDirFile = dir
'Loop

currForm.txtTimer.value = Now()

  DoEvents   ' Do Events Looper
  
LVM_M_Timer = gsCurrDirFile 'just return the last time



End Function

Public Function LVM_M_Init(currForm As Variant) As Variant
  'init Logistics Virtual Machine - micro kernal bootstrap
  
gLVM_Debug = True
  
Call LVM_M_ToDo 'Daily Tasks - 3 Folders style

        ' - local app path, PLS, THX, ARK
' Left(CurrentProject.FullName, InstrRev(CurrentProject.FullName, "\"))

'narrative of the queries / spreadsheets needed

  
gsCurrOSDBPath = left(CurrentProject.FullName, InStrRev(CurrentProject.FullName, "\"))
gsCurrOSDBPath_PLS = gsCurrOSDBPath + "PLS\"
gsCurrOSDBPath_THX = gsCurrOSDBPath + "THX\"
gsCurrOSDBPath_ARK = gsCurrOSDBPath + "ARK\"
gsCurrOSDBPath_DAT = gsCurrOSDBPath + "DAT\"


gsCurrOSDBPath_PLS_DirList = gsCurrOSDBPath_PLS + "*.txt"
gsCurrOSDBPath_THX_DirList = gsCurrOSDBPath_THX + "*.txt"
gsCurrOSDBPath_ARK_DirList = gsCurrOSDBPath_ARK + "*.txt"
gsCurrOSDBPath_DAT_DirList = gsCurrOSDBPath_DAT + "*.txt"

LVM_Init = gsCurrOSDBPath

End Function

Public Function LVM_M_cmdSTOP_Timer_Click(currForm As Variant)
   'Call LVM_cmdSTART_Timer_Click(Me)
   'Call LVM_cmdSTOP_Timer_Click(Me)

  ' 'Read Tag of _dev_frm_Test for Me.Timer_Interval=0
  currForm.TimerInterval = 0
  
    
End Function

Public Function LVM_M_cmdSTART_Timer_Click(currForm As Variant)
   'Call LVM_cmdSTART_Timer_Click(Me)
   'Call LVM_cmdSTOP_Timer_Click(Me)
   
    'Read Tag of _dev_frm_Test for Me.Timer_Interval=500
  ' Port routine to RFO-BASIC - possibly with RFO code that converts VBA to RFO
  
   currForm.TimerInterval = 500
End Function


Public Function LVM_M_ToDo() As Variant
'In Process
  ' Split Screen - Meera working on
  ' 6 Fields - BEDFCA from filename
  
'Waiting On
 ' Dry Run of Data import from Oracle, including smoke test
  
'To Do
  
'*** Core LVM Releated ***
' Complete THX loop


' Generate Super Table based Tables
' - Change m002 to m020
' - fix table names to use __split -
' - add Screen Names to mXXX table / form names
' - THX format
' - core test files on main BEDFCA form - 7z -
 '  - PDF, PLS, THX, VBA Selenium
   
   
'*********** LVM_Pelican_Network_Doc_Notes ****************************
'Pelican case needs a network to "dock"
   '- has a store and forward capability
    '- Can use AT&T router, or seperate Leslie 4 port USB powered router - DHCP or static?)
    

'*** DNA Related ****

' put code to handle DNA - SCAN, WRITE, AddRecord in LVM core
' SUPER_Table, Roles - as tables - need to do field cross walk for global rules
' Current Screen, Next Screen - DNA, Rules - use screens as indexes


' including Username add / remove from Windows - VBScript, PowerShell, g: Registry, SAM :-)
 'Windows Automation - maybe HTA :-)


'**** Lower - Later *****
' _A _B versions of client / server Access
' CAC
' PDF (unclocked, then CAC version)

' Client Access - verification of file sharing - possibly via NAS
' Railo / RFO integration - GET - including "psuedo multi-tasking" file processing loop
' Encinitas / DoEvents (Fusebox) loop in RFO integration

'Housekeeping

 ' put items in To List - use BEDFCA Column , rough priority
 
 'Misc note below
'http://bytes.com/topic/access/answers/199718-get-customerid-new-record-after-recordset-addnew
' If this data is in an Access table, the autonumber is assigned as soon as
'you start to add the record, so you can even get the number before the
'Update if you wish:
'rs.AddNew
'Debug.Print rs!CustomerID
 
 'Pass current Form  ----- Add PLS to BEDFCA and Move the file to ARK
  
  'Note - forced conversion of Application-Name to Application_Name means
   ' we have to do the same for cleaning input - those are rules with test data

 'gsCurrOSDBPath gsCurrOSDBPath_PLS gsCurrOSDBPath_THX gsCurrOSDBPath_ARK
  ' gsCurrOSDBPath_DAT

 
  ' possibly web services to OpenL Tablets - Open Source Expert System with Excel
     '---- just steal the ideas
     
  ' 3 directories - PLS, THX, ARK (archive)
  ' Process - read PLS, archive to ARK, write to THX
  ' see whiteboard from 2014_05_27 - Double Triple Colors :-)
  
   'need microkernal load of tables and test data (self test)
   '
 

    ' test data set by buttons :-)
    
  'Read PLS

 

LVM_ToDo = "Be Productive"

End Function

Public Sub UTL_L_FileMove(file$, pathFrom$, pathTo$)
 'g: access vba move files from one folder to another
 ' or FileCopy "C:\Users\Ron\SourceFolder\Test.xls", "C:\Users\Ron\DestFolder\Test.xls"
 
    Dim fso As Object
    Dim sourceFile As String
    Dim targetFile As String
    Dim answer As Integer

    Set fso = CreateObject("Scripting.FileSystemObject")
    sourceFile = pathFrom$ & "\" & file$
    targetFile = pathTo$ & "\" & file$
      
    If fso.filexExists(targetFile) Then
        answer = MsgBox("File already exists in this location. " _
            & "Are you sure you want to continue? If you continue " _
            & "the file at destination will be deleted!", _
            vbInformation + vbYesNo)
        If answer = vbNo Then
            Exit Sub
        End If
        Kill targetFile
    End If
    fso.MoveFile sourceFile, targetFile
    Set fso = Nothing
End Sub


Public Function UTL_L_FileToOneString(FileIN$) As Variant

'Rem Function FileToOneString()
'Rem FileToOneString(FileIN$)

Dim MyReadNum As Integer
Dim theGuts As Variant
'--

'Dim FileIN$
'FileIN$ = "C:\WINDOWS\Application Data\AVG7\Log\emc.log"
'--
MyReadNum = FreeFile
Open FileIN$ For Input As MyReadNum

theGuts = Input$(LOF(MyReadNum), MyReadNum)
Close MyReadNum

'MsgBox "Length is " & Len(theGuts) & vbCrLf & Right(theGuts, 40)

FileToOneString = theGuts
End Function


Sub UTL_L_UnhideAllSheets()
Dim ws As Worksheet
For Each ws In ActiveWorkbook.Worksheets
  ws.Visible = xlSheetVisible
Next ws
End Sub
